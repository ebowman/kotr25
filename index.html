<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>King of the Road 2025 Strava Routes</title>
  <script src="https://strava-embeds.com/embed.js"></script>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet-gpx@1.7.0/gpx.js"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />
  <style>
    body {
      font-family: 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      line-height: 1.6;
      padding: 0;
      background: #f9f9f9;
      margin: 0;
      color: #333;
    }
    .container {
      max-width: 1000px;
      margin: 0 auto;
      padding: 0 2rem 2rem;
    }
    .banner {
      width: 100%;
      height: auto;
      max-height: 300px;
      object-fit: cover;
      margin-bottom: 1rem;
    }
    h1 {
      text-align: center;
      margin: 1.5rem 0;
      color: #222;
    }
    h2 {
      margin-top: 1rem;
      margin-bottom: 0.75rem;
      color: #333;
      border-bottom: 2px solid #ddd;
      padding-bottom: 0.5rem;
      cursor: pointer;
      user-select: none;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    h2:after {
      content: "▼";
      font-size: 0.8rem;
      transition: transform 0.3s ease;
    }
    h2.collapsed:after {
      transform: rotate(-90deg);
    }
    h3 {
      margin-top: 1rem;
      color: #555;
    }
    .day-section {
      margin-bottom: 3rem;
      background: white;
      border-radius: 10px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.05);
      padding: 1.5rem;
    }
    .day-content {
      transition: max-height 0.5s ease, opacity 0.3s ease;
      max-height: 2000px;
      opacity: 1;
      overflow: hidden;
    }
    .day-content.collapsed {
      max-height: 0;
      opacity: 0;
      margin-top: 0;
    }
    .route-container {
      display: flex;
      flex-wrap: wrap;
      gap: 2rem;
      margin-top: 1rem;
    }
    .route {
      flex: 1;
      min-width: 300px;
      border: 1px solid #eee;
      padding: 1rem;
      background: #fcfcfc;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.03);
    }
    .date {
      font-size: 0.9rem;
      color: #666;
      margin-top: 0.25rem;
      font-weight: normal;
    }
    .intro {
      text-align: center;
      max-width: 800px;
      margin: 0 auto 2rem;
      padding-bottom: 1rem;
      border-bottom: 1px solid #eee;
    }
    .gpx-map {
      height: 400px;
      margin-top: 1rem;
      border-radius: 8px;
      overflow: hidden;
      border: 1px solid #ddd;
    }
    .gpx-download {
      display: flex;
      flex-direction: column;
      margin-top: 1.5rem;
      padding: 1rem;
      background: #f5f9ff;
      border-radius: 8px;
      border: 1px solid #d0e0f0;
      box-shadow: 0 2px 5px rgba(0,0,0,0.03);
    }
    .gpx-download-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    .gpx-btn {
      display: inline-flex;
      align-items: center;
      padding: 10px 16px;
      background: linear-gradient(to bottom, #3498db, #2980b9);
      color: white;
      text-decoration: none;
      border-radius: 6px;
      font-size: 0.95rem;
      font-weight: 500;
      transition: all 0.2s ease;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      border: none;
    }
    .gpx-btn:hover {
      background: linear-gradient(to bottom, #2980b9, #2471a3);
      box-shadow: 0 3px 6px rgba(0,0,0,0.15);
      transform: translateY(-1px);
    }
    .gpx-btn:active {
      transform: translateY(1px);
      box-shadow: 0 1px 2px rgba(0,0,0,0.1);
    }
    .gpx-btn::before {
      content: "⬇️";
      margin-right: 8px;
      font-size: 1rem;
    }
    .gpx-info {
      margin-top: 0.8rem;
      padding: 0.4rem 0;
      font-size: 0.9rem;
      color: #666;
      border-top: 1px solid #e8f0f8;
    }
    .map-tabs {
      display: flex;
      border-bottom: 1px solid #ddd;
      margin-bottom: 1rem;
    }
    .map-tab {
      padding: 8px 15px;
      cursor: pointer;
      border: 1px solid transparent;
      border-bottom: none;
      margin-right: 5px;
      border-radius: 5px 5px 0 0;
      transition: all 0.2s ease;
    }
    .map-tab.active {
      background: #f0f8ff;
      border-color: #d0e0f0;
      font-weight: bold;
    }
    .map-tab:hover:not(.active) {
      background: #f5f5f5;
    }
    .decision-point {
      width: 20px;
      height: 20px;
      background-color: #ff6b6b;
      border: 2px solid white;
      border-radius: 50%;
    }
    .legend {
      background: white;
      padding: 8px;
      border-radius: 4px;
      border: 1px solid #ddd;
      margin-top: 8px;
      font-size: 0.85rem;
    }
    .legend-item {
      display: flex;
      align-items: center;
      margin-bottom: 4px;
    }
    .legend-color {
      width: 15px;
      height: 3px;
      margin-right: 6px;
    }
    .legend-point {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      margin-right: 6px;
    }
    .map-fallback-info {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: white;
      padding: 15px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      text-align: center;
      max-width: 90%;
      z-index: 400;
    }
    .map-note {
      font-size: 0.8rem;
      color: #666;
      margin-top: 10px;
    }
    .leaflet-container {
      position: relative;
      z-index: 1;
    }
    
    /* Weather Widget Styles */
    .weather-widget {
      background: linear-gradient(to bottom, #f0f8ff, #e6f3ff);
      border-radius: 10px;
      padding: 16px;
      margin-top: 20px;
      box-shadow: 0 4px 6px rgba(0,0,0,0.06);
      border: 1px solid #d0e0f0;
      display: flex;
      flex-direction: column;
      font-size: 0.9rem;
    }
    
    .weather-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
      padding-bottom: 10px;
      border-bottom: 1px solid #e0e9f5;
    }
    
    .weather-title {
      font-weight: 600;
      font-size: 1rem;
      color: #2c3e50;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .weather-title i {
      color: #3498db;
    }
    
    .weather-refresh {
      font-size: 0.8rem;
      color: #7f8c8d;
      cursor: pointer;
      padding: 4px 8px;
      border-radius: 4px;
      transition: all 0.2s;
    }
    
    .weather-refresh:hover {
      background: #e0e9f5;
      color: #2980b9;
    }
    
    .weather-content {
      display: flex;
      flex-wrap: wrap;
      gap: 16px;
    }
    
    .weather-day {
      flex: 1;
      min-width: 150px;
      background: white;
      border-radius: 8px;
      padding: 12px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.03);
      text-align: center;
      transition: transform 0.2s;
    }
    
    .weather-day:hover {
      transform: translateY(-3px);
      box-shadow: 0 4px 8px rgba(0,0,0,0.08);
    }
    
    .weather-date {
      font-weight: 600;
      margin-bottom: 8px;
      color: #34495e;
    }
    
    .weather-icon {
      font-size: 2rem;
      margin: 8px 0;
      color: #f39c12;
    }
    
    .weather-temp {
      font-size: 1.4rem;
      font-weight: 600;
      margin-bottom: 4px;
      color: #2c3e50;
    }
    
    .weather-desc {
      color: #7f8c8d;
      font-size: 0.85rem;
      margin-bottom: 8px;
    }
    
    .weather-details {
      display: flex;
      justify-content: space-around;
      font-size: 0.8rem;
      color: #34495e;
    }
    
    .weather-loading {
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 30px;
      color: #7f8c8d;
    }
    
    .weather-loading i {
      animation: spin 2s linear infinite;
      margin-right: 8px;
      color: #3498db;
    }
    
    .weather-error {
      color: #e74c3c;
      text-align: center;
      padding: 15px;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    .weather-alert {
      background: #fef9e7;
      border-left: 4px solid #f39c12;
      padding: 10px;
      margin-top: 10px;
      border-radius: 4px;
      font-size: 0.85rem;
    }
    
    .weather-alert.severe {
      background: #fae1dd;
      border-left-color: #e74c3c;
    }
  </style>
</head>
<body>
  <header>
    <img src="banner.jpg" alt="King of the Road 2025 Banner" class="banner">
  </header>
  
  <div class="container">
    <h1>King Of The Road 2025 Strava Routes</h1>
    
    <div class="intro">
      <p>Welcome to the King of the Road 2025! Below you'll find all the routes for each day of the event. Use the interactive maps to explore both short and long options, and download GPX files for your GPS device.</p>
      
      <details>
        <summary style="cursor: pointer; color: #3498db; margin-top: 10px;">
          <strong>Trouble seeing the maps?</strong>
        </summary>
        <div style="background: #f8f9fa; padding: 15px; margin-top: 10px; border-radius: 5px; font-size: 0.9rem; text-align: left;">
          <p>The interactive maps require a web server to work properly. If you're viewing this file locally (via file:// protocol), you may see gray boxes instead of maps.</p>
          
          <p><strong>Quick solution:</strong> You can still download the GPX files directly and use them with your GPS device or other mapping software.</p>
          
          <p><strong>For interactive maps:</strong> Run a simple web server from this directory. Here are some options:</p>
          
          <ul style="margin-left: 20px;">
            <li>Python: <code>python -m http.server</code> (then open <a href="http://localhost:8000">http://localhost:8000</a>)</li>
            <li>Node.js: <code>npx serve</code> (then open the URL shown)</li>
            <li>Or upload the files to any web hosting service</li>
          </ul>
        </div>
      </details>
    </div>

    <div class="day-section">
      <h2 class="day-toggle">Day 0 - Warm-up Ride <span class="date">May 22, 2025</span></h2>
      <div class="day-content">
        <div class="route">
          <h3>Warm-up Route</h3>
          <div class="strava-embed-placeholder" data-embed-type="route" data-embed-id="3352952321743025716" data-style="standard" data-map-hash="10.13/46.0523/14.5781" data-from-embed="true"></div>
          
          <div class="gpx-map" id="map-day0">
            <div class="map-fallback-info">
              <strong>Interactive Map</strong>
              <p>If the map doesn't appear, try viewing in a web server or download the GPX file below.</p>
              <div class="map-note">
                Note: Interactive maps may not work when viewing via file:// protocol.
              </div>
            </div>
          </div>
          
          <div class="weather-widget" id="weather-day0" data-lat="46.0523" data-lon="14.5781" data-date="2025-05-22">
            <div class="weather-header">
              <div class="weather-title">
                <i class="fas fa-cloud-sun"></i> Weather Forecast
                <span style="font-size: 0.8rem; font-weight: normal; margin-left: 8px; color: #666;">Ljubljana, Slovenia</span>
              </div>
              <div class="weather-refresh" onclick="refreshWeather('day0')">
                <i class="fas fa-sync-alt"></i> Refresh
              </div>
            </div>
            <div class="weather-content">
              <div class="weather-loading">
                <i class="fas fa-spinner"></i> Loading weather forecast...
              </div>
            </div>
            <div class="weather-toggle-container" style="text-align: center; margin-top: 8px; font-size: 0.85rem;">
              <a href="#" onclick="toggleForecastMode('day0', 'historical'); return false;" style="margin-right: 15px; color: #3498db;">
                <i class="fas fa-history"></i> Historical Average
              </a>
              <a href="#" onclick="toggleForecastMode('day0', 'forecast'); return false;" style="color: #3498db;">
                <i class="fas fa-cloud-sun-rain"></i> Current Forecast
              </a>
            </div>
          </div>
          
          <div class="gpx-download">
            <div class="gpx-download-row">
              <a href="gpx/D0_Warm-up.gpx" download class="gpx-btn">Download GPX File</a>
            </div>
            <div class="gpx-info">
              Compatible with Garmin, Wahoo, and all GPS cycling computers
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="day-section">
      <h2 class="day-toggle">Day 1 <span class="date">May 23, 2025</span></h2>
      <div class="day-content">
        <div class="route-container">
          <div class="route">
            <h3>Short Ride Option</h3>
            <div class="strava-embed-placeholder" data-embed-type="route" data-embed-id="3352952599441377432" data-style="standard" data-from-embed="false"></div>
            <div class="gpx-download">
              <div class="gpx-download-row">
                <a href="gpx/D1_East Short.gpx" download class="gpx-btn">Download GPX File</a>
              </div>
              <div class="gpx-info">
                Compatible with Garmin, Wahoo, and all GPS cycling computers
              </div>
            </div>
          </div>
          <div class="route">
            <h3>Long Ride Option</h3>
            <div class="strava-embed-placeholder" data-embed-type="route" data-embed-id="3352952828352792116" data-style="standard" data-from-embed="false"></div>
            <div class="gpx-download">
              <div class="gpx-download-row">
                <a href="gpx/D1_East_Long.gpx" download class="gpx-btn">Download GPX File</a>
              </div>
              <div class="gpx-info">
                Compatible with Garmin, Wahoo, and all GPS cycling computers
              </div>
            </div>
          </div>
        </div>
        
        <h3>Compare Routes</h3>
        <div class="map-tabs">
          <div class="map-tab active" data-tab="day1-comparison">Split Point Comparison</div>
          <div class="map-tab" data-tab="day1-short">Short Route</div>
          <div class="map-tab" data-tab="day1-long">Long Route</div>
        </div>
        
        <div class="gpx-map" id="map-day1">
          <div class="map-fallback-info">
            <strong>Interactive Map</strong>
            <p>If the map doesn't appear, try viewing in a web server or download the GPX files below.</p>
            <div class="map-note">
              Note: Interactive maps may not work when viewing via file:// protocol.
            </div>
          </div>
        </div>
        
        <div class="weather-widget" id="weather-day1" data-lat="46.0523" data-lon="14.5781" data-date="2025-05-23">
          <div class="weather-header">
            <div class="weather-title">
              <i class="fas fa-cloud-sun"></i> Weather Forecast
              <span style="font-size: 0.8rem; font-weight: normal; margin-left: 8px; color: #666;">Ljubljana, Slovenia</span>
            </div>
            <div class="weather-refresh" onclick="refreshWeather('day1')">
              <i class="fas fa-sync-alt"></i> Refresh
            </div>
          </div>
          <div class="weather-content">
            <div class="weather-loading">
              <i class="fas fa-spinner"></i> Loading weather forecast...
            </div>
          </div>
          <div class="weather-toggle-container" style="text-align: center; margin-top: 8px; font-size: 0.85rem;">
            <a href="#" onclick="toggleForecastMode('day1', 'historical'); return false;" style="margin-right: 15px; color: #3498db;">
              <i class="fas fa-history"></i> Historical Average
            </a>
            <a href="#" onclick="toggleForecastMode('day1', 'forecast'); return false;" style="color: #3498db;">
              <i class="fas fa-cloud-sun-rain"></i> Current Forecast
            </a>
          </div>
        </div>
        <div class="legend">
          <div class="legend-item">
            <div class="legend-color" style="background: blue;"></div>
            <span>Common Route</span>
          </div>
          <div class="legend-item">
            <div class="legend-color" style="background: green;"></div>
            <span>Short Route</span>
          </div>
          <div class="legend-item">
            <div class="legend-color" style="background: red;"></div>
            <span>Long Route</span>
          </div>
          <div class="legend-item">
            <div class="legend-point" style="background: #ff6b6b;"></div>
            <span>Decision Point</span>
          </div>
        </div>
      </div>
    </div>

    <div class="day-section">
      <h2 class="day-toggle">Day 2 <span class="date">May 24, 2025</span></h2>
      <div class="day-content">
        <div class="route-container">
          <div class="route">
            <h3>Short Ride Option</h3>
            <div class="strava-embed-placeholder" data-embed-type="route" data-embed-id="3352953250499092020" data-style="standard" data-from-embed="false"></div>
            <div class="gpx-download">
              <div class="gpx-download-row">
                <a href="gpx/D2_North_Short.gpx" download class="gpx-btn">Download GPX File</a>
              </div>
              <div class="gpx-info">
                Compatible with Garmin, Wahoo, and all GPS cycling computers
              </div>
            </div>
          </div>
          <div class="route">
            <h3>Long Ride Option</h3>
            <div class="strava-embed-placeholder" data-embed-type="route" data-embed-id="3352953056042166424" data-style="standard" data-from-embed="false"></div>
            <div class="gpx-download">
              <div class="gpx-download-row">
                <a href="gpx/D2_North_Long.gpx" download class="gpx-btn">Download GPX File</a>
              </div>
              <div class="gpx-info">
                Compatible with Garmin, Wahoo, and all GPS cycling computers
              </div>
            </div>
          </div>
        </div>
        
        <h3>Compare Routes</h3>
        <div class="map-tabs">
          <div class="map-tab active" data-tab="day2-comparison">Split Point Comparison</div>
          <div class="map-tab" data-tab="day2-short">Short Route</div>
          <div class="map-tab" data-tab="day2-long">Long Route</div>
        </div>
        
        <div class="gpx-map" id="map-day2">
          <div class="map-fallback-info">
            <strong>Interactive Map</strong>
            <p>If the map doesn't appear, try viewing in a web server or download the GPX files below.</p>
            <div class="map-note">
              Note: Interactive maps may not work when viewing via file:// protocol.
            </div>
          </div>
        </div>
        
        <div class="weather-widget" id="weather-day2" data-lat="46.0523" data-lon="14.5781" data-date="2025-05-24">
          <div class="weather-header">
            <div class="weather-title">
              <i class="fas fa-cloud-sun"></i> Weather Forecast
              <span style="font-size: 0.8rem; font-weight: normal; margin-left: 8px; color: #666;">Ljubljana, Slovenia</span>
            </div>
            <div class="weather-refresh" onclick="refreshWeather('day2')">
              <i class="fas fa-sync-alt"></i> Refresh
            </div>
          </div>
          <div class="weather-content">
            <div class="weather-loading">
              <i class="fas fa-spinner"></i> Loading weather forecast...
            </div>
          </div>
          <div class="weather-toggle-container" style="text-align: center; margin-top: 8px; font-size: 0.85rem;">
            <a href="#" onclick="toggleForecastMode('day2', 'historical'); return false;" style="margin-right: 15px; color: #3498db;">
              <i class="fas fa-history"></i> Historical Average
            </a>
            <a href="#" onclick="toggleForecastMode('day2', 'forecast'); return false;" style="color: #3498db;">
              <i class="fas fa-cloud-sun-rain"></i> Current Forecast
            </a>
          </div>
        </div>
        <div class="legend">
          <div class="legend-item">
            <div class="legend-color" style="background: blue;"></div>
            <span>Common Route</span>
          </div>
          <div class="legend-item">
            <div class="legend-color" style="background: green;"></div>
            <span>Short Route</span>
          </div>
          <div class="legend-item">
            <div class="legend-color" style="background: red;"></div>
            <span>Long Route</span>
          </div>
          <div class="legend-item">
            <div class="legend-point" style="background: #ff6b6b;"></div>
            <span>Decision Point</span>
          </div>
        </div>
      </div>
    </div>

    <div class="day-section">
      <h2 class="day-toggle">Day 3 <span class="date">May 25, 2025</span></h2>
      <div class="day-content">
        <div class="route-container">
          <div class="route">
            <h3>Short Ride Option</h3>
            <div class="strava-embed-placeholder" data-embed-type="route" data-embed-id="3352953610025735896" data-style="standard" data-from-embed="false"></div>
            <div class="gpx-download">
              <div class="gpx-download-row">
                <a href="gpx/D3_West_Short.gpx" download class="gpx-btn">Download GPX File</a>
              </div>
              <div class="gpx-info">
                Compatible with Garmin, Wahoo, and all GPS cycling computers
              </div>
            </div>
          </div>
          <div class="route">
            <h3>Long Ride Option</h3>
            <div class="strava-embed-placeholder" data-embed-type="route" data-embed-id="3352953454882061876" data-style="standard" data-from-embed="false"></div>
            <div class="gpx-download">
              <div class="gpx-download-row">
                <a href="gpx/D3_West_Long.gpx" download class="gpx-btn">Download GPX File</a>
              </div>
              <div class="gpx-info">
                Compatible with Garmin, Wahoo, and all GPS cycling computers
              </div>
            </div>
          </div>
        </div>
        
        <h3>Compare Routes</h3>
        <div class="map-tabs">
          <div class="map-tab active" data-tab="day3-comparison">Split Point Comparison</div>
          <div class="map-tab" data-tab="day3-short">Short Route</div>
          <div class="map-tab" data-tab="day3-long">Long Route</div>
        </div>
        
        <div class="gpx-map" id="map-day3">
          <div class="map-fallback-info">
            <strong>Interactive Map</strong>
            <p>If the map doesn't appear, try viewing in a web server or download the GPX files below.</p>
            <div class="map-note">
              Note: Interactive maps may not work when viewing via file:// protocol.
            </div>
          </div>
        </div>
        
        <div class="weather-widget" id="weather-day3" data-lat="46.0523" data-lon="14.5781" data-date="2025-05-25">
          <div class="weather-header">
            <div class="weather-title">
              <i class="fas fa-cloud-sun"></i> Weather Forecast
              <span style="font-size: 0.8rem; font-weight: normal; margin-left: 8px; color: #666;">Ljubljana, Slovenia</span>
            </div>
            <div class="weather-refresh" onclick="refreshWeather('day3')">
              <i class="fas fa-sync-alt"></i> Refresh
            </div>
          </div>
          <div class="weather-content">
            <div class="weather-loading">
              <i class="fas fa-spinner"></i> Loading weather forecast...
            </div>
          </div>
          <div class="weather-toggle-container" style="text-align: center; margin-top: 8px; font-size: 0.85rem;">
            <a href="#" onclick="toggleForecastMode('day3', 'historical'); return false;" style="margin-right: 15px; color: #3498db;">
              <i class="fas fa-history"></i> Historical Average
            </a>
            <a href="#" onclick="toggleForecastMode('day3', 'forecast'); return false;" style="color: #3498db;">
              <i class="fas fa-cloud-sun-rain"></i> Current Forecast
            </a>
          </div>
        </div>
        <div class="legend">
          <div class="legend-item">
            <div class="legend-color" style="background: blue;"></div>
            <span>Common Route</span>
          </div>
          <div class="legend-item">
            <div class="legend-color" style="background: green;"></div>
            <span>Short Route</span>
          </div>
          <div class="legend-item">
            <div class="legend-color" style="background: red;"></div>
            <span>Long Route</span>
          </div>
          <div class="legend-item">
            <div class="legend-point" style="background: #ff6b6b;"></div>
            <span>Decision Point</span>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script src="https://strava-embeds.com/embed.js"></script>
  <script>
    document.addEventListener('DOMContentLoaded', function() {
      // Hide fallback info if maps initialize properly
      document.querySelectorAll('.map-fallback-info').forEach(info => {
        // Make it transparent at first so we can check if maps load properly
        info.style.opacity = '0.3';
        
        // After a delay, hide it completely if maps are working
        setTimeout(() => {
          if (window.L && window.L.version) {
            info.style.display = 'none';
          } else {
            info.style.opacity = '1';
          }
        }, 1500);
      });
      
      // Initialize maps
      const maps = {
        'day0': initMap('map-day0', ['gpx/D0_Warm-up.gpx']),
        'day1': initMap('map-day1', ['gpx/D1_East Short.gpx', 'gpx/D1_East_Long.gpx']),
        'day2': initMap('map-day2', ['gpx/D2_North_Short.gpx', 'gpx/D2_North_Long.gpx']),
        'day3': initMap('map-day3', ['gpx/D3_West_Short.gpx', 'gpx/D3_West_Long.gpx'])
      };
      
      // Initialize tabs
      const tabs = document.querySelectorAll('.map-tab');
      tabs.forEach(tab => {
        tab.addEventListener('click', function() {
          // Get the parent container
          const parent = this.parentElement;
          // Remove active class from all siblings
          parent.querySelectorAll('.map-tab').forEach(t => t.classList.remove('active'));
          // Add active class to this tab
          this.classList.add('active');
          
          // Get the map ID and tab type
          const [day, type] = this.dataset.tab.split('-');
          const mapContainer = document.getElementById(`map-${day}`);
          
          // Handle tab switching
          switch(type) {
            case 'comparison':
              showComparison(maps[day], day);
              break;
            case 'short':
              showSingleRoute(maps[day], day, 'short');
              break;
            case 'long':
              showSingleRoute(maps[day], day, 'long');
              break;
          }
        });
      });
      
      // Toggle day sections
      const toggles = document.querySelectorAll('.day-toggle');
      toggles.forEach(toggle => {
        toggle.addEventListener('click', function() {
          // Toggle the collapsed class on the title
          this.classList.toggle('collapsed');
          
          // Find the content section and toggle its collapsed class
          const content = this.nextElementSibling;
          content.classList.toggle('collapsed');
          
          // Re-initialize maps and Strava embeds when expanding
          if (!content.classList.contains('collapsed')) {
            if (window.StravaEmbed) {
              window.StravaEmbed.init();
            }
            
            // Get the day number from the toggle
            const dayId = this.textContent.trim().toLowerCase().replace(/\s+/g, '').includes('day0') 
              ? 'day0' 
              : this.textContent.trim().toLowerCase().replace(/\s+/g, '').includes('day1')
                ? 'day1'
                : this.textContent.trim().toLowerCase().replace(/\s+/g, '').includes('day2')
                  ? 'day2'
                  : 'day3';
            
            // Trigger a resize on the map to fix any display issues
            if (maps[dayId]) {
              maps[dayId].invalidateSize();
              
              // Find the active tab for this day
              const activeTab = content.querySelector('.map-tab.active');
              if (activeTab) {
                const [day, type] = activeTab.dataset.tab.split('-');
                if (type === 'comparison') {
                  showComparison(maps[day], day);
                } else if (type === 'short') {
                  showSingleRoute(maps[day], day, 'short');
                } else if (type === 'long') {
                  showSingleRoute(maps[day], day, 'long');
                }
              }
            }
          }
        });
      });
      
      // Initialize all maps with comparison view
      showComparison(maps.day0, 'day0');
      showComparison(maps.day1, 'day1');
      showComparison(maps.day2, 'day2');
      showComparison(maps.day3, 'day3');
      
      // Optional: Start with all sections expanded except the first one
      // Uncomment the following lines if you want this behavior
      /*
      const firstToggle = toggles[0];
      if (firstToggle) {
        firstToggle.classList.remove('collapsed');
        firstToggle.nextElementSibling.classList.remove('collapsed');
        
        for (let i = 1; i < toggles.length; i++) {
          toggles[i].classList.add('collapsed');
          toggles[i].nextElementSibling.classList.add('collapsed');
        }
      }
      */
    });
    
    // Map initialization function
    function initMap(id, gpxFiles) {
      const map = L.map(id);
      
      // Add tile layer - using a CORS-friendly provider for file:// protocol 
      L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
        subdomains: 'abcd',
        maxZoom: 19,
        crossOrigin: true
      }).addTo(map);
      
      // Add error messaging for map loading
      map.on('tileerror', function(e) {
        if (!map.errorDisplayed) {
          const mapContainer = document.getElementById(id);
          const errorMsg = document.createElement('div');
          errorMsg.className = 'map-error';
          errorMsg.innerHTML = '<strong>Map loading error</strong><br>If viewing locally, please run a local server or view GPX files directly.';
          errorMsg.style.position = 'absolute';
          errorMsg.style.zIndex = 1000;
          errorMsg.style.top = '50%';
          errorMsg.style.left = '50%';
          errorMsg.style.transform = 'translate(-50%, -50%)';
          errorMsg.style.background = 'rgba(255,255,255,0.9)';
          errorMsg.style.padding = '10px';
          errorMsg.style.borderRadius = '5px';
          errorMsg.style.boxShadow = '0 0 10px rgba(0,0,0,0.2)';
          mapContainer.appendChild(errorMsg);
          map.errorDisplayed = true;
        }
      });
      
      // Store track layers for later manipulation
      map.trackLayers = [];
      
      // Add GPX tracks
      if (gpxFiles.length === 1) {
        // For Day 0 (single route)
        const gpxLayer = new L.GPX(gpxFiles[0], {
          async: true,
          marker_options: {
            startIconUrl: '',
            endIconUrl: '',
            shadowUrl: ''
          },
          polyline_options: {
            color: 'blue',
            weight: 5,
            opacity: 0.7
          }
        })
        .on('loaded', function(e) {
          map.fitBounds(e.target.getBounds());
        })
        .addTo(map);
        
        map.trackLayers.push({
          layer: gpxLayer,
          type: 'single'
        });
      } else if (gpxFiles.length === 2) {
        // For Day 1-3 (short and long routes)
        const shortRoute = new L.GPX(gpxFiles[0], {
          async: true,
          marker_options: {
            startIconUrl: '',
            endIconUrl: '',
            shadowUrl: ''
          },
          polyline_options: {
            color: 'green',
            weight: 5,
            opacity: 0.7
          }
        });
        
        const longRoute = new L.GPX(gpxFiles[1], {
          async: true,
          marker_options: {
            startIconUrl: '',
            endIconUrl: '',
            shadowUrl: ''
          },
          polyline_options: {
            color: 'red',
            weight: 5,
            opacity: 0.7
          }
        });
        
        // Add to map when both are loaded
        let loadedCount = 0;
        const checkBothLoaded = function() {
          loadedCount++;
          if (loadedCount === 2) {
            // Now both routes are loaded
            // Create bounds that include both routes
            const bounds = shortRoute.getBounds().extend(longRoute.getBounds());
            map.fitBounds(bounds);
            
            // Try to find decision points (where routes diverge and converge)
            findDecisionPoints(shortRoute, longRoute, map);
          }
        };
        
        shortRoute.on('loaded', checkBothLoaded).addTo(map);
        longRoute.on('loaded', checkBothLoaded).addTo(map);
        
        map.trackLayers.push(
          { layer: shortRoute, type: 'short' },
          { layer: longRoute, type: 'long' }
        );
      }
      
      return map;
    }
    
    // Function to find and mark decision points
    function findDecisionPoints(shortRoute, longRoute, map) {
      try {
        // Check if we have valid routes with layers
        if (!shortRoute || !longRoute || !shortRoute.getLayers || !longRoute.getLayers) {
          console.error("Invalid routes provided to findDecisionPoints");
          return;
        }
        
        const shortLayers = shortRoute.getLayers();
        const longLayers = longRoute.getLayers();
        
        if (!shortLayers || !shortLayers.length || !longLayers || !longLayers.length) {
          console.error("Routes have no layers");
          return;
        }
        
        // Get points from the first layer that has them
        let shortPoints = null;
        let longPoints = null;
        
        // Try to find a valid layer with points
        for (let i = 0; i < shortLayers.length; i++) {
          if (shortLayers[i].getLatLngs && shortLayers[i].getLatLngs().length) {
            shortPoints = shortLayers[i].getLatLngs();
            break;
          }
        }
        
        for (let i = 0; i < longLayers.length; i++) {
          if (longLayers[i].getLatLngs && longLayers[i].getLatLngs().length) {
            longPoints = longLayers[i].getLatLngs();
            break;
          }
        }
        
        if (!shortPoints || !shortPoints.length || !longPoints || !longPoints.length) {
          console.error("Could not find valid points in routes");
          return;
        }
        
        // Flatten arrays if they're multi-dimensional
        if (Array.isArray(shortPoints[0]) && !shortPoints[0].lat) {
          shortPoints = shortPoints[0];
        }
        
        if (Array.isArray(longPoints[0]) && !longPoints[0].lat) {
          longPoints = longPoints[0];
        }
        
        // Ensure we have lat/lng objects
        if (!shortPoints[0].lat || !longPoints[0].lat) {
          console.error("Points don't have lat/lng properties");
          return;
        }
        
        // Find the actual divergence point by comparing the routes
        let shortIndex = 0, longIndex = 0;
        const threshold = 0.0005; // ~50 meters divergence threshold
        let foundDivergence = false;
        
        // Calculate approximate distances for both routes to estimate where 1km would be
        const estimateDistancePerPoint = (points) => {
          if (points.length < 2) return 0;
          
          // Sample a few segments to get an average
          let totalDist = 0;
          const samples = Math.min(10, points.length - 1);
          const step = Math.floor(points.length / samples);
          
          for (let i = 0; i < samples; i++) {
            const idx1 = i * step;
            const idx2 = Math.min((i + 1) * step, points.length - 1);
            totalDist += getDistance(points[idx1], points[idx2]);
          }
          
          return totalDist / samples; // average distance per step
        };
        
        // Roughly estimate distance per point
        const shortDistPerPoint = estimateDistancePerPoint(shortPoints);
        const longDistPerPoint = estimateDistancePerPoint(longPoints);
        
        // Estimate number of points to cover 1km (0.01 in lat/long is roughly 1.1km)
        // This is a very rough approximation that depends on latitude, but good enough for our purposes
        const shortSkipPoints = Math.max(50, Math.round(0.01 / shortDistPerPoint));
        const longSkipPoints = Math.max(50, Math.round(0.01 / longDistPerPoint));
        
        // We need to scan through the routes and find where they start to diverge
        // Using a sliding window approach to find matching segments
        const maxCheck = Math.min(shortPoints.length, longPoints.length) - 1;
        
        // First, find roughly similar starting points by comparing first few points
        let shortStartIdx = shortSkipPoints; // Skip first ~1km
        let longStartIdx = longSkipPoints; // Skip first ~1km
        let minDist = Number.MAX_VALUE;
        
        // Adjust starting indices to find matching points after the first kilometer
        const sampleSize = 20;
        for (let i = 0; i < sampleSize; i++) {
          const shortIdx = shortStartIdx + i;
          if (shortIdx >= shortPoints.length) continue;
          
          for (let j = 0; j < sampleSize; j++) {
            const longIdx = longStartIdx + j;
            if (longIdx >= longPoints.length) continue;
            
            const dist = getDistance(shortPoints[shortIdx], longPoints[longIdx]);
            if (dist < minDist) {
              minDist = dist;
              shortStartIdx = shortIdx;
              longStartIdx = longIdx;
            }
          }
        }
        
        // Start checking from the matched start points
        for (let i = 0; i < maxCheck - Math.max(shortStartIdx, longStartIdx); i++) {
          const shortIdx = Math.min(shortStartIdx + i, shortPoints.length - 1);
          const longIdx = Math.min(longStartIdx + i, longPoints.length - 1);
          
          const distance = getDistance(shortPoints[shortIdx], longPoints[longIdx]);
          
          if (distance > threshold) {
            // We found where the routes diverge (after the first km)
            shortIndex = shortIdx;
            longIndex = longIdx;
            foundDivergence = true;
            break;
          }
        }
        
        // If we couldn't find a clear divergence, fall back to checking distance every N points
        if (!foundDivergence) {
          // Sample every N points to find the divergence, starting after the first kilometer
          const sampleRate = Math.max(1, Math.floor(Math.min(shortPoints.length, longPoints.length) / 20));
          const startSample = Math.max(shortSkipPoints, longSkipPoints);
          
          for (let i = startSample; i < Math.min(shortPoints.length, longPoints.length); i += sampleRate) {
            // Make sure we don't go out of bounds
            if (i >= shortPoints.length || i >= longPoints.length) break;
            
            const distance = getDistance(shortPoints[i], longPoints[i]);
            if (distance > threshold) {
              shortIndex = i;
              longIndex = i;
              foundDivergence = true;
              break;
            }
          }
        }
        
        // If still no divergence found, fall back to 1/3 of the route
        if (!foundDivergence) {
          shortIndex = Math.floor(shortPoints.length / 3);
          longIndex = Math.floor(longPoints.length / 3);
        }
        
        // Ensure we're not choosing a point too early in the route
        shortIndex = Math.max(shortIndex, shortSkipPoints);
        longIndex = Math.max(longIndex, longSkipPoints);
        
        const shortPoint = shortPoints[shortIndex];
        const longPoint = longPoints[longIndex];
        
        // Helper function to calculate distance between two points
        function getDistance(point1, point2) {
          return Math.sqrt(
            Math.pow(point1.lat - point2.lat, 2) + 
            Math.pow(point1.lng - point2.lng, 2)
          );
        }
        
        // Calculate a midpoint between them as the decision point
        const decisionPoint = L.latLng(
          (shortPoint.lat + longPoint.lat) / 2,
          (shortPoint.lng + longPoint.lng) / 2
        );
        
        // Add a marker at the decision point
        const decisionMarker = L.marker(decisionPoint, {
          icon: L.divIcon({
            className: 'decision-point',
            iconSize: [20, 20]
          })
        });
        
        decisionMarker.bindPopup('<strong>Decision Point</strong><br>Choose between short or long route here.');
        map.decisionMarker = decisionMarker;
        decisionMarker.addTo(map);
      } catch (e) {
        console.error("Error finding decision points:", e);
        // Add an error message to the map
        const errorMsg = document.createElement('div');
        errorMsg.className = 'gpx-error';
        errorMsg.innerHTML = '<strong>GPX file loading error</strong><br>Could not analyze route data.';
        errorMsg.style.position = 'absolute';
        errorMsg.style.zIndex = 1000;
        errorMsg.style.bottom = '10px';
        errorMsg.style.left = '10px';
        errorMsg.style.background = 'rgba(255,255,255,0.9)';
        errorMsg.style.padding = '8px';
        errorMsg.style.borderRadius = '4px';
        errorMsg.style.fontSize = '0.8rem';
        map.getContainer().appendChild(errorMsg);
      }
    }
    
    // Function to show comparison view
    function showComparison(map, day) {
      if (!map) return;
      
      // Show all layers
      map.trackLayers.forEach(item => {
        if (!map.hasLayer(item.layer)) {
          map.addLayer(item.layer);
        }
      });
      
      // Show decision marker if it exists
      if (map.decisionMarker && !map.hasLayer(map.decisionMarker)) {
        map.addLayer(map.decisionMarker);
      }
    }
    
    // Function to show just one route
    function showSingleRoute(map, day, routeType) {
      if (!map) return;
      
      // Hide all layers first
      map.trackLayers.forEach(item => {
        if (map.hasLayer(item.layer)) {
          map.removeLayer(item.layer);
        }
      });
      
      // Hide decision marker if it exists
      if (map.decisionMarker && map.hasLayer(map.decisionMarker)) {
        map.removeLayer(map.decisionMarker);
      }
      
      // Show only the requested route
      const layerToShow = map.trackLayers.find(item => 
        routeType === 'short' ? item.type === 'short' : 
        routeType === 'long' ? item.type === 'long' : 
        item.type === 'single'
      );
      
      if (layerToShow) {
        map.addLayer(layerToShow.layer);
      }
    }
    
    // Weather widget functionality
  
    // Load all weather widgets when the page loads
    document.addEventListener('DOMContentLoaded', function() {
      const weatherWidgets = document.querySelectorAll('.weather-widget');
      weatherWidgets.forEach(widget => {
        const dayId = widget.id.replace('weather-', '');
        loadWeatherForecast(dayId);
      });
    });
    
    // Function to refresh a specific weather widget
    function refreshWeather(dayId) {
      const widget = document.getElementById(`weather-${dayId}`);
      if (!widget) return;
      
      // Show loading state
      const content = widget.querySelector('.weather-content');
      content.innerHTML = `
        <div class="weather-loading">
          <i class="fas fa-spinner"></i> Refreshing weather forecast...
        </div>
      `;
      
      // Load fresh weather data
      loadWeatherForecast(dayId);
    }
    
    // Function to load weather forecast for a specific day
    function loadWeatherForecast(dayId) {
      const widget = document.getElementById(`weather-${dayId}`);
      if (!widget) return;
      
      const lat = widget.dataset.lat;
      const lon = widget.dataset.lon;
      const date = widget.dataset.date;
      
      fetchWeatherData(lat, lon, date)
        .then(data => {
          displayWeatherData(dayId, data);
        })
        .catch(error => {
          displayWeatherError(dayId, error);
        });
    }
    
    // Function to fetch weather data from Open-Meteo API
    async function fetchWeatherData(lat, lon, date) {
      try {
        // Parse the target date
        const targetDate = new Date(date);
        
        // Get current date to determine if we need historical or forecast data
        const currentDate = new Date();
        
        // We need to use historical API if the date is more than a day in the past
        const isHistorical = targetDate < new Date(currentDate.getTime() - 24 * 60 * 60 * 1000);
        
        // Calculate start and end dates for 3-day window around target date
        const startDate = new Date(targetDate);
        startDate.setDate(startDate.getDate() - 1);
        const endDate = new Date(targetDate);
        endDate.setDate(endDate.getDate() + 1);
        
        // Format dates as YYYY-MM-DD for API
        const formatAPIDate = (date) => {
          return date.toISOString().split('T')[0];
        };
        
        // Prepare API URL based on whether we need historical or forecast data
        let apiUrl;
        
        if (isHistorical) {
          // For historical data (past)
          apiUrl = `https://archive-api.open-meteo.com/v1/archive?latitude=${lat}&longitude=${lon}` +
            `&start_date=${formatAPIDate(startDate)}&end_date=${formatAPIDate(endDate)}` +
            `&daily=weathercode,temperature_2m_max,temperature_2m_min,precipitation_sum,windspeed_10m_max` +
            `&timezone=auto`;
        } else {
          // For forecast data (future or current)
          apiUrl = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}` +
            `&daily=weathercode,temperature_2m_max,temperature_2m_min,precipitation_probability_max,windspeed_10m_max` +
            `&current_weather=true&timezone=auto`;
        }
        
        // Make the API request
        const response = await fetch(apiUrl);
        
        if (!response.ok) {
          throw new Error(`Weather API error: ${response.status}`);
        }
        
        const data = await response.json();
        
        // Process the data into our desired format
        return processWeatherData(data, targetDate, isHistorical);
        
      } catch (error) {
        console.error('Error fetching weather data:', error);
        throw new Error('Unable to fetch weather forecast. Please try again later.');
      }
    }
    
    // Process the API response into our app's weather format
    function processWeatherData(data, targetDate, isHistorical) {
      // Create an array to hold our processed forecast
      const forecast = [];
      
      // Get the daily data arrays from the API response
      const { daily } = data;
      
      if (!daily || !daily.time || daily.time.length === 0) {
        throw new Error('Invalid weather data format');
      }
      
      // Get indices for the 3 days we want to display
      const startIdx = 0; // First day in the response
      const endIdx = Math.min(daily.time.length - 1, 2); // Up to 3 days
      
      // Process each day's weather data
      for (let i = startIdx; i <= endIdx; i++) {
        const date = new Date(daily.time[i]);
        const weatherCode = daily.weathercode[i];
        const maxTemp = Math.round(daily.temperature_2m_max[i]);
        const minTemp = Math.round(daily.temperature_2m_min[i]);
        const avgTemp = Math.round((maxTemp + minTemp) / 2);
        const windSpeed = Math.round(daily.windspeed_10m_max[i]);
        
        // Precipitation probability is only available in forecast data
        // For historical, we can approximate from precipitation_sum
        let chanceOfRain = 0;
        if (isHistorical) {
          // Rough approximation: if there was precipitation, say 70% chance
          chanceOfRain = daily.precipitation_sum[i] > 0 ? 70 : 10;
        } else {
          // For forecast data, we have the probability directly
          chanceOfRain = daily.precipitation_probability_max ? 
            daily.precipitation_probability_max[i] : 0;
        }
        
        // Map WMO weather codes to our icon and description
        // https://www.nodc.noaa.gov/archive/arc0021/0002199/1.1/data/0-data/HTML/WMO-CODE/WMO4677.HTM
        const weatherInfo = getWeatherInfo(weatherCode);
        
        forecast.push({
          date: date,
          temp: avgTemp,
          tempMax: maxTemp,
          tempMin: minTemp,
          icon: weatherInfo.icon,
          description: weatherInfo.description,
          windSpeed: windSpeed,
          chanceOfRain: chanceOfRain,
          weatherCode: weatherCode
        });
      }
      
      // Generate weather alert if conditions warrant it
      const alert = generateWeatherAlert(forecast);
      
      return {
        forecast: forecast,
        alert: alert
      };
    }
    
    // Map WMO weather codes to icons and descriptions
    function getWeatherInfo(code) {
      // Weather codes from Open-Meteo API: https://open-meteo.com/en/docs
      // WMO Weather interpretation codes (WW)
      switch (true) {
        case code === 0: // Clear sky
          return { icon: 'sun', description: 'Clear sky' };
        case code === 1: // Mainly clear
          return { icon: 'sun', description: 'Mainly clear' };
        case code === 2: // Partly cloudy
          return { icon: 'cloud-sun', description: 'Partly cloudy' };
        case code === 3: // Overcast
          return { icon: 'cloud', description: 'Overcast' };
        case code === 45 || code === 48: // Fog
          return { icon: 'smog', description: 'Fog' };
        case code >= 51 && code <= 55: // Drizzle
          return { icon: 'cloud-rain', description: 'Light drizzle' };
        case code >= 56 && code <= 57: // Freezing Drizzle
          return { icon: 'snowflake', description: 'Freezing drizzle' };
        case code >= 61 && code <= 65: // Rain
          return { icon: 'cloud-showers-heavy', description: 'Rain' };
        case code >= 66 && code <= 67: // Freezing Rain
          return { icon: 'cloud-meatball', description: 'Freezing rain' };
        case code >= 71 && code <= 77: // Snow
          return { icon: 'snowflake', description: 'Snow' };
        case code >= 80 && code <= 82: // Rain showers
          return { icon: 'cloud-sun-rain', description: 'Rain showers' };
        case code >= 85 && code <= 86: // Snow showers
          return { icon: 'snowflake', description: 'Snow showers' };
        case code === 95: // Thunderstorm
          return { icon: 'bolt', description: 'Thunderstorm' };
        case code >= 96 && code <= 99: // Thunderstorm with hail
          return { icon: 'cloud-bolt', description: 'Thunderstorm with hail' };
        default:
          return { icon: 'cloud', description: 'Unknown conditions' };
      }
    }
    
    // Generate meaningful weather alerts based on actual conditions
    function generateWeatherAlert(forecast) {
      // Check the weather conditions to generate relevant alerts
      
      // Check for high winds (above 30 km/h)
      const highWinds = forecast.some(day => day.windSpeed > 30);
      
      // Check for heavy rain (high precipitation probability)
      const heavyRain = forecast.some(day => day.chanceOfRain > 70);
      
      // Check for extreme temperatures
      const extremeHeat = forecast.some(day => day.tempMax > 30);
      const extremeCold = forecast.some(day => day.tempMin < 0);
      
      // Check for thunderstorms
      const thunderstorms = forecast.some(day => 
        day.weatherCode === 95 || 
        day.weatherCode === 96 || 
        day.weatherCode === 99
      );
      
      // Check for snow
      const snow = forecast.some(day => 
        (day.weatherCode >= 71 && day.weatherCode <= 77) || 
        (day.weatherCode >= 85 && day.weatherCode <= 86)
      );
      
      // Generate appropriate alert or return null if conditions are good
      if (thunderstorms) {
        return {
          type: 'severe',
          message: 'Thunderstorms expected. Take shelter if lightning is present.'
        };
      } else if (snow) {
        return {
          type: 'severe',
          message: 'Snow expected. Be prepared for cold, slippery conditions.'
        };
      } else if (extremeHeat) {
        return {
          type: 'warning',
          message: 'High temperatures expected. Stay hydrated and take breaks in shade.'
        };
      } else if (extremeCold) {
        return {
          type: 'warning',
          message: 'Freezing temperatures expected. Dress in warm layers.'
        };
      } else if (highWinds) {
        return {
          type: 'warning',
          message: 'Strong winds expected. Be cautious on exposed routes.'
        };
      } else if (heavyRain) {
        return {
          type: 'warning',
          message: 'Heavy rainfall possible. Be prepared for wet conditions.'
        };
      }
      
      // No significant weather concerns
      return null;
    }
    
    // Function to display weather data in the widget
    function displayWeatherData(dayId, data) {
      const widget = document.getElementById(`weather-${dayId}`);
      if (!widget) return;
      
      const content = widget.querySelector('.weather-content');
      const isHistorical = data.isHistorical;
      
      // Format date for display
      const formatDate = (date) => {
        const options = { weekday: 'short', month: 'short', day: 'numeric' };
        return date.toLocaleDateString('en-US', options);
      };
      
      // Build the weather cards HTML
      let html = '';
      
      // If showing historical data, add a header
      if (isHistorical) {
        html += `
          <div style="width: 100%; text-align: center; margin-bottom: 10px; font-weight: bold; color: #2980b9;">
            Recent Years' Daytime Temperatures
          </div>
        `;
      }
      
      data.forecast.forEach(day => {
        // For historical data, simplify the display to focus on the daytime temperature
        if (isHistorical) {
          html += `
            <div class="weather-day" style="${isHistorical ? 'background-color: #f8f9fa;' : ''}">
              <div class="weather-date">${formatDate(day.date)}</div>
              <div class="weather-icon">
                <i class="fas fa-${day.icon}"></i>
              </div>
              <div class="weather-temp" style="font-size: ${isHistorical ? '1.6rem' : '1.4rem'}; color: #e74c3c;">
                ${day.tempMax}°C
              </div>
              <div style="font-size: 0.8rem; margin-bottom: 4px;">
                Typical Daytime High
              </div>
              <div class="weather-desc">${day.description}</div>
              <div class="weather-details">
                <div>
                  <i class="fas fa-wind"></i> ${day.windSpeed} km/h
                </div>
                <div>
                  <i class="fas fa-tint"></i> ${day.chanceOfRain}%
                </div>
              </div>
            </div>
          `;
        } else {
          // Regular forecast display
          html += `
            <div class="weather-day">
              <div class="weather-date">${formatDate(day.date)}</div>
              <div class="weather-icon">
                <i class="fas fa-${day.icon}"></i>
              </div>
              <div class="weather-temp">${day.temp}°C</div>
              <div style="font-size: 0.75rem; color: #666; margin-bottom: 4px;">
                <span style="color: #e74c3c;">${day.tempMax}°</span> / <span style="color: #3498db;">${day.tempMin}°</span>
              </div>
              <div class="weather-desc">${day.description}</div>
              <div class="weather-details">
                <div>
                  <i class="fas fa-wind"></i> ${day.windSpeed} km/h
                </div>
                <div>
                  <i class="fas fa-tint"></i> ${day.chanceOfRain}%
                </div>
              </div>
            </div>
          `;
        }
      });
      
      // Add any weather alerts
      if (data.alert) {
        html += `
          <div class="weather-alert ${data.alert.type}">
            <i class="fas fa-exclamation-triangle"></i> 
            <strong>${data.alert.type === 'severe' ? 'Alert' : 'Warning'}</strong>: ${data.alert.message}
          </div>
        `;
      }
      
      // Add the attribution note to the HTML
      html += `
        <div style="font-size: 0.75rem; color: #999; text-align: center; margin-top: 12px; width: 100%;">
          Weather data provided by <a href="https://open-meteo.com/" target="_blank" style="color: #3498db;">Open-Meteo.com</a>
        </div>
      `;
      
      // Update the widget content with the complete HTML
      content.innerHTML = html;
    }
    
    // Function to display an error in the weather widget
    function displayWeatherError(dayId, error) {
      const widget = document.getElementById(`weather-${dayId}`);
      if (!widget) return;
      
      const content = widget.querySelector('.weather-content');
      content.innerHTML = `
        <div class="weather-error">
          <i class="fas fa-exclamation-circle"></i>
          ${error.message || 'Unable to load weather data'}
        </div>
        <button onclick="refreshWeather('${dayId}')" class="gpx-btn" style="margin-top:15px;">
          <i class="fas fa-sync-alt"></i> Try Again
        </button>
      `;
    }
    
    // Store weather data for each widget
    const weatherDataCache = {};
    
    // Toggle between historical data and current forecast
    function toggleForecastMode(dayId, mode) {
      const widget = document.getElementById(`weather-${dayId}`);
      if (!widget) return;
      
      // Save the current mode to the widget
      widget.dataset.mode = mode;
      
      // Update the active state of the toggle buttons
      const historicalLink = widget.querySelector('.weather-toggle-container a:first-child');
      const forecastLink = widget.querySelector('.weather-toggle-container a:last-child');
      
      if (mode === 'historical') {
        historicalLink.style.fontWeight = 'bold';
        forecastLink.style.fontWeight = 'normal';
        historicalLink.style.textDecoration = 'underline';
        forecastLink.style.textDecoration = 'none';
      } else {
        historicalLink.style.fontWeight = 'normal';
        forecastLink.style.fontWeight = 'bold';
        historicalLink.style.textDecoration = 'none';
        forecastLink.style.textDecoration = 'underline';
      }
      
      // Show loading state
      const content = widget.querySelector('.weather-content');
      content.innerHTML = `
        <div class="weather-loading">
          <i class="fas fa-spinner"></i> Loading ${mode === 'historical' ? 'historical' : 'forecast'} data...
        </div>
      `;
      
      // Load the data for the selected mode
      const lat = widget.dataset.lat;
      const lon = widget.dataset.lon;
      const date = widget.dataset.date;
      
      // If we're requesting historical data, use the historical API
      if (mode === 'historical') {
        fetchHistoricalWeatherData(lat, lon, date)
          .then(data => {
            // Cache the data
            weatherDataCache[`${dayId}-historical`] = data;
            displayWeatherData(dayId, data);
          })
          .catch(error => {
            displayWeatherError(dayId, error);
          });
      } else {
        // Otherwise load regular forecast/current data
        fetchWeatherData(lat, lon, date)
          .then(data => {
            // Cache the data
            weatherDataCache[`${dayId}-forecast`] = data;
            displayWeatherData(dayId, data);
          })
          .catch(error => {
            displayWeatherError(dayId, error);
          });
      }
    }
    
    // Fetch historical climate data for a location
    async function fetchHistoricalWeatherData(lat, lon, date) {
      try {
        // Parse the target date to get month and day
        const targetDate = new Date(date);
        const month = targetDate.getMonth() + 1; // 1-12
        const day = targetDate.getDate(); // 1-31
        
        // For a cycling event during the day, we'll focus on daytime high temperatures
        // from the most recent years to provide the most relevant data
        
        // Get the same calendar day for the past 3 years (2021, 2022, 2023)
        const threeYearsData = [];
        
        // We'll get data for a 3-day window centered on the target date
        // for each of the last 3 years
        for (let year = 2021; year <= 2023; year++) {
          // Calculate the 3-day window
          const dayMinus1 = new Date(year, targetDate.getMonth(), targetDate.getDate() - 1);
          const dayPlus1 = new Date(year, targetDate.getMonth(), targetDate.getDate() + 1);
          
          // Format dates for API
          const formatDateForAPI = (d) => {
            return `${d.getFullYear()}-${(d.getMonth() + 1).toString().padStart(2, '0')}-${d.getDate().toString().padStart(2, '0')}`;
          };
          
          const startDate = formatDateForAPI(dayMinus1);
          const endDate = formatDateForAPI(dayPlus1);
          
          // Request for this year's data
          const apiUrl = `https://archive-api.open-meteo.com/v1/era5?latitude=${lat}&longitude=${lon}` +
            `&start_date=${startDate}&end_date=${endDate}` +
            `&daily=temperature_2m_max,precipitation_sum,windspeed_10m_max` +
            `&timezone=auto`;
          
          console.log(`Historical API URL for ${year}:`, apiUrl);
          
          threeYearsData.push(fetch(apiUrl).then(response => {
            if (!response.ok) {
              throw new Error(`Weather API error: ${response.status}`);
            }
            return response.json();
          }));
        }
        
        // Wait for all three requests to complete
        const results = await Promise.all(threeYearsData);
        console.log('Historical data for 3 years:', results);
        
        // Process the data to create a forecast based on recent years' highs
        return processRecentYearsData(results, targetDate);
        
      } catch (error) {
        console.error('Error fetching historical weather data:', error);
        throw new Error('Unable to fetch recent years weather data. Please try again later.');
      }
    }
    
    // Process data from recent years to create a useful cycling forecast
    function processRecentYearsData(dataArray, targetDate) {
      try {
        // Collect all the max temperatures from the 3 years
        const allMaxTemps = [];
        const allPrecipitation = [];
        const allWindSpeeds = [];
        
        // Collect data from all three years
        dataArray.forEach((yearData, yearIndex) => {
          if (!yearData.daily || !yearData.daily.temperature_2m_max) {
            console.error(`Invalid data for year ${2021 + yearIndex}:`, yearData);
            return; // Skip this year
          }
          
          // Add this year's data to our collections
          yearData.daily.temperature_2m_max.forEach(temp => allMaxTemps.push(temp));
          
          if (yearData.daily.precipitation_sum) {
            yearData.daily.precipitation_sum.forEach(precip => allPrecipitation.push(precip));
          }
          
          if (yearData.daily.windspeed_10m_max) {
            yearData.daily.windspeed_10m_max.forEach(wind => allWindSpeeds.push(wind));
          }
        });
        
        console.log('All collected max temperatures:', allMaxTemps);
        
        // Calculate the average high temperature (what cyclists will experience)
        const avgDaytimeTemp = allMaxTemps.length > 0 
          ? allMaxTemps.reduce((sum, temp) => sum + temp, 0) / allMaxTemps.length 
          : 20; // Fallback value if no data
        
        // Average precipitation and wind
        const avgPrecipitation = allPrecipitation.length > 0
          ? allPrecipitation.reduce((sum, val) => sum + val, 0) / allPrecipitation.length
          : 0;
          
        const avgWindSpeed = allWindSpeeds.length > 0
          ? allWindSpeeds.reduce((sum, val) => sum + val, 0) / allWindSpeeds.length
          : 10;
        
        console.log(`Recent years data: Avg high temp=${avgDaytimeTemp}°C, Precipitation=${avgPrecipitation}mm, Wind=${avgWindSpeed}km/h`);
        
        // For min temps, we'll use a reasonable offset from max (not that relevant for daytime cycling)
        const estimatedMinTemp = Math.max(5, avgDaytimeTemp - 8);
        
        // Generate 3-day forecast around the target date (all showing the same average data)
        const forecast = [];
        for (let i = -1; i <= 1; i++) {
          const forecastDate = new Date(targetDate);
          forecastDate.setDate(forecastDate.getDate() + i);
          
          // Determine weather icon based on precipitation
          let icon, description;
          if (avgPrecipitation > 5) {
            icon = 'cloud-rain';
            description = 'Occasional rain (based on 2021-2023)';
          } else if (avgPrecipitation > 1) {
            icon = 'cloud-sun-rain';
            description = 'Light showers possible (based on 2021-2023)';
          } else {
            icon = 'sun';
            description = 'Typically sunny (based on 2021-2023)';
          }
          
          // Calculate precipitation probability based on historical data
          const chanceOfRain = avgPrecipitation > 0 ? Math.min(90, Math.round(avgPrecipitation * 15)) : 10;
          
          forecast.push({
            date: forecastDate,
            temp: Math.round(avgDaytimeTemp), // Use daytime temperature as main temp
            tempMax: Math.round(avgDaytimeTemp),
            tempMin: Math.round(estimatedMinTemp),
            icon: icon,
            description: description,
            windSpeed: Math.round(avgWindSpeed),
            chanceOfRain: chanceOfRain,
            isHistorical: true
          });
        }
        
        return {
          forecast: forecast,
          isHistorical: true,
          alert: {
            type: 'info',
            message: 'Showing typical daytime temperatures from 2021-2023. Actual conditions will vary.'
          }
        };
      } catch (error) {
        console.error('Error processing historical data:', error);
        throw new Error('Could not process historical weather data');
      }
    }
  </script>
</body>
</html>
