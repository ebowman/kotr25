<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>King of the Road 2025 Strava Routes</title>
  <script src="https://strava-embeds.com/embed.js"></script>
  <link rel="stylesheet" href="https://unpkg.com/mapbox-gl@2.15.0/dist/mapbox-gl.css" />
  <script src="https://unpkg.com/mapbox-gl@2.15.0/dist/mapbox-gl.js"></script>
  <script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />
  <style>
    body {
      font-family: 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      line-height: 1.6;
      padding: 0;
      background: #f9f9f9;
      margin: 0;
      color: #333;
    }
    .container {
      max-width: 1000px;
      margin: 0 auto;
      padding: 0 2rem 2rem;
    }
    .banner {
      width: 100%;
      height: auto;
      max-height: 300px;
      object-fit: cover;
      margin-bottom: 1rem;
    }
    h1 {
      text-align: center;
      margin: 1.5rem 0;
      color: #222;
    }
    h2 {
      margin-top: 1rem;
      margin-bottom: 0.75rem;
      color: #333;
      border-bottom: 2px solid #ddd;
      padding-bottom: 0.5rem;
      cursor: pointer;
      user-select: none;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    h2:after {
      content: "▼";
      font-size: 0.8rem;
      transition: transform 0.3s ease;
    }
    h2.collapsed:after {
      transform: rotate(-90deg);
    }
    h3 {
      margin-top: 1rem;
      color: #555;
    }
    .day-section {
      margin-bottom: 3rem;
      background: white;
      border-radius: 10px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.05);
      padding: 1.5rem;
    }
    .day-content {
      transition: max-height 0.5s ease, opacity 0.3s ease;
      max-height: 2000px;
      opacity: 1;
      overflow: hidden;
    }
    .day-content.collapsed {
      max-height: 0;
      opacity: 0;
      margin-top: 0;
    }
    .route-container {
      display: flex;
      flex-wrap: wrap;
      gap: 2rem;
      margin-top: 1rem;
    }
    .route {
      flex: 1;
      min-width: 300px;
      border: 1px solid #eee;
      padding: 1rem;
      background: #fcfcfc;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.03);
    }
    .date {
      font-size: 0.9rem;
      color: #666;
      margin-top: 0.25rem;
      font-weight: normal;
    }
    .intro {
      text-align: center;
      max-width: 800px;
      margin: 0 auto 2rem;
      padding-bottom: 1rem;
      border-bottom: 1px solid #eee;
    }
    .gpx-map {
      height: 400px;
      margin-top: 1rem;
      border-radius: 8px;
      overflow: hidden;
      border: 1px solid #ddd;
    }
    .gpx-download {
      display: flex;
      flex-direction: column;
      margin-top: 1.5rem;
      padding: 1rem;
      background: #f5f9ff;
      border-radius: 8px;
      border: 1px solid #d0e0f0;
      box-shadow: 0 2px 5px rgba(0,0,0,0.03);
    }
    .gpx-download-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    .gpx-btn {
      display: inline-flex;
      align-items: center;
      padding: 10px 16px;
      background: linear-gradient(to bottom, #3498db, #2980b9);
      color: white;
      text-decoration: none;
      border-radius: 6px;
      font-size: 0.95rem;
      font-weight: 500;
      transition: all 0.2s ease;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      border: none;
    }
    .gpx-btn:hover {
      background: linear-gradient(to bottom, #2980b9, #2471a3);
      box-shadow: 0 3px 6px rgba(0,0,0,0.15);
      transform: translateY(-1px);
    }
    .gpx-btn:active {
      transform: translateY(1px);
      box-shadow: 0 1px 2px rgba(0,0,0,0.1);
    }
    .gpx-btn::before {
      content: "⬇️";
      margin-right: 8px;
      font-size: 1rem;
    }
    .gpx-info {
      margin-top: 0.8rem;
      padding: 0.4rem 0;
      font-size: 0.9rem;
      color: #666;
      border-top: 1px solid #e8f0f8;
    }
    .map-tabs {
      display: flex;
      border-bottom: 1px solid #ddd;
      margin-bottom: 1rem;
    }
    .map-tab {
      padding: 8px 15px;
      cursor: pointer;
      border: 1px solid transparent;
      border-bottom: none;
      margin-right: 5px;
      border-radius: 5px 5px 0 0;
      transition: all 0.2s ease;
    }
    .map-tab.active {
      background: #f0f8ff;
      border-color: #d0e0f0;
      font-weight: bold;
    }
    .map-tab:hover:not(.active) {
      background: #f5f5f5;
    }
    .decision-point {
      width: 20px;
      height: 20px;
      background-color: #ff6b6b;
      border: 2px solid white;
      border-radius: 50%;
    }
    .legend {
      background: white;
      padding: 8px;
      border-radius: 4px;
      border: 1px solid #ddd;
      margin-top: 8px;
      font-size: 0.85rem;
    }
    .legend-item {
      display: flex;
      align-items: center;
      margin-bottom: 4px;
    }
    .legend-color {
      width: 15px;
      height: 3px;
      margin-right: 6px;
    }
    .legend-point {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      margin-right: 6px;
    }
    .map-fallback-info {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: white;
      padding: 15px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      text-align: center;
      max-width: 90%;
      z-index: 400;
    }
    .map-note {
      font-size: 0.8rem;
      color: #666;
      margin-top: 10px;
    }
    .mapboxgl-map {
      position: relative;
      z-index: 1;
    }
    
    .mapboxgl-popup {
      max-width: 200px;
    }
    
    /* Weather Widget Styles */
    .weather-widget {
      background: linear-gradient(to bottom, #f0f8ff, #e6f3ff);
      border-radius: 10px;
      padding: 16px;
      margin-top: 20px;
      box-shadow: 0 4px 6px rgba(0,0,0,0.06);
      border: 1px solid #d0e0f0;
      display: flex;
      flex-direction: column;
      font-size: 0.9rem;
    }
    
    .weather-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
      padding-bottom: 10px;
      border-bottom: 1px solid #e0e9f5;
    }
    
    .weather-title {
      font-weight: 600;
      font-size: 1rem;
      color: #2c3e50;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .weather-title i {
      color: #3498db;
    }
    
    .weather-refresh {
      font-size: 0.8rem;
      color: #7f8c8d;
      cursor: pointer;
      padding: 4px 8px;
      border-radius: 4px;
      transition: all 0.2s;
    }
    
    .weather-refresh:hover {
      background: #e0e9f5;
      color: #2980b9;
    }
    
    .weather-content {
      display: flex;
      flex-wrap: wrap;
      gap: 16px;
    }
    
    .weather-day {
      flex: 1;
      min-width: 150px;
      background: white;
      border-radius: 8px;
      padding: 12px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.03);
      text-align: center;
      transition: transform 0.2s;
    }
    
    .weather-day:hover {
      transform: translateY(-3px);
      box-shadow: 0 4px 8px rgba(0,0,0,0.08);
    }
    
    .weather-date {
      font-weight: 600;
      margin-bottom: 8px;
      color: #34495e;
    }
    
    .weather-icon {
      font-size: 2rem;
      margin: 8px 0;
      color: #f39c12;
    }
    
    .weather-temp {
      font-size: 1.4rem;
      font-weight: 600;
      margin-bottom: 4px;
      color: #2c3e50;
    }
    
    .weather-desc {
      color: #7f8c8d;
      font-size: 0.85rem;
      margin-bottom: 8px;
    }
    
    .weather-details {
      display: flex;
      justify-content: space-around;
      font-size: 0.8rem;
      color: #34495e;
    }
    
    .weather-loading {
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 30px;
      color: #7f8c8d;
    }
    
    .weather-loading i {
      animation: spin 2s linear infinite;
      margin-right: 8px;
      color: #3498db;
    }
    
    .weather-error {
      color: #e74c3c;
      text-align: center;
      padding: 15px;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    .weather-alert {
      background: #fef9e7;
      border-left: 4px solid #f39c12;
      padding: 10px;
      margin-top: 10px;
      border-radius: 4px;
      font-size: 0.85rem;
    }
    
    .weather-alert.severe {
      background: #fae1dd;
      border-left-color: #e74c3c;
    }
  </style>
</head>
<body>
  <header>
    <img src="banner.jpg" alt="King of the Road 2025 Banner" class="banner">
  </header>
  
  <div class="container">
    <h1>King Of The Road 2025 Strava Routes</h1>
    
    <div class="intro">
      <p>Welcome to the King of the Road 2025! Below you'll find all the routes for each day of the event. Use the interactive maps to explore both short and long options, and download GPX files for your GPS device.</p>
      
      <div style="text-align: center; margin: 20px 0;">
        <a href="route-flyover.html" class="gpx-btn" style="display: inline-block;">
          <i class="fas fa-mountain"></i> Experience 3D Route Flyovers
        </a>
      </div>
      
      <details>
        <summary style="cursor: pointer; color: #3498db; margin-top: 10px;">
          <strong>Trouble seeing the maps?</strong>
        </summary>
        <div style="background: #f8f9fa; padding: 15px; margin-top: 10px; border-radius: 5px; font-size: 0.9rem; text-align: left;">
          <p>The interactive maps require a web server to work properly. If you're viewing this file locally (via file:// protocol), you may see gray boxes instead of maps.</p>
          
          <p><strong>Quick solution:</strong> You can still download the GPX files directly and use them with your GPS device or other mapping software.</p>
          
          <p><strong>For interactive maps:</strong> Run a simple web server from this directory. Here are some options:</p>
          
          <ul style="margin-left: 20px;">
            <li>Python: <code>python -m http.server</code> (then open <a href="http://localhost:8000">http://localhost:8000</a>)</li>
            <li>Node.js: <code>npx serve</code> (then open the URL shown)</li>
            <li>Or upload the files to any web hosting service</li>
          </ul>
        </div>
      </details>
    </div>

    <div class="day-section">
      <h2 class="day-toggle">Day 0 - Warm-up Ride <span class="date">May 22, 2025</span></h2>
      <div class="day-content">
        <div class="route">
          <h3>Warm-up Route</h3>
          <div class="strava-embed-placeholder" data-embed-type="route" data-embed-id="3352952321743025716" data-style="standard" data-map-hash="10.13/46.0523/14.5781" data-from-embed="true"></div>
          
          <div class="gpx-map" id="map-day0">
            <div class="map-fallback-info">
              <strong>Interactive Map</strong>
              <p>If the map doesn't appear, try viewing in a web server or download the GPX file below.</p>
              <div class="map-note">
                Note: Interactive maps may not work when viewing via file:// protocol.
              </div>
            </div>
          </div>
          
          <div class="weather-widget" id="weather-day0" data-lat="46.0523" data-lon="14.5781" data-date="2025-05-22">
            <div class="weather-header">
              <div class="weather-title">
                <i class="fas fa-cloud-sun"></i> Weather Forecast
                <span style="font-size: 0.8rem; font-weight: normal; margin-left: 8px; color: #666;">Ljubljana, Slovenia</span>
              </div>
              <div class="weather-refresh" onclick="refreshWeather('day0')">
                <i class="fas fa-sync-alt"></i> Refresh
              </div>
            </div>
            <div class="weather-content">
              <div class="weather-loading">
                <i class="fas fa-spinner"></i> Loading weather forecast...
              </div>
            </div>
            <div class="weather-toggle-container" style="text-align: center; margin-top: 8px; font-size: 0.85rem;">
              <a href="#" onclick="toggleForecastMode('day0', 'historical'); return false;" style="margin-right: 15px; color: #3498db;">
                <i class="fas fa-history"></i> Historical Average
              </a>
              <a href="#" onclick="toggleForecastMode('day0', 'forecast'); return false;" style="color: #3498db;">
                <i class="fas fa-cloud-sun-rain"></i> Current Forecast
              </a>
            </div>
          </div>
          
          <div class="gpx-download">
            <div class="gpx-download-row">
              <a href="gpx/D0_Warm-up.gpx" download class="gpx-btn">Download GPX File</a>
              <a href="route-flyover.html#route=D0_Warm-up.gpx" class="gpx-btn" style="margin-left: 10px;">
                <i class="fas fa-mountain"></i> 3D Flyover
              </a>
            </div>
            <div class="gpx-info">
              Compatible with Garmin, Wahoo, and all GPS cycling computers
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="day-section">
      <h2 class="day-toggle">Day 1 <span class="date">May 23, 2025</span></h2>
      <div class="day-content">
        <div class="route-container">
          <div class="route">
            <h3>Short Ride Option</h3>
            <div class="strava-embed-placeholder" data-embed-type="route" data-embed-id="3352952599441377432" data-style="standard" data-from-embed="false"></div>
            <div class="gpx-download">
              <div class="gpx-download-row">
                <a href="gpx/D1_East Short.gpx" download class="gpx-btn">Download GPX File</a>
                <a href="route-flyover.html#route=D1_East Short.gpx" class="gpx-btn" style="margin-left: 10px;">
                  <i class="fas fa-mountain"></i> 3D Flyover
                </a>
              </div>
              <div class="gpx-info">
                Compatible with Garmin, Wahoo, and all GPS cycling computers
              </div>
            </div>
          </div>
          <div class="route">
            <h3>Long Ride Option</h3>
            <div class="strava-embed-placeholder" data-embed-type="route" data-embed-id="3352952828352792116" data-style="standard" data-from-embed="false"></div>
            <div class="gpx-download">
              <div class="gpx-download-row">
                <a href="gpx/D1_East_Long.gpx" download class="gpx-btn">Download GPX File</a>
                <a href="route-flyover.html#route=D1_East_Long.gpx" class="gpx-btn" style="margin-left: 10px;">
                  <i class="fas fa-mountain"></i> 3D Flyover
                </a>
              </div>
              <div class="gpx-info">
                Compatible with Garmin, Wahoo, and all GPS cycling computers
              </div>
            </div>
          </div>
        </div>
        
        <h3>Compare Routes</h3>
        <div class="map-tabs">
          <div class="map-tab active" data-tab="day1-comparison">Split Point Comparison</div>
          <div class="map-tab" data-tab="day1-short">Short Route</div>
          <div class="map-tab" data-tab="day1-long">Long Route</div>
        </div>
        
        <div class="gpx-map" id="map-day1">
          <div class="map-fallback-info">
            <strong>Interactive Map</strong>
            <p>If the map doesn't appear, try viewing in a web server or download the GPX files below.</p>
            <div class="map-note">
              Note: Interactive maps may not work when viewing via file:// protocol.
            </div>
          </div>
        </div>
        
        <div class="weather-widget" id="weather-day1" data-lat="46.0523" data-lon="14.5781" data-date="2025-05-23">
          <div class="weather-header">
            <div class="weather-title">
              <i class="fas fa-cloud-sun"></i> Weather Forecast
              <span style="font-size: 0.8rem; font-weight: normal; margin-left: 8px; color: #666;">Ljubljana, Slovenia</span>
            </div>
            <div class="weather-refresh" onclick="refreshWeather('day1')">
              <i class="fas fa-sync-alt"></i> Refresh
            </div>
          </div>
          <div class="weather-content">
            <div class="weather-loading">
              <i class="fas fa-spinner"></i> Loading weather forecast...
            </div>
          </div>
          <div class="weather-toggle-container" style="text-align: center; margin-top: 8px; font-size: 0.85rem;">
            <a href="#" onclick="toggleForecastMode('day1', 'historical'); return false;" style="margin-right: 15px; color: #3498db;">
              <i class="fas fa-history"></i> Historical Average
            </a>
            <a href="#" onclick="toggleForecastMode('day1', 'forecast'); return false;" style="color: #3498db;">
              <i class="fas fa-cloud-sun-rain"></i> Current Forecast
            </a>
          </div>
        </div>
        <div class="legend">
          <div class="legend-item">
            <div class="legend-color" style="background: blue;"></div>
            <span>Common Route</span>
          </div>
          <div class="legend-item">
            <div class="legend-color" style="background: green;"></div>
            <span>Short Route</span>
          </div>
          <div class="legend-item">
            <div class="legend-color" style="background: red;"></div>
            <span>Long Route</span>
          </div>
          <div class="legend-item">
            <div class="legend-point" style="background: #ff6b6b;"></div>
            <span>Decision Point</span>
          </div>
        </div>
      </div>
    </div>

    <div class="day-section">
      <h2 class="day-toggle">Day 2 <span class="date">May 24, 2025</span></h2>
      <div class="day-content">
        <div class="route-container">
          <div class="route">
            <h3>Short Ride Option</h3>
            <div class="strava-embed-placeholder" data-embed-type="route" data-embed-id="3352953250499092020" data-style="standard" data-from-embed="false"></div>
            <div class="gpx-download">
              <div class="gpx-download-row">
                <a href="gpx/D2_North_Short.gpx" download class="gpx-btn">Download GPX File</a>
                <a href="route-flyover.html#route=D2_North_Short.gpx" class="gpx-btn" style="margin-left: 10px;">
                  <i class="fas fa-mountain"></i> 3D Flyover
                </a>
              </div>
              <div class="gpx-info">
                Compatible with Garmin, Wahoo, and all GPS cycling computers
              </div>
            </div>
          </div>
          <div class="route">
            <h3>Long Ride Option</h3>
            <div class="strava-embed-placeholder" data-embed-type="route" data-embed-id="3352953056042166424" data-style="standard" data-from-embed="false"></div>
            <div class="gpx-download">
              <div class="gpx-download-row">
                <a href="gpx/D2_North_Long.gpx" download class="gpx-btn">Download GPX File</a>
                <a href="route-flyover.html#route=D2_North_Long.gpx" class="gpx-btn" style="margin-left: 10px;">
                  <i class="fas fa-mountain"></i> 3D Flyover
                </a>
              </div>
              <div class="gpx-info">
                Compatible with Garmin, Wahoo, and all GPS cycling computers
              </div>
            </div>
          </div>
        </div>
        
        <h3>Compare Routes</h3>
        <div class="map-tabs">
          <div class="map-tab active" data-tab="day2-comparison">Split Point Comparison</div>
          <div class="map-tab" data-tab="day2-short">Short Route</div>
          <div class="map-tab" data-tab="day2-long">Long Route</div>
        </div>
        
        <div class="gpx-map" id="map-day2">
          <div class="map-fallback-info">
            <strong>Interactive Map</strong>
            <p>If the map doesn't appear, try viewing in a web server or download the GPX files below.</p>
            <div class="map-note">
              Note: Interactive maps may not work when viewing via file:// protocol.
            </div>
          </div>
        </div>
        
        <div class="weather-widget" id="weather-day2" data-lat="46.0523" data-lon="14.5781" data-date="2025-05-24">
          <div class="weather-header">
            <div class="weather-title">
              <i class="fas fa-cloud-sun"></i> Weather Forecast
              <span style="font-size: 0.8rem; font-weight: normal; margin-left: 8px; color: #666;">Ljubljana, Slovenia</span>
            </div>
            <div class="weather-refresh" onclick="refreshWeather('day2')">
              <i class="fas fa-sync-alt"></i> Refresh
            </div>
          </div>
          <div class="weather-content">
            <div class="weather-loading">
              <i class="fas fa-spinner"></i> Loading weather forecast...
            </div>
          </div>
          <div class="weather-toggle-container" style="text-align: center; margin-top: 8px; font-size: 0.85rem;">
            <a href="#" onclick="toggleForecastMode('day2', 'historical'); return false;" style="margin-right: 15px; color: #3498db;">
              <i class="fas fa-history"></i> Historical Average
            </a>
            <a href="#" onclick="toggleForecastMode('day2', 'forecast'); return false;" style="color: #3498db;">
              <i class="fas fa-cloud-sun-rain"></i> Current Forecast
            </a>
          </div>
        </div>
        <div class="legend">
          <div class="legend-item">
            <div class="legend-color" style="background: blue;"></div>
            <span>Common Route</span>
          </div>
          <div class="legend-item">
            <div class="legend-color" style="background: green;"></div>
            <span>Short Route</span>
          </div>
          <div class="legend-item">
            <div class="legend-color" style="background: red;"></div>
            <span>Long Route</span>
          </div>
          <div class="legend-item">
            <div class="legend-point" style="background: #ff6b6b;"></div>
            <span>Decision Point</span>
          </div>
        </div>
      </div>
    </div>

    <div class="day-section">
      <h2 class="day-toggle">Day 3 <span class="date">May 25, 2025</span></h2>
      <div class="day-content">
        <div class="route-container">
          <div class="route">
            <h3>Short Ride Option</h3>
            <div class="strava-embed-placeholder" data-embed-type="route" data-embed-id="3352953610025735896" data-style="standard" data-from-embed="false"></div>
            <div class="gpx-download">
              <div class="gpx-download-row">
                <a href="gpx/D3_West_Short.gpx" download class="gpx-btn">Download GPX File</a>
                <a href="route-flyover.html#route=D3_West_Short.gpx" class="gpx-btn" style="margin-left: 10px;">
                  <i class="fas fa-mountain"></i> 3D Flyover
                </a>
              </div>
              <div class="gpx-info">
                Compatible with Garmin, Wahoo, and all GPS cycling computers
              </div>
            </div>
          </div>
          <div class="route">
            <h3>Long Ride Option</h3>
            <div class="strava-embed-placeholder" data-embed-type="route" data-embed-id="3352953454882061876" data-style="standard" data-from-embed="false"></div>
            <div class="gpx-download">
              <div class="gpx-download-row">
                <a href="gpx/D3_West_Long.gpx" download class="gpx-btn">Download GPX File</a>
                <a href="route-flyover.html#route=D3_West_Long.gpx" class="gpx-btn" style="margin-left: 10px;">
                  <i class="fas fa-mountain"></i> 3D Flyover
                </a>
              </div>
              <div class="gpx-info">
                Compatible with Garmin, Wahoo, and all GPS cycling computers
              </div>
            </div>
          </div>
        </div>
        
        <h3>Compare Routes</h3>
        <div class="map-tabs">
          <div class="map-tab active" data-tab="day3-comparison">Split Point Comparison</div>
          <div class="map-tab" data-tab="day3-short">Short Route</div>
          <div class="map-tab" data-tab="day3-long">Long Route</div>
        </div>
        
        <div class="gpx-map" id="map-day3">
          <div class="map-fallback-info">
            <strong>Interactive Map</strong>
            <p>If the map doesn't appear, try viewing in a web server or download the GPX files below.</p>
            <div class="map-note">
              Note: Interactive maps may not work when viewing via file:// protocol.
            </div>
          </div>
        </div>
        
        <div class="weather-widget" id="weather-day3" data-lat="46.0523" data-lon="14.5781" data-date="2025-05-25">
          <div class="weather-header">
            <div class="weather-title">
              <i class="fas fa-cloud-sun"></i> Weather Forecast
              <span style="font-size: 0.8rem; font-weight: normal; margin-left: 8px; color: #666;">Ljubljana, Slovenia</span>
            </div>
            <div class="weather-refresh" onclick="refreshWeather('day3')">
              <i class="fas fa-sync-alt"></i> Refresh
            </div>
          </div>
          <div class="weather-content">
            <div class="weather-loading">
              <i class="fas fa-spinner"></i> Loading weather forecast...
            </div>
          </div>
          <div class="weather-toggle-container" style="text-align: center; margin-top: 8px; font-size: 0.85rem;">
            <a href="#" onclick="toggleForecastMode('day3', 'historical'); return false;" style="margin-right: 15px; color: #3498db;">
              <i class="fas fa-history"></i> Historical Average
            </a>
            <a href="#" onclick="toggleForecastMode('day3', 'forecast'); return false;" style="color: #3498db;">
              <i class="fas fa-cloud-sun-rain"></i> Current Forecast
            </a>
          </div>
        </div>
        <div class="legend">
          <div class="legend-item">
            <div class="legend-color" style="background: blue;"></div>
            <span>Common Route</span>
          </div>
          <div class="legend-item">
            <div class="legend-color" style="background: green;"></div>
            <span>Short Route</span>
          </div>
          <div class="legend-item">
            <div class="legend-color" style="background: red;"></div>
            <span>Long Route</span>
          </div>
          <div class="legend-item">
            <div class="legend-point" style="background: #ff6b6b;"></div>
            <span>Decision Point</span>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script src="https://strava-embeds.com/embed.js"></script>
  <script>
    // Mapbox access token
    mapboxgl.accessToken = 'pk.eyJ1IjoiZWJvd21hbiIsImEiOiJjbWE1ZWVwdzYwODhwMmlzZnU4NTlyem1rIn0.E10X5hj2NTgViJexKpvrOg';
    
    document.addEventListener('DOMContentLoaded', function() {
      // Hide fallback info if maps initialize properly
      document.querySelectorAll('.map-fallback-info').forEach(info => {
        // Make it transparent at first so we can check if maps load properly
        info.style.opacity = '0.3';
        
        // After a delay, hide it completely if maps are working
        setTimeout(() => {
          if (window.mapboxgl) {
            info.style.display = 'none';
          } else {
            info.style.opacity = '1';
          }
        }, 1500);
      });
      
      // Initialize maps
      const maps = {
        'day0': initMap('map-day0', ['gpx/D0_Warm-up.gpx']),
        'day1': initMap('map-day1', ['gpx/D1_East Short.gpx', 'gpx/D1_East_Long.gpx']),
        'day2': initMap('map-day2', ['gpx/D2_North_Short.gpx', 'gpx/D2_North_Long.gpx']),
        'day3': initMap('map-day3', ['gpx/D3_West_Short.gpx', 'gpx/D3_West_Long.gpx'])
      };
      
      // Initialize tabs
      const tabs = document.querySelectorAll('.map-tab');
      tabs.forEach(tab => {
        tab.addEventListener('click', function() {
          // Get the parent container
          const parent = this.parentElement;
          // Remove active class from all siblings
          parent.querySelectorAll('.map-tab').forEach(t => t.classList.remove('active'));
          // Add active class to this tab
          this.classList.add('active');
          
          // Get the map ID and tab type
          const [day, type] = this.dataset.tab.split('-');
          const mapContainer = document.getElementById(`map-${day}`);
          
          // Handle tab switching
          switch(type) {
            case 'comparison':
              showComparison(maps[day], day);
              break;
            case 'short':
              showSingleRoute(maps[day], day, 'short');
              break;
            case 'long':
              showSingleRoute(maps[day], day, 'long');
              break;
          }
        });
      });
      
      // Toggle day sections
      const toggles = document.querySelectorAll('.day-toggle');
      toggles.forEach(toggle => {
        toggle.addEventListener('click', function() {
          // Toggle the collapsed class on the title
          this.classList.toggle('collapsed');
          
          // Find the content section and toggle its collapsed class
          const content = this.nextElementSibling;
          content.classList.toggle('collapsed');
          
          // Re-initialize maps and Strava embeds when expanding
          if (!content.classList.contains('collapsed')) {
            if (window.StravaEmbed) {
              window.StravaEmbed.init();
            }
            
            // Get the day number from the toggle
            const dayId = this.textContent.trim().toLowerCase().replace(/\s+/g, '').includes('day0') 
              ? 'day0' 
              : this.textContent.trim().toLowerCase().replace(/\s+/g, '').includes('day1')
                ? 'day1'
                : this.textContent.trim().toLowerCase().replace(/\s+/g, '').includes('day2')
                  ? 'day2'
                  : 'day3';
            
            // Trigger a resize on the map to fix any display issues
            if (maps[dayId]) {
              maps[dayId].resize();
              
              // Find the active tab for this day
              const activeTab = content.querySelector('.map-tab.active');
              if (activeTab) {
                const [day, type] = activeTab.dataset.tab.split('-');
                if (type === 'comparison') {
                  showComparison(maps[day], day);
                } else if (type === 'short') {
                  showSingleRoute(maps[day], day, 'short');
                } else if (type === 'long') {
                  showSingleRoute(maps[day], day, 'long');
                }
              }
            }
          }
        });
      });
      
      // Initialize all maps with comparison view
      showComparison(maps.day0, 'day0');
      showComparison(maps.day1, 'day1');
      showComparison(maps.day2, 'day2');
      showComparison(maps.day3, 'day3');
      
      // Optional: Start with all sections expanded except the first one
      // Uncomment the following lines if you want this behavior
      /*
      const firstToggle = toggles[0];
      if (firstToggle) {
        firstToggle.classList.remove('collapsed');
        firstToggle.nextElementSibling.classList.remove('collapsed');
        
        for (let i = 1; i < toggles.length; i++) {
          toggles[i].classList.add('collapsed');
          toggles[i].nextElementSibling.classList.add('collapsed');
        }
      }
      */
    });
    
    // Map initialization function
    function initMap(id, gpxFiles) {
      const map = new mapboxgl.Map({
        container: id,
        style: 'mapbox://styles/mapbox/outdoors-v12',
        center: [14.5, 46.05], // Ljubljana, Slovenia
        zoom: 11
      });
      
      // Store track layers and loaded state for later reference
      map.trackLayers = [];
      map.routesLoaded = false;
      
      // Add error handling
      map.on('error', function(e) {
        if (!map.errorDisplayed) {
          const mapContainer = document.getElementById(id);
          const errorMsg = document.createElement('div');
          errorMsg.className = 'map-error';
          errorMsg.innerHTML = '<strong>Map loading error</strong><br>If viewing locally, please run a local server or view GPX files directly.';
          errorMsg.style.position = 'absolute';
          errorMsg.style.zIndex = 1000;
          errorMsg.style.top = '50%';
          errorMsg.style.left = '50%';
          errorMsg.style.transform = 'translate(-50%, -50%)';
          errorMsg.style.background = 'rgba(255,255,255,0.9)';
          errorMsg.style.padding = '10px';
          errorMsg.style.borderRadius = '5px';
          errorMsg.style.boxShadow = '0 0 10px rgba(0,0,0,0.2)';
          mapContainer.appendChild(errorMsg);
          map.errorDisplayed = true;
        }
      });
      
      // Load GPX files when the map style is fully loaded
      map.on('load', function() {
        loadGPXRoutes(map, gpxFiles);
      });
      
      return map;
    }
    
    // Function to load GPX routes
    async function loadGPXRoutes(map, gpxFiles) {
      try {
        const bounds = new mapboxgl.LngLatBounds();
        
        // Load each GPX file
        for (let i = 0; i < gpxFiles.length; i++) {
          const response = await fetch(gpxFiles[i]);
          const gpxData = await response.text();
          
          // Parse GPX
          const parser = new DOMParser();
          const gpx = parser.parseFromString(gpxData, 'text/xml');
          const trackPoints = gpx.querySelectorAll('trkpt');
          
          // Extract coordinates
          const coordinates = [];
          
          trackPoints.forEach(point => {
            const lat = parseFloat(point.getAttribute('lat'));
            const lon = parseFloat(point.getAttribute('lon'));
            // Include elevation if available
            let elevation = 0;
            const eleTag = point.querySelector('ele');
            if (eleTag && eleTag.textContent) {
              elevation = parseFloat(eleTag.textContent);
            }
            
            coordinates.push([lon, lat, elevation]);
            
            // Extend bounds
            bounds.extend([lon, lat]);
          });
          
          // Create GeoJSON
          const geojson = {
            type: 'Feature',
            properties: {},
            geometry: {
              type: 'LineString',
              coordinates: coordinates
            }
          };
          
          // Choose color based on route type
          let color = 'blue';
          let routeType = 'single';
          
          if (gpxFiles.length > 1) {
            color = i === 0 ? 'green' : 'red';
            routeType = i === 0 ? 'short' : 'long';
          }
          
          // Add source and layer
          const sourceId = `route-${id}-${i}`;
          const layerId = `route-layer-${id}-${i}`;
          
          map.addSource(sourceId, {
            type: 'geojson',
            data: geojson
          });
          
          map.addLayer({
            id: layerId,
            type: 'line',
            source: sourceId,
            layout: {
              'line-join': 'round',
              'line-cap': 'round'
            },
            paint: {
              'line-color': color,
              'line-width': 5,
              'line-opacity': 0.7
            }
          });
          
          // Store track info
          map.trackLayers.push({
            sourceId: sourceId,
            layerId: layerId,
            type: routeType,
            coordinates: coordinates
          });
        }
        
        // Fit map to bounds with padding
        map.fitBounds(bounds, { padding: 50 });
        
        // Find decision point if we have two routes
        if (gpxFiles.length === 2) {
          findDecisionPoints(map);
        }
        
        // Mark routes as loaded
        map.routesLoaded = true;
      } catch (error) {
        console.error("Error loading GPX routes:", error);
        
        // Display error message on map
        const mapContainer = document.getElementById(map.getContainer().id);
        const errorMsg = document.createElement('div');
        errorMsg.className = 'gpx-error';
        errorMsg.innerHTML = '<strong>GPX loading error</strong><br>Could not load or parse route data.';
        errorMsg.style.position = 'absolute';
        errorMsg.style.zIndex = 1000;
        errorMsg.style.bottom = '10px';
        errorMsg.style.left = '10px';
        errorMsg.style.background = 'rgba(255,255,255,0.9)';
        errorMsg.style.padding = '8px';
        errorMsg.style.borderRadius = '4px';
        errorMsg.style.fontSize = '0.8rem';
        mapContainer.appendChild(errorMsg);
      }
    }
    
    // Function to find and mark decision points
    function findDecisionPoints(map) {
      try {
        if (map.trackLayers.length < 2) return;
        
        // Get coordinates from the stored track layers
        const shortCoords = map.trackLayers.find(layer => layer.type === 'short').coordinates;
        const longCoords = map.trackLayers.find(layer => layer.type === 'long').coordinates;
        
        if (!shortCoords || !shortCoords.length || !longCoords || !longCoords.length) {
          console.error("Could not find valid coordinates in routes");
          return;
        }
        
        // Convert coordinates to Turf points for distance calculation
        const shortPoints = shortCoords.map(coord => turf.point([coord[0], coord[1]]));
        const longPoints = longCoords.map(coord => turf.point([coord[0], coord[1]]));
        
        // Find the divergence point
        const threshold = 0.05; // ~50 meters in km
        let shortIndex = 0, longIndex = 0;
        let foundDivergence = false;
        
        // Skip the first 1km equivalent of points (rough estimate)
        const skipDistance = 1; // 1km
        let shortSkipIndex = 0;
        let longSkipIndex = 0;
        let shortDistanceTotal = 0;
        let longDistanceTotal = 0;
        
        // Find roughly where 1km is on each route
        for (let i = 1; i < shortPoints.length; i++) {
          if (shortDistanceTotal >= skipDistance) break;
          const dist = turf.distance(shortPoints[i-1], shortPoints[i], {units: 'kilometers'});
          shortDistanceTotal += dist;
          shortSkipIndex = i;
        }
        
        for (let i = 1; i < longPoints.length; i++) {
          if (longDistanceTotal >= skipDistance) break;
          const dist = turf.distance(longPoints[i-1], longPoints[i], {units: 'kilometers'});
          longDistanceTotal += dist;
          longSkipIndex = i;
        }
        
        // Sample the routes to find the divergence point
        const shortSampleRate = Math.max(1, Math.floor(shortPoints.length / 50));
        const longSampleRate = Math.max(1, Math.floor(longPoints.length / 50));
        
        // Find points where routes diverge by sampling
        for (let i = shortSkipIndex; i < shortPoints.length; i += shortSampleRate) {
          let minDistance = Infinity;
          let closestLongIndex = 0;
          
          // Find closest point on long route
          for (let j = longSkipIndex; j < longPoints.length; j += longSampleRate) {
            const distance = turf.distance(shortPoints[i], longPoints[j], {units: 'kilometers'});
            if (distance < minDistance) {
              minDistance = distance;
              closestLongIndex = j;
            }
          }
          
          // If the minimum distance is greater than threshold, routes diverge
          if (minDistance > threshold) {
            shortIndex = i;
            longIndex = closestLongIndex;
            foundDivergence = true;
            break;
          }
        }
        
        // If we couldn't find a divergence, use 1/3 of the route as fallback
        if (!foundDivergence) {
          shortIndex = Math.floor(shortPoints.length / 3);
          longIndex = Math.floor(longPoints.length / 3);
        }
        
        // Make sure indices are valid
        shortIndex = Math.max(shortSkipIndex, Math.min(shortIndex, shortPoints.length - 1));
        longIndex = Math.max(longSkipIndex, Math.min(longIndex, longPoints.length - 1));
        
        // Get the points at the divergence
        const shortPoint = shortCoords[shortIndex];
        const longPoint = longCoords[longIndex];
        
        // Calculate midpoint
        const decisionPoint = [
          (shortPoint[0] + longPoint[0]) / 2,
          (shortPoint[1] + longPoint[1]) / 2
        ];
        
        // Create HTML for the marker
        const el = document.createElement('div');
        el.className = 'decision-point';
        
        // Add marker
        const marker = new mapboxgl.Marker(el)
          .setLngLat(decisionPoint)
          .setPopup(
            new mapboxgl.Popup({offset: 25})
              .setHTML('<strong>Decision Point</strong><br>Choose between short or long route here.')
          )
          .addTo(map);
        
        // Store marker reference
        map.decisionMarker = marker;
      } catch (e) {
        console.error("Error finding decision points:", e);
      }
    }
    
    // Function to show comparison view
    function showComparison(map, day) {
      if (!map || !map.routesLoaded) return;
      
      // Show all layers
      map.trackLayers.forEach(item => {
        map.setLayoutProperty(item.layerId, 'visibility', 'visible');
      });
      
      // Show decision marker if it exists
      if (map.decisionMarker) {
        map.decisionMarker.addTo(map);
      }
    }
    
    // Function to show just one route
    function showSingleRoute(map, day, routeType) {
      if (!map || !map.routesLoaded) return;
      
      // Hide all layers first
      map.trackLayers.forEach(item => {
        map.setLayoutProperty(item.layerId, 'visibility', 'none');
      });
      
      // Hide decision marker if it exists
      if (map.decisionMarker) {
        map.decisionMarker.remove();
      }
      
      // Show only the requested route
      const layerToShow = map.trackLayers.find(item => 
        routeType === 'short' ? item.type === 'short' : 
        routeType === 'long' ? item.type === 'long' : 
        item.type === 'single'
      );
      
      if (layerToShow) {
        map.setLayoutProperty(layerToShow.layerId, 'visibility', 'visible');
      }
    }
    
    // Weather widget functionality
  
    // Load all weather widgets when the page loads
    document.addEventListener('DOMContentLoaded', function() {
      const weatherWidgets = document.querySelectorAll('.weather-widget');
      weatherWidgets.forEach(widget => {
        const dayId = widget.id.replace('weather-', '');
        loadWeatherForecast(dayId);
      });
    });
    
    // Function to refresh a specific weather widget
    function refreshWeather(dayId) {
      const widget = document.getElementById(`weather-${dayId}`);
      if (!widget) return;
      
      // Show loading state
      const content = widget.querySelector('.weather-content');
      content.innerHTML = `
        <div class="weather-loading">
          <i class="fas fa-spinner"></i> Refreshing weather forecast...
        </div>
      `;
      
      // Load fresh weather data
      loadWeatherForecast(dayId);
    }
    
    // Function to load weather forecast for a specific day
    function loadWeatherForecast(dayId) {
      const widget = document.getElementById(`weather-${dayId}`);
      if (!widget) return;
      
      const lat = widget.dataset.lat;
      const lon = widget.dataset.lon;
      const date = widget.dataset.date;
      
      fetchWeatherData(lat, lon, date)
        .then(data => {
          displayWeatherData(dayId, data);
        })
        .catch(error => {
          displayWeatherError(dayId, error);
        });
    }
    
    // Function to fetch weather data from Open-Meteo API
    async function fetchWeatherData(lat, lon, date) {
      try {
        // Parse the target date
        const targetDate = new Date(date);
        
        // Get current date to determine if we need historical or forecast data
        const currentDate = new Date();
        
        // We need to use historical API if the date is more than a day in the past
        const isHistorical = targetDate < new Date(currentDate.getTime() - 24 * 60 * 60 * 1000);
        
        // Calculate start and end dates for 3-day window around target date
        const startDate = new Date(targetDate);
        startDate.setDate(startDate.getDate() - 1);
        const endDate = new Date(targetDate);
        endDate.setDate(endDate.getDate() + 1);
        
        // Format dates as YYYY-MM-DD for API
        const formatAPIDate = (date) => {
          return date.toISOString().split('T')[0];
        };
        
        // Prepare API URL based on whether we need historical or forecast data
        let apiUrl;
        
        if (isHistorical) {
          // For historical data (past)
          apiUrl = `https://archive-api.open-meteo.com/v1/archive?latitude=${lat}&longitude=${lon}` +
            `&start_date=${formatAPIDate(startDate)}&end_date=${formatAPIDate(endDate)}` +
            `&daily=weathercode,temperature_2m_max,temperature_2m_min,precipitation_sum,windspeed_10m_max` +
            `&timezone=auto`;
        } else {
          // For forecast data (future or current)
          apiUrl = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}` +
            `&daily=weathercode,temperature_2m_max,temperature_2m_min,precipitation_probability_max,windspeed_10m_max` +
            `&current_weather=true&timezone=auto`;
        }
        
        // Make the API request
        const response = await fetch(apiUrl);
        
        if (!response.ok) {
          throw new Error(`Weather API error: ${response.status}`);
        }
        
        const data = await response.json();
        
        // Process the data into our desired format
        return processWeatherData(data, targetDate, isHistorical);
        
      } catch (error) {
        console.error('Error fetching weather data:', error);
        throw new Error('Unable to fetch weather forecast. Please try again later.');
      }
    }
    
    // Process the API response into our app's weather format
    function processWeatherData(data, targetDate, isHistorical) {
      // Create an array to hold our processed forecast
      const forecast = [];
      
      // Get the daily data arrays from the API response
      const { daily } = data;
      
      if (!daily || !daily.time || daily.time.length === 0) {
        throw new Error('Invalid weather data format');
      }
      
      // Get indices for the 3 days we want to display
      const startIdx = 0; // First day in the response
      const endIdx = Math.min(daily.time.length - 1, 2); // Up to 3 days
      
      // Process each day's weather data
      for (let i = startIdx; i <= endIdx; i++) {
        const date = new Date(daily.time[i]);
        const weatherCode = daily.weathercode[i];
        const maxTemp = Math.round(daily.temperature_2m_max[i]);
        const minTemp = Math.round(daily.temperature_2m_min[i]);
        const avgTemp = Math.round((maxTemp + minTemp) / 2);
        const windSpeed = Math.round(daily.windspeed_10m_max[i]);
        
        // Precipitation probability is only available in forecast data
        // For historical, we can approximate from precipitation_sum
        let chanceOfRain = 0;
        if (isHistorical) {
          // Rough approximation: if there was precipitation, say 70% chance
          chanceOfRain = daily.precipitation_sum[i] > 0 ? 70 : 10;
        } else {
          // For forecast data, we have the probability directly
          chanceOfRain = daily.precipitation_probability_max ? 
            daily.precipitation_probability_max[i] : 0;
        }
        
        // Map WMO weather codes to our icon and description
        // https://www.nodc.noaa.gov/archive/arc0021/0002199/1.1/data/0-data/HTML/WMO-CODE/WMO4677.HTM
        const weatherInfo = getWeatherInfo(weatherCode);
        
        forecast.push({
          date: date,
          temp: avgTemp,
          tempMax: maxTemp,
          tempMin: minTemp,
          icon: weatherInfo.icon,
          description: weatherInfo.description,
          windSpeed: windSpeed,
          chanceOfRain: chanceOfRain,
          weatherCode: weatherCode
        });
      }
      
      // Generate weather alert if conditions warrant it
      const alert = generateWeatherAlert(forecast);
      
      return {
        forecast: forecast,
        alert: alert
      };
    }
    
    // Map WMO weather codes to icons and descriptions
    function getWeatherInfo(code) {
      // Weather codes from Open-Meteo API: https://open-meteo.com/en/docs
      // WMO Weather interpretation codes (WW)
      switch (true) {
        case code === 0: // Clear sky
          return { icon: 'sun', description: 'Clear sky' };
        case code === 1: // Mainly clear
          return { icon: 'sun', description: 'Mainly clear' };
        case code === 2: // Partly cloudy
          return { icon: 'cloud-sun', description: 'Partly cloudy' };
        case code === 3: // Overcast
          return { icon: 'cloud', description: 'Overcast' };
        case code === 45 || code === 48: // Fog
          return { icon: 'smog', description: 'Fog' };
        case code >= 51 && code <= 55: // Drizzle
          return { icon: 'cloud-rain', description: 'Light drizzle' };
        case code >= 56 && code <= 57: // Freezing Drizzle
          return { icon: 'snowflake', description: 'Freezing drizzle' };
        case code >= 61 && code <= 65: // Rain
          return { icon: 'cloud-showers-heavy', description: 'Rain' };
        case code >= 66 && code <= 67: // Freezing Rain
          return { icon: 'cloud-meatball', description: 'Freezing rain' };
        case code >= 71 && code <= 77: // Snow
          return { icon: 'snowflake', description: 'Snow' };
        case code >= 80 && code <= 82: // Rain showers
          return { icon: 'cloud-sun-rain', description: 'Rain showers' };
        case code >= 85 && code <= 86: // Snow showers
          return { icon: 'snowflake', description: 'Snow showers' };
        case code === 95: // Thunderstorm
          return { icon: 'bolt', description: 'Thunderstorm' };
        case code >= 96 && code <= 99: // Thunderstorm with hail
          return { icon: 'cloud-bolt', description: 'Thunderstorm with hail' };
        default:
          return { icon: 'cloud', description: 'Unknown conditions' };
      }
    }
    
    // Generate meaningful weather alerts based on actual conditions
    function generateWeatherAlert(forecast) {
      // Check the weather conditions to generate relevant alerts
      
      // Check for high winds (above 30 km/h)
      const highWinds = forecast.some(day => day.windSpeed > 30);
      
      // Check for heavy rain (high precipitation probability)
      const heavyRain = forecast.some(day => day.chanceOfRain > 70);
      
      // Check for extreme temperatures
      const extremeHeat = forecast.some(day => day.tempMax > 30);
      const extremeCold = forecast.some(day => day.tempMin < 0);
      
      // Check for thunderstorms
      const thunderstorms = forecast.some(day => 
        day.weatherCode === 95 || 
        day.weatherCode === 96 || 
        day.weatherCode === 99
      );
      
      // Check for snow
      const snow = forecast.some(day => 
        (day.weatherCode >= 71 && day.weatherCode <= 77) || 
        (day.weatherCode >= 85 && day.weatherCode <= 86)
      );
      
      // Generate appropriate alert or return null if conditions are good
      if (thunderstorms) {
        return {
          type: 'severe',
          message: 'Thunderstorms expected. Take shelter if lightning is present.'
        };
      } else if (snow) {
        return {
          type: 'severe',
          message: 'Snow expected. Be prepared for cold, slippery conditions.'
        };
      } else if (extremeHeat) {
        return {
          type: 'warning',
          message: 'High temperatures expected. Stay hydrated and take breaks in shade.'
        };
      } else if (extremeCold) {
        return {
          type: 'warning',
          message: 'Freezing temperatures expected. Dress in warm layers.'
        };
      } else if (highWinds) {
        return {
          type: 'warning',
          message: 'Strong winds expected. Be cautious on exposed routes.'
        };
      } else if (heavyRain) {
        return {
          type: 'warning',
          message: 'Heavy rainfall possible. Be prepared for wet conditions.'
        };
      }
      
      // No significant weather concerns
      return null;
    }
    
    // Function to display weather data in the widget
    function displayWeatherData(dayId, data) {
      const widget = document.getElementById(`weather-${dayId}`);
      if (!widget) return;
      
      const content = widget.querySelector('.weather-content');
      const isHistorical = data.isHistorical;
      
      // Format date for display
      const formatDate = (date) => {
        const options = { weekday: 'short', month: 'short', day: 'numeric' };
        return date.toLocaleDateString('en-US', options);
      };
      
      // Build the weather cards HTML
      let html = '';
      
      // If showing historical data, add a header
      if (isHistorical) {
        html += `
          <div style="width: 100%; text-align: center; margin-bottom: 10px; font-weight: bold; color: #2980b9;">
            Recent Years' Daytime Temperatures
          </div>
        `;
      }
      
      data.forecast.forEach(day => {
        // For historical data, simplify the display to focus on the daytime temperature
        if (isHistorical) {
          html += `
            <div class="weather-day" style="${isHistorical ? 'background-color: #f8f9fa;' : ''}">
              <div class="weather-date">${formatDate(day.date)}</div>
              <div class="weather-icon">
                <i class="fas fa-${day.icon}"></i>
              </div>
              <div class="weather-temp" style="font-size: ${isHistorical ? '1.6rem' : '1.4rem'}; color: #e74c3c;">
                ${day.tempMax}°C
              </div>
              <div style="font-size: 0.8rem; margin-bottom: 4px;">
                Typical Daytime High
              </div>
              <div class="weather-desc">${day.description}</div>
              <div class="weather-details">
                <div>
                  <i class="fas fa-wind"></i> ${day.windSpeed} km/h
                </div>
                <div>
                  <i class="fas fa-tint"></i> ${day.chanceOfRain}%
                </div>
              </div>
            </div>
          `;
        } else {
          // Regular forecast display
          html += `
            <div class="weather-day">
              <div class="weather-date">${formatDate(day.date)}</div>
              <div class="weather-icon">
                <i class="fas fa-${day.icon}"></i>
              </div>
              <div class="weather-temp">${day.temp}°C</div>
              <div style="font-size: 0.75rem; color: #666; margin-bottom: 4px;">
                <span style="color: #e74c3c;">${day.tempMax}°</span> / <span style="color: #3498db;">${day.tempMin}°</span>
              </div>
              <div class="weather-desc">${day.description}</div>
              <div class="weather-details">
                <div>
                  <i class="fas fa-wind"></i> ${day.windSpeed} km/h
                </div>
                <div>
                  <i class="fas fa-tint"></i> ${day.chanceOfRain}%
                </div>
              </div>
            </div>
          `;
        }
      });
      
      // Add any weather alerts
      if (data.alert) {
        html += `
          <div class="weather-alert ${data.alert.type}">
            <i class="fas fa-exclamation-triangle"></i> 
            <strong>${data.alert.type === 'severe' ? 'Alert' : 'Warning'}</strong>: ${data.alert.message}
          </div>
        `;
      }
      
      // Add the attribution note to the HTML
      html += `
        <div style="font-size: 0.75rem; color: #999; text-align: center; margin-top: 12px; width: 100%;">
          Weather data provided by <a href="https://open-meteo.com/" target="_blank" style="color: #3498db;">Open-Meteo.com</a>
        </div>
      `;
      
      // Update the widget content with the complete HTML
      content.innerHTML = html;
    }
    
    // Function to display an error in the weather widget
    function displayWeatherError(dayId, error) {
      const widget = document.getElementById(`weather-${dayId}`);
      if (!widget) return;
      
      const content = widget.querySelector('.weather-content');
      content.innerHTML = `
        <div class="weather-error">
          <i class="fas fa-exclamation-circle"></i>
          ${error.message || 'Unable to load weather data'}
        </div>
        <button onclick="refreshWeather('${dayId}')" class="gpx-btn" style="margin-top:15px;">
          <i class="fas fa-sync-alt"></i> Try Again
        </button>
      `;
    }
    
    // Store weather data for each widget
    const weatherDataCache = {};
    
    // Toggle between historical data and current forecast
    function toggleForecastMode(dayId, mode) {
      const widget = document.getElementById(`weather-${dayId}`);
      if (!widget) return;
      
      // Save the current mode to the widget
      widget.dataset.mode = mode;
      
      // Update the active state of the toggle buttons
      const historicalLink = widget.querySelector('.weather-toggle-container a:first-child');
      const forecastLink = widget.querySelector('.weather-toggle-container a:last-child');
      
      if (mode === 'historical') {
        historicalLink.style.fontWeight = 'bold';
        forecastLink.style.fontWeight = 'normal';
        historicalLink.style.textDecoration = 'underline';
        forecastLink.style.textDecoration = 'none';
      } else {
        historicalLink.style.fontWeight = 'normal';
        forecastLink.style.fontWeight = 'bold';
        historicalLink.style.textDecoration = 'none';
        forecastLink.style.textDecoration = 'underline';
      }
      
      // Show loading state
      const content = widget.querySelector('.weather-content');
      content.innerHTML = `
        <div class="weather-loading">
          <i class="fas fa-spinner"></i> Loading ${mode === 'historical' ? 'historical' : 'forecast'} data...
        </div>
      `;
      
      // Load the data for the selected mode
      const lat = widget.dataset.lat;
      const lon = widget.dataset.lon;
      const date = widget.dataset.date;
      
      // If we're requesting historical data, use the historical API
      if (mode === 'historical') {
        fetchHistoricalWeatherData(lat, lon, date)
          .then(data => {
            // Cache the data
            weatherDataCache[`${dayId}-historical`] = data;
            displayWeatherData(dayId, data);
          })
          .catch(error => {
            displayWeatherError(dayId, error);
          });
      } else {
        // Otherwise load regular forecast/current data
        fetchWeatherData(lat, lon, date)
          .then(data => {
            // Cache the data
            weatherDataCache[`${dayId}-forecast`] = data;
            displayWeatherData(dayId, data);
          })
          .catch(error => {
            displayWeatherError(dayId, error);
          });
      }
    }
    
    // Fetch historical climate data for a location
    async function fetchHistoricalWeatherData(lat, lon, date) {
      try {
        // Parse the target date to get month and day
        const targetDate = new Date(date);
        const month = targetDate.getMonth() + 1; // 1-12
        const day = targetDate.getDate(); // 1-31
        
        // For a cycling event during the day, we'll focus on daytime high temperatures
        // from the most recent years to provide the most relevant data
        
        // Get the same calendar day for the past 3 years (2021, 2022, 2023)
        const threeYearsData = [];
        
        // We'll get data for a 3-day window centered on the target date
        // for each of the last 3 years
        for (let year = 2021; year <= 2023; year++) {
          // Calculate the 3-day window
          const dayMinus1 = new Date(year, targetDate.getMonth(), targetDate.getDate() - 1);
          const dayPlus1 = new Date(year, targetDate.getMonth(), targetDate.getDate() + 1);
          
          // Format dates for API
          const formatDateForAPI = (d) => {
            return `${d.getFullYear()}-${(d.getMonth() + 1).toString().padStart(2, '0')}-${d.getDate().toString().padStart(2, '0')}`;
          };
          
          const startDate = formatDateForAPI(dayMinus1);
          const endDate = formatDateForAPI(dayPlus1);
          
          // Request for this year's data
          const apiUrl = `https://archive-api.open-meteo.com/v1/era5?latitude=${lat}&longitude=${lon}` +
            `&start_date=${startDate}&end_date=${endDate}` +
            `&daily=temperature_2m_max,precipitation_sum,windspeed_10m_max` +
            `&timezone=auto`;
          
          console.log(`Historical API URL for ${year}:`, apiUrl);
          
          threeYearsData.push(fetch(apiUrl).then(response => {
            if (!response.ok) {
              throw new Error(`Weather API error: ${response.status}`);
            }
            return response.json();
          }));
        }
        
        // Wait for all three requests to complete
        const results = await Promise.all(threeYearsData);
        console.log('Historical data for 3 years:', results);
        
        // Process the data to create a forecast based on recent years' highs
        return processRecentYearsData(results, targetDate);
        
      } catch (error) {
        console.error('Error fetching historical weather data:', error);
        throw new Error('Unable to fetch recent years weather data. Please try again later.');
      }
    }
    
    // Process data from recent years to create a useful cycling forecast
    function processRecentYearsData(dataArray, targetDate) {
      try {
        // Collect all the max temperatures from the 3 years
        const allMaxTemps = [];
        const allPrecipitation = [];
        const allWindSpeeds = [];
        
        // Collect data from all three years
        dataArray.forEach((yearData, yearIndex) => {
          if (!yearData.daily || !yearData.daily.temperature_2m_max) {
            console.error(`Invalid data for year ${2021 + yearIndex}:`, yearData);
            return; // Skip this year
          }
          
          // Add this year's data to our collections
          yearData.daily.temperature_2m_max.forEach(temp => allMaxTemps.push(temp));
          
          if (yearData.daily.precipitation_sum) {
            yearData.daily.precipitation_sum.forEach(precip => allPrecipitation.push(precip));
          }
          
          if (yearData.daily.windspeed_10m_max) {
            yearData.daily.windspeed_10m_max.forEach(wind => allWindSpeeds.push(wind));
          }
        });
        
        console.log('All collected max temperatures:', allMaxTemps);
        
        // Calculate the average high temperature (what cyclists will experience)
        const avgDaytimeTemp = allMaxTemps.length > 0 
          ? allMaxTemps.reduce((sum, temp) => sum + temp, 0) / allMaxTemps.length 
          : 20; // Fallback value if no data
        
        // Average precipitation and wind
        const avgPrecipitation = allPrecipitation.length > 0
          ? allPrecipitation.reduce((sum, val) => sum + val, 0) / allPrecipitation.length
          : 0;
          
        const avgWindSpeed = allWindSpeeds.length > 0
          ? allWindSpeeds.reduce((sum, val) => sum + val, 0) / allWindSpeeds.length
          : 10;
        
        console.log(`Recent years data: Avg high temp=${avgDaytimeTemp}°C, Precipitation=${avgPrecipitation}mm, Wind=${avgWindSpeed}km/h`);
        
        // For min temps, we'll use a reasonable offset from max (not that relevant for daytime cycling)
        const estimatedMinTemp = Math.max(5, avgDaytimeTemp - 8);
        
        // Generate 3-day forecast around the target date (all showing the same average data)
        const forecast = [];
        for (let i = -1; i <= 1; i++) {
          const forecastDate = new Date(targetDate);
          forecastDate.setDate(forecastDate.getDate() + i);
          
          // Determine weather icon based on precipitation
          let icon, description;
          if (avgPrecipitation > 5) {
            icon = 'cloud-rain';
            description = 'Occasional rain (based on 2021-2023)';
          } else if (avgPrecipitation > 1) {
            icon = 'cloud-sun-rain';
            description = 'Light showers possible (based on 2021-2023)';
          } else {
            icon = 'sun';
            description = 'Typically sunny (based on 2021-2023)';
          }
          
          // Calculate precipitation probability based on historical data
          const chanceOfRain = avgPrecipitation > 0 ? Math.min(90, Math.round(avgPrecipitation * 15)) : 10;
          
          forecast.push({
            date: forecastDate,
            temp: Math.round(avgDaytimeTemp), // Use daytime temperature as main temp
            tempMax: Math.round(avgDaytimeTemp),
            tempMin: Math.round(estimatedMinTemp),
            icon: icon,
            description: description,
            windSpeed: Math.round(avgWindSpeed),
            chanceOfRain: chanceOfRain,
            isHistorical: true
          });
        }
        
        return {
          forecast: forecast,
          isHistorical: true,
          alert: {
            type: 'info',
            message: 'Showing typical daytime temperatures from 2021-2023. Actual conditions will vary.'
          }
        };
      } catch (error) {
        console.error('Error processing historical data:', error);
        throw new Error('Could not process historical weather data');
      }
    }
  </script>
</body>
</html>
