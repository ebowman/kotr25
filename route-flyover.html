<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>King of the Road 2025 - Route Flyover</title>
  <link rel="stylesheet" href="https://unpkg.com/mapbox-gl@2.15.0/dist/mapbox-gl.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />
  <script src="https://unpkg.com/mapbox-gl@2.15.0/dist/mapbox-gl.js"></script>
  <script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>
  <script src="https://unpkg.com/axios/dist/axios.min.js"></script>
  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      background: #f9f9f9;
      color: #333;
    }
    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
      display: flex;
      flex-wrap: wrap;
      gap: 20px;
    }
    h1 {
      width: 100%;
      text-align: center;
      margin-bottom: 10px;
      color: #222;
    }
    #map {
      flex: 1;
      min-width: 700px;
      height: 600px;
      border-radius: 8px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.05);
    }
    .controls {
      width: 280px;
      padding: 15px;
      background: white;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.05);
      display: flex;
      flex-direction: column;
      gap: 20px;
    }
    select, button {
      padding: 10px 15px;
      border-radius: 5px;
      border: 1px solid #ddd;
      background: white;
      font-size: 14px;
      width: 100%;
    }
    button {
      background: linear-gradient(to bottom, #3498db, #2980b9);
      color: white;
      cursor: pointer;
      border: none;
      transition: all 0.2s;
      font-weight: 600;
    }
    button:hover {
      background: linear-gradient(to bottom, #2980b9, #2471a3);
      transform: translateY(-1px);
    }
    button:disabled {
      background: #ccc;
      cursor: not-allowed;
    }
    label {
      font-weight: 600;
      margin-bottom: 5px;
      display: block;
      color: #444;
    }
    .control-group {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .route-info {
      background: white;
      border-radius: 8px;
      padding: 15px;
      margin-top: 20px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    }
    .info-grid {
      display: flex;
      justify-content: space-between;
      flex-wrap: nowrap;
      gap: 15px;
      margin-top: 10px;
    }
    .info-item {
      flex: 1;
      text-align: center;
      padding: 12px;
      background: #f5f9ff;
      border-radius: 5px;
    }
    .info-label {
      font-size: 12px;
      color: #666;
      margin-bottom: 5px;
    }
    .info-value {
      font-size: 20px;
      font-weight: 600;
      color: #2c3e50;
    }
    .elevation-profile {
      width: 100%;
      height: 120px;
      background: white;
      margin-top: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.05);
      position: relative;
    }
    #elevation-canvas {
      width: 100%;
      height: 100%;
      border-radius: 8px;
    }
    .elevation-marker {
      position: absolute;
      top: 0;
      width: 2px;
      height: 120px;
      background: red;
      z-index: 10;
      pointer-events: none;
    }
    .loading {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(255,255,255,0.8);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }
    .loading-spinner {
      border: 5px solid #f3f3f3;
      border-top: 5px solid #3498db;
      border-radius: 50%;
      width: 50px;
      height: 50px;
      animation: spin 1s linear infinite;
      margin-bottom: 15px;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    .slider-container {
      margin-top: 5px;
    }
    .range-labels {
      display: flex;
      justify-content: space-between;
      font-size: 12px;
      color: #666;
      margin-top: 5px;
    }
    input[type="range"] {
      width: 100%;
      margin: 0;
      -webkit-appearance: none;
      appearance: none;
      height: 6px;
      background: #e0e0e0;
      border-radius: 3px;
      outline: none;
    }
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: #3498db;
      cursor: pointer;
      border: 2px solid white;
      box-shadow: 0 1px 3px rgba(0,0,0,0.2);
    }
    input[type="range"]::-moz-range-thumb {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: #3498db;
      cursor: pointer;
      border: 2px solid white;
      box-shadow: 0 1px 3px rgba(0,0,0,0.2);
    }
  </style>
</head>
<body>
  <div class="container">
    <div style="display: flex; justify-content: space-between; align-items: center; width: 100%; margin-bottom: 10px;">
      <a href="index.html" style="text-decoration: none; color: #3498db; display: flex; align-items: center;">
        <i class="fas fa-arrow-left" style="margin-right: 5px;"></i> Back to routes
      </a>
    </div>
    <h1>King of the Road 2025 - 3D Route Flyover</h1>
    
    <div class="controls">
      <div class="control-group">
        <label for="route-select">Select Route:</label>
        <select id="route-select">
          <option value="D0_Warm-up.gpx">Day 0 - Warm-up</option>
          <option value="D1_East Short.gpx">Day 1 - East (Short)</option>
          <option value="D1_East_Long.gpx">Day 1 - East (Long)</option>
          <option value="D2_North_Short.gpx">Day 2 - North (Short)</option>
          <option value="D2_North_Long.gpx">Day 2 - North (Long)</option>
          <option value="D3_West_Short.gpx">Day 3 - West (Short)</option>
          <option value="D3_West_Long.gpx">Day 3 - West (Long)</option>
        </select>
      </div>
      
      <div class="control-group">
        <label for="camera-height">Zoom:</label>
        <div class="slider-container">
          <input type="range" id="camera-height" min="1" max="100" step="1" value="25">
          <div class="range-labels">
            <span>In</span>
            <span>Out</span>
          </div>
        </div>
      </div>
      
      <div class="control-group">
        <label for="camera-angle">View Angle:</label>
        <div class="slider-container">
          <input type="range" id="camera-angle" min="10" max="85" step="1" value="45">
          <div class="range-labels">
            <span>Low</span>
            <span>High</span>
          </div>
        </div>
      </div>
      
      <div class="control-group">
        <label for="speed-control">Animation Speed:</label>
        <div class="slider-container">
          <input type="range" id="speed-control" min="0.1" max="5" step="0.1" value="0.5">
          <div class="range-labels">
            <span>Slow</span>
            <span>Fast</span>
          </div>
        </div>
      </div>
      
      <div class="control-group">
        <label for="position-slider">Position:</label>
        <div class="slider-container">
          <input type="range" id="position-slider" min="0" max="100" step="0.1" value="0">
          <div class="range-labels">
            <span>Start</span>
            <span>End</span>
          </div>
        </div>
      </div>
      
      <div class="control-group" style="margin-top: 10px;">
        <button id="toggle-btn">Start</button>
        <button id="reset-btn" disabled>Reset</button>
      </div>
    </div>
    
    <div id="map"></div>
    
    <div class="elevation-profile">
      <canvas id="elevation-canvas"></canvas>
      <div class="elevation-marker" id="elevation-marker" style="display: none;"></div>
    </div>
    
    <div class="route-info">
      <div class="info-header">
        <h3>Route Information</h3>
      </div>
      <div class="info-grid">
        <div class="info-item">
          <div class="info-label">Total Distance</div>
          <div class="info-value" id="total-distance">--</div>
        </div>
        <div class="info-item">
          <div class="info-label">Distance Traveled</div>
          <div class="info-value" id="distance-traveled">0.0 km</div>
        </div>
        <div class="info-item">
          <div class="info-label">Elevation Gain</div>
          <div class="info-value" id="elevation-gain">--</div>
        </div>
        <div class="info-item">
          <div class="info-label">Current Elevation</div>
          <div class="info-value" id="current-elevation">--</div>
        </div>
        <div class="info-item">
          <div class="info-label">Current Gradient</div>
          <div class="info-value" id="current-gradient">--</div>
        </div>
        <div class="info-item">
          <div class="info-label">Progress</div>
          <div class="info-value" id="progress">0%</div>
        </div>
      </div>
    </div>
  </div>
  
  <div class="loading" id="loading">
    <div class="loading-spinner"></div>
    <p>Loading route data...</p>
  </div>
  
  <script>
    // Replace with your Mapbox access token
    mapboxgl.accessToken = 'pk.eyJ1IjoiZWJvd21hbiIsImEiOiJjbWE1ZWVwdzYwODhwMmlzZnU4NTlyem1rIn0.E10X5hj2NTgViJexKpvrOg';
    
    // Global variables
    let map;
    let routeData = null;
    let animationId = null;
    let currentPoint = 0;
    let elevationProfile = [];
    let maxElevation = 0;
    let minElevation = Infinity;
    let totalDistance = 0;
    let elevationGain = 0;
    let routeCoordinates = [];
    let smoothedRouteCoordinates = []; // Smoothed version of coordinates for camera movement when zoomed out
    let routeDistances = []; // Array to store cumulative distances along route
    let smoothedRouteDistances = []; // Array to store distances for smoothed route
    let animationSpeed = 0.5;
    let cameraHeight = 25; // Default camera height (slider position, not actual meters)
    let cameraAngle = 25; // Default camera angle (pitch) in degrees (inverted from slider value of 45)
    let currentRouteDistance = 0; // Current distance along route in meters
    let totalDistanceMeters = 0; // Total distance of the route in meters
    let dt = 1/60; // Physics timestep in seconds (60fps)
    
    // Camera state variables - simplified
    let cameraPos = { x: 0, y: 0, z: 0 }; // Current position
    let cameraFOV = 60; // Current field of view
    let lastFrameTime = performance.now(); // For deltaTime calculation
    let currentBearing = 0; // Current smoothed bearing for gradual direction changes
    let cameraVelocity = { bearing: 0, speed: 0 }; // Camera movement velocity for momentum
    let currentWaypoint = null; // Current target waypoint camera is flying toward
    let waypointUpdateTimer = 0; // Timer to update waypoint occasionally
    
    // Simplified camera parameters for smooth motion
    let lookAheadFactor = 0.05;  // Much less aggressive look-ahead
    let minLook = 2;  // Minimum look-ahead distance
    let maxLook = 20;  // Reduced maximum look-ahead for stability
    let verticalOffset = 5;  // Minimal vertical offset
    let baseZoom = 50;  // Default FOV
    let zoomMax = 75;  // Maximum FOV
    
    // Smoothing parameters
    let positionSmoothing = 0.08;  // Base position smoothing factor
    let zoomSmoothing = 0.12;      // Zoom smoothing factor
    let bearingSmoothing = 0.15;   // Bearing smoothing factor for camera direction
    
    // Simplified zoom control
    let zoomGoal = baseZoom;
    
    // Helper function to smooth bearing changes with proper angle wraparound
    function smoothBearing(currentBearing, targetBearing, smoothingFactor, deltaTime) {
      // Normalize angles to 0-360 range
      const normalizeBearing = (angle) => ((angle % 360) + 360) % 360;
      
      const current = normalizeBearing(currentBearing);
      const target = normalizeBearing(targetBearing);
      
      // Calculate the shortest angular distance
      let diff = target - current;
      if (diff > 180) diff -= 360;
      if (diff < -180) diff += 360;
      
      // Apply frame-rate independent smoothing
      const frameRateAdjustment = Math.min(1, deltaTime * 60);
      const actualSmoothingFactor = 1 - Math.pow(1 - smoothingFactor, frameRateAdjustment);
      
      // Calculate new bearing
      const newBearing = current + (diff * actualSmoothingFactor);
      
      return normalizeBearing(newBearing);
    }
    
    // Create multiple levels of route smoothing for dynamic camera behavior
    function createSmoothedRoute(coordinates) {
      // Skip if too few points
      if (coordinates.length <= 10) return [...coordinates];
      
      // Create multiple smoothed versions for different zoom levels
      return createTrulySmoothedRoute(coordinates);
    }
    
    function createTrulySmoothedRoute(coordinates) {
      // Create TRULY smooth curves using large moving averages
      // This creates flowing, cinematic paths perfect for zoomed-out views
      const routeLength = coordinates.length;
      const smoothed = [];
      
      // Large smoothing window for silky smooth curves - ignores minor deviations
      const smoothingWindow = Math.max(20, Math.floor(routeLength / 50)); // Much larger window
      
      // Process every point with heavy smoothing
      for (let i = 0; i < routeLength; i++) {
        let sumLng = 0;
        let sumLat = 0;
        let sumEle = 0;
        let count = 0;
        
        // Large moving average window
        const start = Math.max(0, i - smoothingWindow);
        const end = Math.min(routeLength - 1, i + smoothingWindow);
        
        for (let j = start; j <= end; j++) {
          sumLng += coordinates[j][0];
          sumLat += coordinates[j][1];
          if (coordinates[j].length > 2) {
            sumEle += coordinates[j][2];
          }
          count++;
        }
        
        // Create smoothed point
        const smoothPoint = [
          sumLng / count,
          sumLat / count
        ];
        
        if (coordinates[i].length > 2) {
          smoothPoint.push(sumEle / count);
        }
        
        smoothed.push(smoothPoint);
      }
      
      console.log(`Route smoothed from ${routeLength} to ${smoothed.length} points with TRUE curve smoothing`);
      return smoothed;
    }
    
    // Helper function to efficiently calculate segment data for any distance
    // Uses binary search for much faster lookups, important for smooth animation
    function calculateSegmentForDistance(distanceKm, useSmoothedRoute = false) {
      // Dynamically determine whether to use smoothed route based on zoom level
      // When zoomed out (high FOV), use smoothed route; when zoomed in, use regular route
      let shouldUseSmoothedRoute = useSmoothedRoute;
      
      // Allow dynamic route selection based on camera height/zoom during animation
      if (!useSmoothedRoute) {
        const heightControl = document.getElementById('camera-height');
        if (heightControl) {
          // Get height value (1-100); higher values = more zoomed out
          const zoomOutAmount = parseInt(heightControl.value);
          
          // Use smoothed route when zoomed out beyond a threshold (>50 = zoomed out)
          // For values higher than 50, start blending in the smoothed route
          shouldUseSmoothedRoute = zoomOutAmount > 50;
        }
      }
      
      // Choose which route coordinates and distances to use based on zoom level
      const distances = shouldUseSmoothedRoute ? smoothedRouteDistances : routeDistances;
      
      // Safety check to ensure we have valid distances
      if (!distances || distances.length < 2) {
        console.warn('Invalid distances array for route lookup');
        return { beforeIdx: 0, afterIdx: 1, fraction: 0 };
      }
      
      let beforeIdx = 0;
      let afterIdx = 1;
      let fraction = 0;
      
      // Handle edge cases for start and end of route
      if (distanceKm <= distances[0]) {
        return { 
          beforeIdx: 0, 
          afterIdx: 1, 
          fraction: 0,
          useSmoothedRoute: shouldUseSmoothedRoute 
        };
      }
      
      if (distanceKm >= distances[distances.length - 1]) {
        return { 
          beforeIdx: distances.length - 2,
          afterIdx: distances.length - 1,
          fraction: 1,
          useSmoothedRoute: shouldUseSmoothedRoute
        };
      }
      
      // Binary search to find the closest segment for the given distance
      // This is much more efficient than linear search for long routes
      let start = 0, end = distances.length - 1;
      
      while (start <= end) {
        const mid = Math.floor((start + end) / 2);
        
        if (mid + 1 < distances.length && // Safety check for array bounds
            distances[mid] <= distanceKm && distances[mid + 1] >= distanceKm) {
          beforeIdx = mid;
          afterIdx = mid + 1;
          break;
        } else if (distances[mid] < distanceKm) {
          start = mid + 1;
        } else {
          end = mid - 1;
        }
      }
      
      // Final safety check for valid indices
      if (afterIdx >= distances.length) {
        afterIdx = distances.length - 1;
        beforeIdx = Math.max(0, afterIdx - 1);
      }
      
      // Calculate the interpolation fraction
      const segmentLength = distances[afterIdx] - distances[beforeIdx];
      fraction = segmentLength > 0 ? 
        (distanceKm - distances[beforeIdx]) / segmentLength : 0;
      
      // Ensure fraction is always valid (0-1)
      fraction = Math.max(0, Math.min(1, fraction));
      
      // Debug interpolation occasionally
      if (Math.random() < 0.005) { // Log very occasionally
        console.log(`Segment ${beforeIdx}-${afterIdx}: length=${(segmentLength*1000).toFixed(1)}m, fraction=${fraction.toFixed(3)}`);
      }
      
      return { 
        beforeIdx, 
        afterIdx, 
        fraction,
        useSmoothedRoute: shouldUseSmoothedRoute
      };
    }

    // Calculate bearing between two coordinates
    function calculateBearing(start, end) {
      // Safety check for invalid coordinates
      if (!start || !end || !Array.isArray(start) || !Array.isArray(end) || 
          start.length < 2 || end.length < 2) {
        console.warn('Invalid coordinates for bearing calculation:', start, end);
        return 0; // Default bearing
      }
      
      try {
        const startLat = start[1] * Math.PI / 180;
        const startLng = start[0] * Math.PI / 180;
        const endLat = end[1] * Math.PI / 180;
        const endLng = end[0] * Math.PI / 180;
        
        const y = Math.sin(endLng - startLng) * Math.cos(endLat);
        const x = Math.cos(startLat) * Math.sin(endLat) - 
                  Math.sin(startLat) * Math.cos(endLat) * Math.cos(endLng - startLng);
        
        const bearing = Math.atan2(y, x) * 180 / Math.PI;
        return (bearing + 360) % 360;
      } catch (e) {
        console.warn('Error calculating bearing:', e);
        return 0; // Default bearing on error
      }
    }
    
    // Update point position
    function updatePointPosition(coord) {
      // Safety check to prevent errors
      if (!coord || !Array.isArray(coord) || coord.length < 2) {
        console.warn('Invalid coordinate passed to updatePointPosition:', coord);
        return;
      }
      
      // Create a GeoJSON point
      const point = {
        type: 'Feature',
        properties: {},
        geometry: {
          type: 'Point',
          coordinates: [coord[0], coord[1]]
        }
      };
      
      // Update the point source if it exists
      if (map && map.getSource('point')) {
        try {
          map.getSource('point').setData(point);
        } catch (e) {
          console.warn('Error updating point position:', e);
        }
      }
    }
    
    // TARGET-POINT MODULE: Calculate where camera position should be
    function calculateTargetPoint(bikerPos, bikerVel) {
      // Safety checks for NaN values
      if (isNaN(bikerPos.x) || isNaN(bikerPos.y) || isNaN(bikerPos.z)) {
        console.warn('NaN values detected in biker position');
        return {
          x: bikerPos.x || 0,
          y: bikerPos.y || 0,
          z: (bikerPos.z || 0) + verticalOffset
        };
      }
      
      // Get current zoom level
      const heightControl = document.getElementById('camera-height');
      const zoomOutAmount = heightControl ? parseInt(heightControl.value) : 50;
      const currentZoomFactor = Math.max(0, Math.min(1, zoomOutAmount / 100));
      
      // Calculate how far ahead on the route to position the camera
      // Use altitude-based look-ahead like the bearing calculation
      const currentDistanceKm = currentRouteDistance / 1000;
      const altitudeFactor = Math.max(0.1, Math.min(1.0, (cameraFOV - baseZoom) / (zoomMax - baseZoom)));
      const lookAheadDistance = currentDistanceKm + (0.05 + altitudeFactor * 0.3); // 0.05-0.35km based on altitude
      
      const clampedLookAheadDistance = Math.min(lookAheadDistance, routeDistances[routeDistances.length - 1]);
      
      // Find the point on the route at this distance
      const lookAheadSegment = calculateSegmentForDistance(clampedLookAheadDistance, false); // Use actual route
      const lookAheadCoords = routeCoordinates;
      
      if (lookAheadSegment && lookAheadCoords[lookAheadSegment.afterIdx]) {
        const beforePoint = lookAheadCoords[lookAheadSegment.beforeIdx];
        const afterPoint = lookAheadCoords[lookAheadSegment.afterIdx];
        const fraction = lookAheadSegment.fraction;
        
        // Interpolate the look-ahead point on the route
        let targetX = beforePoint[0] + (afterPoint[0] - beforePoint[0]) * fraction;
        let targetY = beforePoint[1] + (afterPoint[1] - beforePoint[1]) * fraction;
        const targetZ = (beforePoint[2] || 0) + ((afterPoint[2] || 0) - (beforePoint[2] || 0)) * fraction + verticalOffset;
        
        // CRITICAL: Adjust camera position to keep biker centered in viewport
        // Calculate direction from camera to biker
        const cameraToBikerX = bikerPos.x - targetX;
        const cameraToBikerY = bikerPos.y - targetY;
        const distanceToBiker = Math.sqrt(cameraToBikerX * cameraToBikerX + cameraToBikerY * cameraToBikerY);
        
        if (distanceToBiker > 0.0001) { // Avoid division by zero
          // STRONGER BIKER CENTERING: Calculate viewport constraints
          // Ensure biker stays within central 70% of viewport
          const maxOffsetFromCenter = 0.35; // 35% of viewport radius
          const viewportRadius = currentZoomFactor > 0.5 ? 
            0.001 + currentZoomFactor * 0.003 : // Larger viewport when zoomed out
            0.0005 + currentZoomFactor * 0.001; // Smaller when zoomed in
          
          const maxAllowedDistance = viewportRadius * maxOffsetFromCenter;
          
          if (distanceToBiker > maxAllowedDistance) {
            // FORCE camera closer to keep biker in safe zone
            const correctionFactor = maxAllowedDistance / distanceToBiker;
            targetX = bikerPos.x - (cameraToBikerX * correctionFactor);
            targetY = bikerPos.y - (cameraToBikerY * correctionFactor);
          } else {
            // Normal positioning with gentler adjustment
            const desiredDistance = viewportRadius * 0.2; // Keep biker 20% from center
            const scaleFactor = Math.min(1.0, desiredDistance / distanceToBiker);
            targetX = bikerPos.x - (cameraToBikerX * scaleFactor);
            targetY = bikerPos.y - (cameraToBikerY * scaleFactor);
          }
        }
        
        return { x: targetX, y: targetY, z: targetZ };
      }
      
      // Fallback to biker position
      return {
        x: bikerPos.x,
        y: bikerPos.y,
        z: bikerPos.z + verticalOffset
      };
    }
    
    // FRAMING CONTROLLER: Simplified - just maintain base zoom
    function framingController(bikerScreenPos) {
      // Keep zoom at base level - manual controls will override if needed
      zoomGoal = baseZoom;
    }
    
    // CAMERA SOLVER: Simple exponential smoothing for silky smooth movement
    function updateCameraPhysics(targetPos, targetFOV, deltaTime, useSmoothedForCamera = false, bearing = 0) {
      // Get current manual zoom setting
      const heightControl = document.getElementById('camera-height');
      let desiredFOV = targetFOV;
      
      if (heightControl) {
        const heightValue = parseInt(heightControl.value);
        const heightRatio = heightValue / 100;
        desiredFOV = baseZoom + ((zoomMax - baseZoom) * heightRatio);
      }
      
      // Apply safety limits to FOV
      desiredFOV = Math.max(baseZoom, Math.min(zoomMax, desiredFOV));
      
      // Calculate zoom alpha (0: zoomed in, 1: zoomed out) for adaptive smoothing
      const zoomAlpha = Math.max(0, Math.min(1, (cameraFOV - baseZoom) / (zoomMax - baseZoom)));
      
      // Adaptive smoothing: faster when zoomed in, slower when zoomed out
      // Also more aggressive smoothing when using smoothed routes for camera targeting
      const baseAdaptiveSmoothing = positionSmoothing + (0.15 * (1 - zoomAlpha));
      const adaptivePositionSmoothing = useSmoothedForCamera ? 
        baseAdaptiveSmoothing * 0.7 : // Even smoother when following smoothed route
        baseAdaptiveSmoothing;
      
      // Simple exponential smoothing for position - frame rate independent
      const frameRateAdjustment = Math.min(1, deltaTime * 60); // Normalize to 60fps
      const actualPositionSmoothing = 1 - Math.pow(1 - adaptivePositionSmoothing, frameRateAdjustment);
      
      cameraPos.x += (targetPos.x - cameraPos.x) * actualPositionSmoothing;
      cameraPos.y += (targetPos.y - cameraPos.y) * actualPositionSmoothing;
      cameraPos.z += (targetPos.z - cameraPos.z) * actualPositionSmoothing;
      
      // Simple exponential smoothing for FOV
      const actualZoomSmoothing = 1 - Math.pow(1 - zoomSmoothing, frameRateAdjustment);
      cameraFOV += (desiredFOV - cameraFOV) * actualZoomSmoothing;
      
      // Apply safety limits to FOV
      cameraFOV = Math.max(baseZoom, Math.min(zoomMax, cameraFOV));
      
      // Use the bearing passed in from the animation loop (don't recalculate!)
      // This bearing has already been smoothed and calculated with inertia
      
      // FOV was already updated earlier in the function
      
      // Improved conversion from FOV to mapbox zoom level
      // With our new settings (FOV 50-70)
      // FOV 50 -> zoom 18, FOV 70 -> zoom 14
      const zoom = 22 - ((cameraFOV - 40) / 5);
      
      // Convert to map coordinates
      return {
        center: [cameraPos.x, cameraPos.y],
        bearing: bearing,
        pitch: cameraAngle,
        zoom: zoom
      };
    }
    
    // Get biker position on screen
    function getBikerScreenPosition() {
      // Safety check
      if (!map || !map.getSource('point')) return null;
      
      try {
        // Get the rider's current position
        const pointSource = map.getSource('point');
        if (!pointSource || !pointSource._data) return null;
        
        const pointFeature = pointSource._data;
        if (!pointFeature || !pointFeature.geometry || !pointFeature.geometry.coordinates) return null;
      
        const riderCoords = pointFeature.geometry.coordinates;
        
        // Convert rider coordinates to screen coordinates
        return map.project(riderCoords);
      } catch (e) {
        console.warn('Error getting rider screen position:', e);
        return null;
      }
    }
    
    // Clean, optimized animation function that implements the architecture from CAMERA.md
    // Enhanced to handle dynamic route smoothing based on zoom level
    function animateRoute(currentTime = performance.now()) {
      // Calculate deltaTime for frame-rate independent animation
      let deltaTime = (currentTime - lastFrameTime) / 1000; // Convert to seconds
      lastFrameTime = currentTime;
      
      // Cap deltaTime to prevent large jumps (e.g., when tab was in background)
      deltaTime = Math.min(deltaTime, 1/30); // Max 33ms frame time for smooth movement
      
      // Safety check to avoid errors if route data isn't loaded
      if (!routeCoordinates || routeCoordinates.length === 0 || !routeDistances || routeDistances.length === 0) {
        pauseAnimation();
        console.warn('No route coordinates available for animation');
        return;
      }
      
      // Check if we've reached the end of the route
      if (currentRouteDistance >= routeDistances[routeDistances.length - 1] * 1000) { // Convert km to m
        pauseAnimation();
        // Reset button text to "Start" when animation completes
        const toggleBtn = document.getElementById('toggle-btn');
        if (toggleBtn) toggleBtn.textContent = "Start";
        
        // Ensure map interactions are re-enabled at the end of animation
        map.dragPan.enable();
        map.scrollZoom.enable();
        map.doubleClickZoom.enable();
        map.touchZoomRotate.enable();
        
        // Enable position slider
        const positionSlider = document.getElementById('position-slider');
        if (positionSlider) positionSlider.disabled = false;
        
        return;
      }
      
      // Frame-rate independent speed calculation  
      // Realistic cycling speed: ~15-25 m/s for visualization (54-90 km/h)
      const baseSpeedMPS = 20; // meters per second (more realistic for smooth movement)
      const distanceIncrement = baseSpeedMPS * animationSpeed * deltaTime;
      
      // Debug speed consistency
      if (Math.random() < 0.01) { // Log occasionally
        console.log(`Speed: ${(baseSpeedMPS * animationSpeed).toFixed(1)} m/s, deltaTime: ${deltaTime.toFixed(3)}s, increment: ${distanceIncrement.toFixed(2)}m`);
      }
      
      // Update current distance along route
      currentRouteDistance += distanceIncrement;
      
      // Convert to km for route lookup
      const currentDistanceKm = currentRouteDistance / 1000;
      
      // Get current zoom level to determine camera behavior
      const heightControl = document.getElementById('camera-height');
      const zoomOutAmount = heightControl ? parseInt(heightControl.value) : 50;
      
      // Calculate zoom factor (0 = zoomed in, 1 = zoomed out)
      const zoomFactor = Math.max(0, Math.min(1, zoomOutAmount / 100));
      
      // Use smoothed route for camera when significantly zoomed out
      const useSmoothedForCamera = zoomFactor > 0.5;
      
      // Get segment for RIDER position - always use raw route for rider
      // This ensures the rider always stays on the actual route
      const riderSegment = calculateSegmentForDistance(currentDistanceKm, false);
      const riderBeforeIdx = riderSegment.beforeIdx;
      const riderAfterIdx = riderSegment.afterIdx;
      const riderFraction = riderSegment.fraction;
      
      // Get the points for rider interpolation from raw route
      const riderBeforePoint = routeCoordinates[riderBeforeIdx];
      const riderAfterPoint = routeCoordinates[riderAfterIdx];
      
      // Create interpolated point for the rider position
      const interpolatedPoint = [
        riderBeforePoint[0] + (riderAfterPoint[0] - riderBeforePoint[0]) * riderFraction,
        riderBeforePoint[1] + (riderAfterPoint[1] - riderBeforePoint[1]) * riderFraction
      ];
      
      // Include elevation if available
      if (riderBeforePoint.length > 2 && riderAfterPoint.length > 2) {
        interpolatedPoint[2] = riderBeforePoint[2] + (riderAfterPoint[2] - riderBeforePoint[2]) * riderFraction;
      } else {
        interpolatedPoint[2] = 0;
      }
      
      // Debug position calculation occasionally
      if (Math.random() < 0.005) { // Log very occasionally
        const usedDistances = riderSegment.useSmoothedRoute ? smoothedRouteDistances : routeDistances;
        const routeSegmentDistance = (usedDistances[riderAfterIdx] - usedDistances[riderBeforeIdx]) * 1000; // km to m
        const expectedPosition = usedDistances[riderBeforeIdx] + (riderFraction * (usedDistances[riderAfterIdx] - usedDistances[riderBeforeIdx]));
        const actualPosition = currentRouteDistance / 1000; // m to km
        console.log(`Position: segment ${riderBeforeIdx}-${riderAfterIdx}, fraction=${riderFraction.toFixed(3)}, route segment=${routeSegmentDistance.toFixed(1)}m, expected=${expectedPosition.toFixed(3)}km, actual=${actualPosition.toFixed(3)}km`);
      }
      
      // Update the rider marker position
      updatePointPosition(interpolatedPoint);
      
      // Update tracking information for UI display
      currentPoint = riderBeforeIdx;
      currentPointFloat = riderBeforeIdx + riderFraction;
      
      // Get camera targeting points - use smoothed route when zoomed out for smooth camera movement
      let cameraCoords, cameraSegment, cameraBeforePoint, cameraAfterPoint, nextCameraPoint;
      
      if (useSmoothedForCamera && smoothedRouteCoordinates.length > 0) {
        // Use smoothed route for camera targeting when zoomed out
        cameraSegment = calculateSegmentForDistance(currentDistanceKm, true);
        cameraCoords = smoothedRouteCoordinates;
        cameraBeforePoint = cameraCoords[cameraSegment.beforeIdx];
        cameraAfterPoint = cameraCoords[cameraSegment.afterIdx];
        const lookAheadIdx = Math.min(cameraSegment.afterIdx + 1, cameraCoords.length - 1);
        nextCameraPoint = cameraCoords[lookAheadIdx];
      } else {
        // Use actual route for camera targeting when zoomed in
        cameraSegment = riderSegment;
        cameraCoords = routeCoordinates;
        cameraBeforePoint = riderBeforePoint;
        cameraAfterPoint = riderAfterPoint;
        const lookAheadIdx = Math.min(riderAfterIdx + 1, routeCoordinates.length - 1);
        nextCameraPoint = routeCoordinates[lookAheadIdx];
      }
      
      // FORWARD-LOOKING CAMERA: Look ahead on route, not back at biker
      
      // Calculate where biker will be further ahead on the route
      // Look-ahead distance based on camera altitude (like real helicopter pilot)
      const altitudeFactor = Math.max(0.1, Math.min(1.0, (cameraFOV - baseZoom) / (zoomMax - baseZoom)));
      const forwardLookDistance = currentDistanceKm + (0.1 + altitudeFactor * 1.0); // 0.1-1.1km based on altitude
        
      const clampedForwardDistance = Math.min(forwardLookDistance, routeDistances[routeDistances.length - 1]);
      
      // Get the forward point on the route
      const forwardSegment = calculateSegmentForDistance(clampedForwardDistance, false);
      const forwardCoords = routeCoordinates;
      
      let targetBearing = currentBearing; // Default: keep current direction
      
      if (forwardSegment && forwardCoords[forwardSegment.afterIdx]) {
        const beforePoint = forwardCoords[forwardSegment.beforeIdx];
        const afterPoint = forwardCoords[forwardSegment.afterIdx];
        const fraction = forwardSegment.fraction;
        
        // Interpolate the forward point
        const forwardX = beforePoint[0] + (afterPoint[0] - beforePoint[0]) * fraction;
        const forwardY = beforePoint[1] + (afterPoint[1] - beforePoint[1]) * fraction;
        
        // Calculate bearing toward this forward point (where biker is going)
        targetBearing = calculateBearing([cameraPos.x, cameraPos.y], [forwardX, forwardY]);
      }
      
      
      if (zoomFactor > 0.5) {
        // ZOOMED OUT: Camera has strong inertia and barely responds
        const bearingError = ((targetBearing - currentBearing + 540) % 360) - 180;
        
        // Only make tiny corrections if significantly off-course
        let correction = 0;
        if (Math.abs(bearingError) > 15) {
          correction = Math.sign(bearingError) * 0.05; // Fixed 0.05 degree correction
        }
        
        // Apply correction with massive momentum
        cameraVelocity.bearing = cameraVelocity.bearing * 0.999 + correction * 0.001;
        cameraVelocity.bearing = Math.max(-0.1, Math.min(0.1, cameraVelocity.bearing));
        
      } else {
        // ZOOMED IN: More responsive tracking
        const bearingError = ((targetBearing - currentBearing + 540) % 360) - 180;
        const correction = bearingError * 0.01;
        cameraVelocity.bearing = cameraVelocity.bearing * 0.9 + correction * 0.1;
        cameraVelocity.bearing = Math.max(-2.0, Math.min(2.0, cameraVelocity.bearing));
      }
      
      // Apply velocity to bearing
      currentBearing = currentBearing + cameraVelocity.bearing;
      const bearing = currentBearing;
      
      // ===== CAMERA SYSTEM ARCHITECTURE PER CAMERA.md =====
      
      // 1. BIKER STATE - always use actual rider position
      const bikerPos = {
        x: interpolatedPoint[0],
        y: interpolatedPoint[1],
        z: interpolatedPoint[2]
      };
      
      
      // Calculate velocity using camera targeting points for smooth movement
      let bikerVel;
      // Safety check for valid points
      if (!nextCameraPoint || !Array.isArray(nextCameraPoint) || nextCameraPoint.length < 2 || 
          !cameraAfterPoint || !Array.isArray(cameraAfterPoint) || cameraAfterPoint.length < 2) {
        console.warn('Invalid points for velocity calculation');
        // Provide a safe default velocity
        bikerVel = { x: 0, y: 0, z: 0 };
      } else {
        // Calculate raw velocity
        let dx = nextCameraPoint[0] - cameraAfterPoint[0];
        let dy = nextCameraPoint[1] - cameraAfterPoint[1];
        let dz = (nextCameraPoint.length > 2 && cameraAfterPoint.length > 2) ? 
                  (nextCameraPoint[2] - cameraAfterPoint[2]) : 0;
        
        // Apply additional real-time smoothing when zoomed out for ultra-smooth movement
        if (useSmoothedForCamera && zoomFactor > 0.7) {
          // Very heavy smoothing for velocity when significantly zoomed out
          const smoothingFactor = 0.3 * zoomFactor; // More smoothing = smaller changes
          dx *= smoothingFactor;
          dy *= smoothingFactor;
          dz *= smoothingFactor;
        }
        
        // Scale velocity by animation speed, but keep it reasonable
        const scaleFactor = Math.min(5.0, animationSpeed) * 0.0005;
        
        bikerVel = {
          x: dx * scaleFactor,
          y: dy * scaleFactor,
          z: dz * scaleFactor
        };
      }
      
      // 2. TARGET-POINT MODULE
      const targetPoint = calculateTargetPoint(bikerPos, bikerVel);
      
      // 3. FRAMING CONTROLLER
      const bikerScreenPos = getBikerScreenPosition();
      framingController(bikerScreenPos);
      
      // 4. CAMERA SOLVER
      const newCameraState = updateCameraPhysics(targetPoint, zoomGoal, deltaTime, useSmoothedForCamera, bearing);
      
      // Apply the new camera state with smooth transitions
      map.easeTo({
        ...newCameraState,
        duration: 0, // Frame-based animation
        easing: t => t // Linear for smoothest motion
      });
      
      // Update UI elements
      updateProgress();
      
      // Continue animation
      animationId = requestAnimationFrame(animateRoute);
    }
    
    // Helper functions and UI-related code (mostly unchanged)
    
    // Update progress and UI
    function updateProgress() {
      if (routeCoordinates.length === 0 || routeDistances.length === 0) return;
      
      // Calculate progress percentage based on distance
      const totalDistanceMeters = routeDistances[routeDistances.length - 1] * 1000; // km to m
      const progress = currentRouteDistance / totalDistanceMeters;
      
      // Update progress element
      const progressEl = document.getElementById('progress');
      progressEl.textContent = `${Math.round(progress * 100)}%`;
      
      // Update distance traveled
      const distanceTraveledEl = document.getElementById('distance-traveled');
      distanceTraveledEl.textContent = `${(currentRouteDistance / 1000).toFixed(1)} km`;
      
      // Update position slider without triggering its change event
      const positionSlider = document.getElementById('position-slider');
      positionSlider.value = progress * 100;
      
      // Update elevation marker
      updateElevationMarker(progress);
      
      // Get current and next points for interpolation
      const currentIdx = Math.floor(currentPointFloat);
      const nextIdx = Math.min(currentIdx + 1, routeCoordinates.length - 1);
      const pointFraction = currentPointFloat - currentIdx;
      
      // Get interpolated elevation
      let currentElevation;
      if (routeCoordinates[currentIdx].length > 2 && routeCoordinates[nextIdx].length > 2) {
        currentElevation = routeCoordinates[currentIdx][2] + 
                          (routeCoordinates[nextIdx][2] - routeCoordinates[currentIdx][2]) * pointFraction;
      } else {
        currentElevation = routeCoordinates[currentIdx][2] || 0;
      }
      
      const currentElevationEl = document.getElementById('current-elevation');
      currentElevationEl.textContent = `${Math.round(currentElevation)} m`;
      
      // Calculate gradient using about 100m look-behind distance
      // Find a point ~100m back from our current position
      let lookBehindDistance = Math.max(0, currentRouteDistance - 100); // meters
      let lookBehindDistanceKm = lookBehindDistance / 1000;
      let prevPointIdx = 0;
      
      // Find the closest point for our look-behind distance
      for (let i = 0; i < routeDistances.length; i++) {
        if (routeDistances[i] >= lookBehindDistanceKm) {
          prevPointIdx = Math.max(0, i - 1);
          break;
        }
      }
      
      // Calculate the elevation change over this distance
      const prevElevation = routeCoordinates[prevPointIdx][2] || 0;
      const elevationChange = currentElevation - prevElevation;
      
      // Calculate the actual distance between these points
      const actualDistance = (currentRouteDistance - (routeDistances[prevPointIdx] * 1000)); // in meters
      
      const currentGradientEl = document.getElementById('current-gradient');
      if (actualDistance > 10) { // Only calculate gradient if we have sufficient distance
        const gradient = (elevationChange / actualDistance) * 100;
        currentGradientEl.textContent = `${gradient.toFixed(1)}%`;
        
        // Change gradient text color based on steepness
        if (gradient > 8) {
          currentGradientEl.style.color = '#e74c3c'; // Steep - red
        } else if (gradient > 4) {
          currentGradientEl.style.color = '#f39c12'; // Moderate - orange
        } else if (gradient < -4) {
          currentGradientEl.style.color = '#2ecc71'; // Descent - green
        } else {
          currentGradientEl.style.color = '#2c3e50'; // Flat - default
        }
      }
    }
    
    // Update elevation marker on the profile
    function updateElevationMarker(progress) {
      const elevationMarker = document.getElementById('elevation-marker');
      if (!elevationMarker) return;
      
      const elevationProfile = document.querySelector('.elevation-profile');
      if (!elevationProfile) return;
      
      const profileWidth = elevationProfile.offsetWidth;
      const markerPosition = profileWidth * progress;
      
      elevationMarker.style.left = `${markerPosition}px`;
      elevationMarker.style.display = 'block';
    }
    
    // Add terrain and common sources/layers function
    function addTerrainAndSources(exaggerationValue = 1.0) {
      try {
        // Add terrain source if it doesn't exist
        if (!map.getSource('mapbox-dem')) {
          map.addSource('mapbox-dem', {
            'type': 'raster-dem',
            'url': 'mapbox://mapbox.mapbox-terrain-dem-v1',
            'tileSize': 512,
            'maxzoom': 14
          });
        }
        
        // Add sky layer if it doesn't exist
        if (!map.getLayer('sky')) {
          map.addLayer({
            'id': 'sky',
            'type': 'sky',
            'paint': {
              'sky-type': 'atmosphere',
              'sky-atmosphere-sun': [0.0, 0.0],
              'sky-atmosphere-sun-intensity': 15
            }
          });
        }
        
        // Use fixed 1.0 terrain exaggeration - no slider adjustment
        const exaggeration = exaggerationValue;
        
        // Add 3D terrain
        map.setTerrain({ 'source': 'mapbox-dem', 'exaggeration': exaggeration });
        
        // Add route source and layer if needed
        if (!map.getSource('route') && routeCoordinates.length > 0) {
          map.addSource('route', {
            type: 'geojson',
            data: {
              type: 'Feature',
              properties: {},
              geometry: {
                type: 'LineString',
                coordinates: routeCoordinates.map(coord => [coord[0], coord[1]])
              }
            }
          });
          
          map.addLayer({
            id: 'route',
            type: 'line',
            source: 'route',
            layout: {
              'line-join': 'round',
              'line-cap': 'round'
            },
            paint: {
              'line-color': '#3498db',
              'line-width': 5,
              'line-opacity': 0.8
            }
          });
        }
        
        // Add point source and layer if needed
        if (!map.getSource('point') && routeCoordinates.length > 0) {
          map.addSource('point', {
            type: 'geojson',
            data: {
              type: 'Feature',
              properties: {},
              geometry: {
                type: 'Point',
                coordinates: [routeCoordinates[currentPoint][0], routeCoordinates[currentPoint][1]]
              }
            }
          });
          
          map.addLayer({
            id: 'point',
            type: 'circle',
            source: 'point',
            paint: {
              'circle-radius': 8,
              'circle-color': '#e74c3c',
              'circle-stroke-width': 2,
              'circle-stroke-color': '#ffffff'
            }
          });
        }
        
        return true;
      } catch (e) {
        console.warn('Error adding terrain or sources:', e);
        return false;
      }
    }
    
    // Initialize the map
    function initMap() {
      map = new mapboxgl.Map({
        container: 'map',
        style: 'mapbox://styles/mapbox/satellite-streets-v12',
        center: [0, 0], // Will be updated when route is loaded
        zoom: 13,
        pitch: 50,
        bearing: 0,
        antialias: true, // Smoother lines
        attributionControl: false
      });
      
      // Add attribution separately to have more control over its position
      map.addControl(new mapboxgl.AttributionControl({
        compact: true
      }));
      
      // Add navigation controls
      map.addControl(new mapboxgl.NavigationControl(), 'top-right');
      
      // Initialize the camera position and velocity
      map.on('load', () => {
        cameraPos = {
          x: map.getCenter().lng,
          y: map.getCenter().lat,
          z: 0
        };
        cameraVel = { x: 0, y: 0, z: 0 };
        cameraFOV = baseZoom;
        cameraFOVVel = 0; // Initialize velocity for spring physics
      });
    }
    
    // Load a GPX route
    async function loadRoute(routeFile, applyHeightImmediately = false) {
      document.getElementById('loading').style.display = 'flex';
      
      // Ensure buttons are disabled during load
      document.getElementById('toggle-btn').disabled = true;
      document.getElementById('reset-btn').disabled = true;
      
      try {
        // If map has route layer, remove it
        if (map.getLayer('route')) {
          map.removeLayer('route');
        }
        
        // If map has route source, remove it
        if (map.getSource('route')) {
          map.removeSource('route');
        }
        
        // If map has point layer, remove it
        if (map.getLayer('point')) {
          map.removeLayer('point');
        }
        
        // If map has point source, remove it
        if (map.getSource('point')) {
          map.removeSource('point');
        }
        
        const response = await axios.get(`gpx/${routeFile}`);
        const gpxData = response.data;
        
        // Parse GPX data
        const parser = new DOMParser();
        const gpx = parser.parseFromString(gpxData, 'text/xml');
        
        // Extract track points
        const trackPoints = gpx.querySelectorAll('trkpt');
        
        // Reset route data completely
        routeCoordinates = [];
        totalDistance = 0;
        routeDistances = [];
        smoothedRouteCoordinates = [];
        smoothedRouteDistances = [];
        
        // Reset tracking state
        currentPoint = 0;
        currentPointFloat = 0;
        currentRouteDistance = 0;
        
        // Extract elevation gain
        elevationGain = 0;
        let previousElevation = null;
        let minElevation = Infinity;
        let maxElevation = -Infinity;
        
        // Parse route coordinates and calculate cumulative distance
        for (let i = 0; i < trackPoints.length; i++) {
          const point = trackPoints[i];
          const lat = parseFloat(point.getAttribute('lat'));
          const lon = parseFloat(point.getAttribute('lon'));
          const ele = point.querySelector('ele');
          const elevation = ele ? parseFloat(ele.textContent) : 0;
          
          if (elevation < minElevation) minElevation = elevation;
          if (elevation > maxElevation) maxElevation = elevation;
          
          // Calculate elevation gain
          if (previousElevation !== null && elevation > previousElevation) {
            elevationGain += elevation - previousElevation;
          }
          previousElevation = elevation;
          
          const coordinate = [lon, lat, elevation];
          routeCoordinates.push(coordinate);
          
          // Calculate distance from previous point
          if (i > 0) {
            const prevPoint = [routeCoordinates[i-1][0], routeCoordinates[i-1][1]];
            const currentPoint = [lon, lat];
            const segmentDistance = turf.distance(turf.point(prevPoint), turf.point(currentPoint));
            totalDistance += segmentDistance;
          }
          
          // Store cumulative distance at each point (in kilometers)
          routeDistances.push(totalDistance);
        }
        
        // Log route information
        console.log(`Loaded route ${routeFile} with ${routeCoordinates.length} points and ${totalDistance.toFixed(1)}km total distance`);
        
        // Debug: Check if route distances are consistent
        if (routeDistances.length > 10) {
          for (let i = 1; i < Math.min(11, routeDistances.length); i++) {
            const segmentDist = routeDistances[i] - routeDistances[i-1];
            console.log(`Segment ${i}: ${(segmentDist * 1000).toFixed(1)}m`);
          }
        }
        
        // Calculate smoothed route coordinates for camera
        smoothedRouteCoordinates = createSmoothedRoute(routeCoordinates);
        
        // Calculate distances for smoothed route
        if (smoothedRouteCoordinates.length > 0) {
          let smoothedDistance = 0;
          smoothedRouteDistances = [0]; // First point has distance 0
          
          for (let i = 1; i < smoothedRouteCoordinates.length; i++) {
            const prevPoint = [smoothedRouteCoordinates[i-1][0], smoothedRouteCoordinates[i-1][1]];
            const currentPoint = [smoothedRouteCoordinates[i][0], smoothedRouteCoordinates[i][1]];
            const segmentDistance = turf.distance(turf.point(prevPoint), turf.point(currentPoint));
            smoothedDistance += segmentDistance;
            smoothedRouteDistances.push(smoothedDistance);
          }
        }
        
        // Initialize map and camera
        if (routeCoordinates.length > 0) {
          // Save total distance for progress calculations
          totalDistanceMeters = totalDistance * 1000; // km to meters
          
          // Reset camera physics state
          cameraVel = { x: 0, y: 0, z: 0 };
          cameraFOVVel = 0;
          
          // Reset framing controller state
          framingState = "IN_SAFE";
          stateTimer = 0;
          zoomGoal = baseZoom;
          
          // Update UI
          document.getElementById('total-distance').textContent = `${totalDistance.toFixed(1)} km`;
          document.getElementById('elevation-gain').textContent = `${Math.round(elevationGain)} m`;
          document.getElementById('progress').textContent = "0%";
          document.getElementById('distance-traveled').textContent = "0.0 km";
          document.getElementById('current-elevation').textContent = "--";
          document.getElementById('current-gradient').textContent = "--";
          
          // Reset position slider
          const positionSlider = document.getElementById('position-slider');
          if (positionSlider) positionSlider.value = 0;
          
          // Hide elevation marker
          const elevationMarker = document.getElementById('elevation-marker');
          if (elevationMarker) elevationMarker.style.display = 'none';
          
          // Set map center to start of route
          map.flyTo({
            center: [routeCoordinates[0][0], routeCoordinates[0][1]],
            zoom: 13,
            pitch: cameraAngle,
            bearing: 0,
            duration: 1500
          });
          
          // Initialize camera position and state
          // Start with a good initial position slightly behind and above the route start
          if (routeCoordinates.length > 5) {
            // Calculate initial direction from first few points
            const startPoint = routeCoordinates[0];
            const aheadPoint = routeCoordinates[5];
            const initialBearing = calculateBearing(startPoint, aheadPoint);
            
            // Convert to radians for offset calculation
            const bearingRad = (initialBearing + 180) % 360 * Math.PI / 180;
            
            // Position camera slightly behind and above the start point
            cameraPos = {
              x: startPoint[0] - 0.0002 * Math.sin(bearingRad),
              y: startPoint[1] - 0.0002 * Math.cos(bearingRad),
              z: (startPoint[2] || 0) + verticalOffset
            };
            
            // Reset camera state
            cameraFOV = baseZoom;
            currentBearing = initialBearing; // Initialize bearing for smooth transitions
            cameraVelocity = { bearing: 0, speed: 0 }; // Reset camera momentum
            currentWaypoint = null; // Reset waypoint
            waypointUpdateTimer = 0; // Reset timer
          } else {
            // Fallback for routes with fewer points
            cameraPos = {
              x: routeCoordinates[0][0],
              y: routeCoordinates[0][1],
              z: (routeCoordinates[0][2] || 0) + verticalOffset
            };
            currentBearing = 0; // Initialize bearing for smooth transitions
            cameraVelocity = { bearing: 0, speed: 0 }; // Reset camera momentum
            currentWaypoint = null; // Reset waypoint
            waypointUpdateTimer = 0; // Reset timer
          }
          
          // When map is ready, add terrain and layers
          map.once('moveend', () => {
            updateInitialMapView(applyHeightImmediately);
            
            // Draw elevation profile
            drawElevationProfile();
            
            // Hide loading spinner
            document.getElementById('loading').style.display = 'none';
            
            // Enable buttons
            document.getElementById('toggle-btn').disabled = false;
            document.getElementById('reset-btn').disabled = false;
          });
        }
      } catch (error) {
        console.error('Error loading GPX route:', error);
        document.getElementById('loading').style.display = 'none';
        document.getElementById('toggle-btn').disabled = false;
        document.getElementById('reset-btn').disabled = false;
      }
    }
    
    // Update initial map view
    function updateInitialMapView(applyHeightImmediately = false) {
      if (!map || routeCoordinates.length === 0) return;
      
      // Add terrain and layers
      addTerrainAndSources(1.0);
      
      // Reset position
      currentPoint = 0;
      currentPointFloat = 0;
      currentRouteDistance = 0;
      
      // Update point position
      if (map.getSource('point')) {
        updatePointPosition(routeCoordinates[0]);
      }
      
      // Update camera position
      cameraPos = {
        x: routeCoordinates[0][0],
        y: routeCoordinates[0][1],
        z: routeCoordinates[0][2] || 0
      };
      
      // Reset velocity
      cameraVel = { x: 0, y: 0, z: 0 };
      cameraFOVVel = 0; // Reset FOV velocity for spring physics
      
      // Reset framing controller
      framingState = "IN_SAFE";
      stateTimer = 0;
      zoomGoal = baseZoom;
      
      // Update progress UI
      updateProgress();
    }
    
    // Draw elevation profile
    function drawElevationProfile() {
      const canvas = document.getElementById('elevation-canvas');
      if (!canvas || routeCoordinates.length === 0) return;
      
      const ctx = canvas.getContext('2d');
      const canvasWidth = canvas.clientWidth;
      const canvasHeight = canvas.clientHeight;
      
      // Set canvas dimensions to match display size
      canvas.width = canvasWidth;
      canvas.height = canvasHeight;
      
      // Clear canvas
      ctx.clearRect(0, 0, canvasWidth, canvasHeight);
      
      // Find min and max elevation
      let minEle = Infinity;
      let maxEle = -Infinity;
      
      for (const point of routeCoordinates) {
        if (point.length > 2) {
          minEle = Math.min(minEle, point[2]);
          maxEle = Math.max(maxEle, point[2]);
        }
      }
      
      // Add padding to elevation range
      const padding = (maxEle - minEle) * 0.1;
      minEle = Math.max(0, minEle - padding);
      maxEle = maxEle + padding;
      
      // Draw elevation profile
      ctx.beginPath();
      ctx.moveTo(0, canvasHeight);
      
      for (let i = 0; i < routeCoordinates.length; i++) {
        const x = (i / (routeCoordinates.length - 1)) * canvasWidth;
        const elevation = routeCoordinates[i].length > 2 ? routeCoordinates[i][2] : 0;
        const y = canvasHeight - ((elevation - minEle) / (maxEle - minEle)) * canvasHeight;
        
        if (i === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      }
      
      // Complete the path to the bottom of the canvas
      ctx.lineTo(canvasWidth, canvasHeight);
      ctx.lineTo(0, canvasHeight);
      
      // Fill the elevation profile
      const gradient = ctx.createLinearGradient(0, 0, 0, canvasHeight);
      gradient.addColorStop(0, 'rgba(46, 204, 113, 0.8)');
      gradient.addColorStop(1, 'rgba(52, 152, 219, 0.4)');
      
      ctx.fillStyle = gradient;
      ctx.fill();
      
      // Draw the profile line
      ctx.beginPath();
      for (let i = 0; i < routeCoordinates.length; i++) {
        const x = (i / (routeCoordinates.length - 1)) * canvasWidth;
        const elevation = routeCoordinates[i].length > 2 ? routeCoordinates[i][2] : 0;
        const y = canvasHeight - ((elevation - minEle) / (maxEle - minEle)) * canvasHeight;
        
        if (i === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      }
      
      ctx.strokeStyle = 'rgba(41, 128, 185, 0.8)';
      ctx.lineWidth = 2;
      ctx.stroke();
    }
    
    // Toggle animation
    function toggleAnimation() {
      const toggleBtn = document.getElementById('toggle-btn');
      if (animationId) {
        pauseAnimation();
        if (toggleBtn) toggleBtn.textContent = "Start";
      } else {
        startAnimation();
        if (toggleBtn) toggleBtn.textContent = "Pause";
      }
    }
    
    // Start animation
    function startAnimation() {
      if (animationId) return; // Already running
      
      // Disable interactions during animation
      map.dragPan.disable();
      map.scrollZoom.disable();
      map.doubleClickZoom.disable();
      map.touchZoomRotate.disable();
      
      // Disable position slider during animation
      document.getElementById('position-slider').disabled = true;
      
      // Enable reset button
      document.getElementById('reset-btn').disabled = false;
      
      // Start animation
      animationId = requestAnimationFrame(animateRoute);
    }
    
    // Pause animation
    function pauseAnimation() {
      if (animationId) {
        cancelAnimationFrame(animationId);
        animationId = null;
      }
      
      // Re-enable interactions
      map.dragPan.enable();
      map.scrollZoom.enable();
      map.doubleClickZoom.enable();
      map.touchZoomRotate.enable();
      
      // Enable position slider
      document.getElementById('position-slider').disabled = false;
    }
    
    // Reset animation
    function resetAnimation() {
      // Pause animation if running
      pauseAnimation();
      
      // Reset position
      currentPoint = 0;
      currentPointFloat = 0;
      currentRouteDistance = 0;
      
      // Update point position
      if (map.getSource('point')) {
        updatePointPosition(routeCoordinates[0]);
      }
      
      // Reset camera position
      cameraPos = {
        x: routeCoordinates[0][0],
        y: routeCoordinates[0][1],
        z: routeCoordinates[0][2] || 0
      };
      
      // Reset camera state
      cameraFOV = baseZoom;
      
      // Update camera position
      map.flyTo({
        center: [routeCoordinates[0][0], routeCoordinates[0][1]],
        zoom: 13,
        pitch: cameraAngle,
        bearing: 0,
        duration: 1000
      });
      
      // Reset framing controller
      framingState = "IN_SAFE";
      stateTimer = 0;
      zoomGoal = baseZoom;
      
      // Update progress UI
      updateProgress();
      
      // Reset button text
      const toggleBtn = document.getElementById('toggle-btn');
      if (toggleBtn) toggleBtn.textContent = "Start";
    }
    
    // Function to manually update position based on slider
    function updatePositionManually(positionPercent) {
      // Safety check
      if (!routeCoordinates || routeCoordinates.length === 0 || !routeDistances || routeDistances.length === 0) {
        return;
      }
      
      // Calculate the distance along the route
      const totalDistanceMeters = routeDistances[routeDistances.length - 1] * 1000; // km to m
      currentRouteDistance = positionPercent * totalDistanceMeters;
      
      // Convert current distance to km for comparison with routeDistances
      const currentDistanceKm = currentRouteDistance / 1000;
      
      // Get segment using the route
      const segment = calculateSegmentForDistance(currentDistanceKm, false);
      const beforeIdx = segment.beforeIdx;
      const afterIdx = segment.afterIdx;
      const fraction = segment.fraction;
      
      // Get the two points
      const beforePoint = routeCoordinates[beforeIdx];
      const afterPoint = routeCoordinates[afterIdx];
      
      // Create interpolated point
      const interpolatedPoint = [
        beforePoint[0] + (afterPoint[0] - beforePoint[0]) * fraction,
        beforePoint[1] + (afterPoint[1] - beforePoint[1]) * fraction
      ];
      
      // Include elevation if available
      if (beforePoint.length > 2 && afterPoint.length > 2) {
        interpolatedPoint[2] = beforePoint[2] + (afterPoint[2] - beforePoint[2]) * fraction;
      }
      
      // Update rider position
      updatePointPosition(interpolatedPoint);
      
      // Update current tracking point indices
      currentPoint = beforeIdx;
      currentPointFloat = beforeIdx + fraction;
      
      // Update UI
      updateProgress();
      
      // Update camera position
      // Calculate the bearing
      const bearing = calculateBearing(beforePoint, afterPoint);
      
      // Update biker position
      const bikerPos = {
        x: interpolatedPoint[0],
        y: interpolatedPoint[1],
        z: interpolatedPoint[2] || 0
      };
      
      // Calculate velocity based on next point
      const lookAheadIdx = Math.min(afterIdx + 1, routeCoordinates.length - 1);
      const nextPoint = routeCoordinates[lookAheadIdx];
      
      let bikerVel;
      // Safety check for valid points
      if (!nextPoint || !Array.isArray(nextPoint) || nextPoint.length < 2 || 
          !interpolatedPoint || !Array.isArray(interpolatedPoint) || interpolatedPoint.length < 2) {
        console.warn('Invalid points for velocity calculation in manual update');
        // Provide a safe default velocity
        bikerVel = { x: 0, y: 0, z: 0 };
      } else {
        // Calculate velocity with scaled magnitude
        const dx = nextPoint[0] - interpolatedPoint[0];
        const dy = nextPoint[1] - interpolatedPoint[1];
        const dz = (nextPoint.length > 2 && interpolatedPoint.length > 2) ? 
                    (nextPoint[2] - interpolatedPoint[2]) : 0;
        
        // Scale velocity for manual updates
        const scaleFactor = 0.0002;
        
        bikerVel = {
          x: dx * scaleFactor,
          y: dy * scaleFactor,
          z: dz * scaleFactor
        };
      }
      
      // Calculate target position
      const targetPoint = calculateTargetPoint(bikerPos, bikerVel);
      
      // Set the camera position directly for manual positioning
      cameraPos = {
        x: targetPoint.x,
        y: targetPoint.y,
        z: targetPoint.z
      };
      
      // Jump to the new position
      map.jumpTo({
        center: [targetPoint.x, targetPoint.y],
        zoom: 13,
        bearing: bearing,
        pitch: cameraAngle
      });
    }
    
    // Calculate bearing between two coordinates
    function calculateBearing(start, end) {
      // Safety check for invalid coordinates
      if (!start || !end || !Array.isArray(start) || !Array.isArray(end) || 
          start.length < 2 || end.length < 2) {
        console.warn('Invalid coordinates for bearing calculation:', start, end);
        return 0; // Default bearing
      }
      
      try {
        const startLat = start[1] * Math.PI / 180;
        const startLng = start[0] * Math.PI / 180;
        const endLat = end[1] * Math.PI / 180;
        const endLng = end[0] * Math.PI / 180;
        
        const y = Math.sin(endLng - startLng) * Math.cos(endLat);
        const x = Math.cos(startLat) * Math.sin(endLat) - 
                  Math.sin(startLat) * Math.cos(endLat) * Math.cos(endLng - startLng);
        
        const bearing = Math.atan2(y, x) * 180 / Math.PI;
        return (bearing + 360) % 360;
      } catch (e) {
        console.warn('Error calculating bearing:', e);
        return 0; // Default bearing on error
      }
    }
    
    // Event listeners
    document.addEventListener('DOMContentLoaded', () => {
      initMap();
      
      // DOM elements
      const routeSelect = document.getElementById('route-select');
      const heightControl = document.getElementById('camera-height');
      const angleControl = document.getElementById('camera-angle');
      const speedControl = document.getElementById('speed-control');
      const positionSlider = document.getElementById('position-slider');
      const toggleBtn = document.getElementById('toggle-btn');
      const resetBtn = document.getElementById('reset-btn');
      
      // Check URL parameters for requested route
      const initialRoute = parseUrlParams();
      
      // Load the initial route from URL parameter if available
      if (initialRoute) {
        loadRoute(initialRoute, true);
      }
      
      routeSelect.addEventListener('change', () => {
        // Ensure animation is paused before loading new route
        if (animationId) {
          pauseAnimation();
          
          // Reset button text to "Start"
          if (toggleBtn) toggleBtn.textContent = "Start";
        }
        
        // Reset all state variables before loading the new route
        // This prevents the camera from following the old route
        resetAllStateVariables();
        
        // Load the new route
        loadRoute(routeSelect.value, true); // Apply camera height immediately on route change
        
        // Update URL hash to make the current route shareable
        window.location.hash = `route=${routeSelect.value}`;
      });
      
      // Function to completely reset all state variables when changing routes
      function resetAllStateVariables() {
        // Reset route data
        routeCoordinates = [];
        smoothedRouteCoordinates = [];
        routeDistances = [];
        smoothedRouteDistances = [];
        
        // Reset position tracking
        currentPoint = 0;
        currentPointFloat = 0;
        currentRouteDistance = 0;
        totalDistance = 0;
        totalDistanceMeters = 0;
        
        // Reset camera physics state
        cameraPos = { x: 0, y: 0, z: 0 };
        cameraVel = { x: 0, y: 0, z: 0 };
        cameraFOV = baseZoom;
        cameraFOVVel = 0;
        
        // Reset framing controller state
        framingState = "IN_SAFE";
        stateTimer = 0;
        zoomGoal = baseZoom;
        
        // Reset UI elements
        document.getElementById('progress').textContent = "0%";
        document.getElementById('distance-traveled').textContent = "0.0 km";
        document.getElementById('current-elevation').textContent = "--";
        document.getElementById('current-gradient').textContent = "--";
        document.getElementById('total-distance').textContent = "--";
        document.getElementById('elevation-gain').textContent = "--";
        
        // Reset position slider
        const positionSlider = document.getElementById('position-slider');
        if (positionSlider) positionSlider.value = 0;
        
        // Hide elevation marker
        const elevationMarker = document.getElementById('elevation-marker');
        if (elevationMarker) elevationMarker.style.display = 'none';
      }
      
      toggleBtn.addEventListener('click', toggleAnimation);
      resetBtn.addEventListener('click', resetAnimation);
      
      // Camera height handler - updates view immediately
      heightControl.addEventListener('input', () => {
        cameraHeight = parseInt(heightControl.value);
        
        // If not animating, update the view immediately
        if (!animationId) {
          // Calculate target FOV based on height slider
          const heightRatio = cameraHeight / 100;
          const targetFOV = baseZoom + ((zoomMax - baseZoom) * heightRatio);
          
          // Convert FOV to mapbox zoom
          const zoomLevel = 21 - ((targetFOV - 40) / 10);
          
          // Update the map view with new zoom
          map.easeTo({
            zoom: zoomLevel,
            pitch: cameraAngle,
            duration: 500
          });
        }
      });
      
      // Camera angle handler - updates view immediately
      angleControl.addEventListener('input', () => {
        // Invert the values - slider shows low to high (10-85)
        const sliderValue = parseInt(angleControl.value);
        
        // Calculate inverted angle - when slider is at min (10), we want max angle (85)
        // and vice versa
        cameraAngle = 95 - sliderValue; // 95 - 10 = 85, 95 - 85 = 10
        
        // If animation is not running, update the view immediately
        if (!animationId && routeCoordinates.length > 0) {
          updateInitialMapView();
        }
      });
      
      speedControl.addEventListener('input', () => {
        animationSpeed = parseFloat(speedControl.value);
      });
      
      // Position slider handler
      positionSlider.addEventListener('input', () => {
        // Only allow manual positioning when animation is not running
        if (!animationId) {
          const positionPercent = parseFloat(positionSlider.value) / 100;
          updatePositionManually(positionPercent);
        }
      });
    });
    
    // Function to parse URL parameters and hash fragments
    function parseUrlParams() {
      // Check for route parameter in the URL query string
      const urlParams = new URLSearchParams(window.location.search);
      const routeParam = urlParams.get('route');
      
      // Check for route in the hash fragment (e.g. #route=D1_East_Long.gpx)
      const hashParams = new URLSearchParams(window.location.hash.substring(1));
      const hashRoute = hashParams.get('route');
      
      // Use the parameter from query string or hash if available
      const requestedRoute = routeParam || hashRoute;
      
      if (requestedRoute) {
        // Find the matching option in the select element
        const options = Array.from(document.getElementById('route-select').options);
        const matchingOption = options.find(option => option.value === requestedRoute);
        
        if (matchingOption) {
          // Set the select element to the requested route
          document.getElementById('route-select').value = requestedRoute;
          return requestedRoute;
        }
      }
      
      // Return default route if no valid route parameter found
      return document.getElementById('route-select').value;
    }
  </script>
</body>
</html>