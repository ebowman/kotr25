<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>King of the Road 2025 - Route Flyover</title>
  <link rel="stylesheet" href="https://unpkg.com/mapbox-gl@2.15.0/dist/mapbox-gl.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />
  <script src="https://unpkg.com/mapbox-gl@2.15.0/dist/mapbox-gl.js"></script>
  <script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>
  <script src="https://unpkg.com/axios/dist/axios.min.js"></script>
  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      background: #f9f9f9;
      color: #333;
    }
    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
      display: flex;
      flex-wrap: wrap;
      gap: 20px;
    }
    h1 {
      width: 100%;
      text-align: center;
      margin-bottom: 10px;
      color: #222;
    }
    #map {
      flex: 1;
      min-width: 700px;
      height: 600px;
      border-radius: 8px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.05);
    }
    .controls {
      width: 280px;
      padding: 15px;
      background: white;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.05);
      display: flex;
      flex-direction: column;
      gap: 20px;
    }
    select, button {
      padding: 10px 15px;
      border-radius: 5px;
      border: 1px solid #ddd;
      background: white;
      font-size: 14px;
      width: 100%;
    }
    button {
      background: linear-gradient(to bottom, #3498db, #2980b9);
      color: white;
      cursor: pointer;
      border: none;
      transition: all 0.2s;
      font-weight: 600;
    }
    button:hover {
      background: linear-gradient(to bottom, #2980b9, #2471a3);
      transform: translateY(-1px);
    }
    button:disabled {
      background: #ccc;
      cursor: not-allowed;
    }
    label {
      font-weight: 600;
      margin-bottom: 5px;
      display: block;
      color: #444;
    }
    .control-group {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .route-info {
      background: white;
      border-radius: 8px;
      padding: 15px;
      margin-top: 20px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    }
    .info-grid {
      display: flex;
      justify-content: space-between;
      flex-wrap: nowrap;
      gap: 15px;
      margin-top: 10px;
    }
    .info-item {
      flex: 1;
      text-align: center;
      padding: 12px;
      background: #f5f9ff;
      border-radius: 5px;
    }
    .info-label {
      font-size: 12px;
      color: #666;
      margin-bottom: 5px;
    }
    .info-value {
      font-size: 20px;
      font-weight: 600;
      color: #2c3e50;
    }
    .elevation-profile {
      width: 100%;
      height: 120px;
      background: white;
      margin-top: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.05);
      position: relative;
    }
    #elevation-canvas {
      width: 100%;
      height: 100%;
      border-radius: 8px;
    }
    .elevation-marker {
      position: absolute;
      top: 0;
      width: 2px;
      height: 120px;
      background: red;
      z-index: 10;
      pointer-events: none;
    }
    .loading {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(255,255,255,0.8);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }
    .loading-spinner {
      border: 5px solid #f3f3f3;
      border-top: 5px solid #3498db;
      border-radius: 50%;
      width: 50px;
      height: 50px;
      animation: spin 1s linear infinite;
      margin-bottom: 15px;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    .slider-container {
      margin-top: 5px;
    }
    .range-labels {
      display: flex;
      justify-content: space-between;
      font-size: 12px;
      color: #666;
      margin-top: 5px;
    }
    input[type="range"] {
      width: 100%;
      margin: 0;
      -webkit-appearance: none;
      appearance: none;
      height: 6px;
      background: #e0e0e0;
      border-radius: 3px;
      outline: none;
    }
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: #3498db;
      cursor: pointer;
      border: 2px solid white;
      box-shadow: 0 1px 3px rgba(0,0,0,0.2);
    }
    input[type="range"]::-moz-range-thumb {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: #3498db;
      cursor: pointer;
      border: 2px solid white;
      box-shadow: 0 1px 3px rgba(0,0,0,0.2);
    }
  </style>
</head>
<body>
  <div class="container">
    <div style="display: flex; justify-content: space-between; align-items: center; width: 100%; margin-bottom: 10px;">
      <a href="index.html" style="text-decoration: none; color: #3498db; display: flex; align-items: center;">
        <i class="fas fa-arrow-left" style="margin-right: 5px;"></i> Back to routes
      </a>
    </div>
    <h1>King of the Road 2025 - 3D Route Flyover</h1>
    
    <div class="controls">
      <div class="control-group">
        <label for="route-select">Select Route:</label>
        <select id="route-select">
          <option value="D0_Warm-up.gpx">Day 0 - Warm-up</option>
          <option value="D1_East Short.gpx">Day 1 - East (Short)</option>
          <option value="D1_East_Long.gpx">Day 1 - East (Long)</option>
          <option value="D2_North_Short.gpx">Day 2 - North (Short)</option>
          <option value="D2_North_Long.gpx">Day 2 - North (Long)</option>
          <option value="D3_West_Short.gpx">Day 3 - West (Short)</option>
          <option value="D3_West_Long.gpx">Day 3 - West (Long)</option>
        </select>
      </div>
      
      <div class="control-group">
        <label for="camera-height">Zoom:</label>
        <div class="slider-container">
          <input type="range" id="camera-height" min="1" max="100" step="1" value="25">
          <div class="range-labels">
            <span>In</span>
            <span>Out</span>
          </div>
        </div>
      </div>
      
      <div class="control-group">
        <label for="camera-angle">View Angle:</label>
        <div class="slider-container">
          <input type="range" id="camera-angle" min="10" max="85" step="1" value="45">
          <div class="range-labels">
            <span>Low</span>
            <span>High</span>
          </div>
        </div>
      </div>
      
      <div class="control-group">
        <label for="speed-control">Animation Speed:</label>
        <div class="slider-container">
          <input type="range" id="speed-control" min="0.1" max="1" step="0.1" value="0.5">
          <div class="range-labels">
            <span>Slow</span>
            <span>Fast</span>
          </div>
        </div>
      </div>
      
      <div class="control-group">
        <label for="position-slider">Position:</label>
        <div class="slider-container">
          <input type="range" id="position-slider" min="0" max="100" step="0.1" value="0">
          <div class="range-labels">
            <span>Start</span>
            <span>End</span>
          </div>
        </div>
      </div>
      
      <div class="control-group" style="margin-top: 10px;">
        <button id="toggle-btn">Start</button>
        <button id="reset-btn" disabled>Reset</button>
      </div>
    </div>
    
    <div id="map"></div>
    
    <div class="elevation-profile">
      <canvas id="elevation-canvas"></canvas>
      <div class="elevation-marker" id="elevation-marker" style="display: none;"></div>
    </div>
    
    <div class="route-info">
      <div class="info-header">
        <h3>Route Information</h3>
      </div>
      <div class="info-grid">
        <div class="info-item">
          <div class="info-label">Total Distance</div>
          <div class="info-value" id="total-distance">--</div>
        </div>
        <div class="info-item">
          <div class="info-label">Distance Traveled</div>
          <div class="info-value" id="distance-traveled">0.0 km</div>
        </div>
        <div class="info-item">
          <div class="info-label">Elevation Gain</div>
          <div class="info-value" id="elevation-gain">--</div>
        </div>
        <div class="info-item">
          <div class="info-label">Current Elevation</div>
          <div class="info-value" id="current-elevation">--</div>
        </div>
        <div class="info-item">
          <div class="info-label">Current Gradient</div>
          <div class="info-value" id="current-gradient">--</div>
        </div>
        <div class="info-item">
          <div class="info-label">Progress</div>
          <div class="info-value" id="progress">0%</div>
        </div>
      </div>
    </div>
  </div>
  
  <div class="loading" id="loading">
    <div class="loading-spinner"></div>
    <p>Loading route data...</p>
  </div>
  
  <script>
    // Replace with your Mapbox access token
    mapboxgl.accessToken = 'pk.eyJ1IjoiZWJvd21hbiIsImEiOiJjbWE1ZWVwdzYwODhwMmlzZnU4NTlyem1rIn0.E10X5hj2NTgViJexKpvrOg';
    
    // Global variables
    let map;
    let routeData = null;
    let animationId = null;
    let currentPoint = 0;
    let elevationProfile = [];
    let maxElevation = 0;
    let minElevation = Infinity;
    let totalDistance = 0;
    let elevationGain = 0;
    let routeCoordinates = [];
    let smoothedRouteCoordinates = []; // Smoothed version of coordinates for camera movement when zoomed out
    let routeDistances = []; // Array to store cumulative distances along route
    let smoothedRouteDistances = []; // Array to store distances for smoothed route
    let animationSpeed = 0.5;
    let cameraHeight = 25; // Default camera height (slider position, not actual meters)
    let cameraAngle = 50; // Default camera angle (pitch) in degrees (inverted from slider value of 45)
    let currentRouteDistance = 0; // Current distance along route in meters
    let totalDistanceMeters = 0; // Total distance of the route in meters
    let dt = 1/60; // Physics timestep in seconds (60fps)
    
    // Camera state variables
    let cameraPos = { x: 0, y: 0, z: 0 }; // Position
    let cameraVel = { x: 0, y: 0, z: 0 }; // Velocity for physics-based motion
    let cameraFOV = 60; // Field of view
    let cameraFOVVel = 0; // Velocity for FOV physics (spring model)
    
    // Camera control parameters based on CAMERA.md
    let lookAheadFactor = 0.2;  // Less aggressive look-ahead
    let minLook = 5;  // Minimum look-ahead distance
    let maxLook = 80;  // Significantly reduced maximum look-ahead for better visibility
    let verticalOffset = 10;  // Minimal vertical offset to keep rider in view
    let kBase = 3.0;  // Increased spring stiffness for more responsive camera
    let kZoomedOutMul = 0.4;  // Moderate damping when zoomed out
    let zoomStep = 3;  // Moderate FOV increments when zooming out
    let baseZoom = 50;  // Default FOV - narrower for closer view (mapbox zoom ~17-18)
    let zoomMax = 75;  // Maximum FOV - now more moderate (mapbox zoom ~14-15)
    let tightBox = { x: 0.30, y: 0.20 };  // Smaller box to trigger zoom-out sooner
    let looseBox = { x: 0.45, y: 0.30 };  // More moderate box when zoomed out
    let outerBox = { x: 0.70, y: 0.70 };  // Smaller outer boundary for better visibility
    let stableTime = 1.0;  // Quicker recovery time
    
    // Framing controller state
    let framingState = "IN_SAFE"; // One of: IN_SAFE, ZOOMING_OUT, COOLDOWN, ZOOMING_IN
    let stateTimer = 0;
    let zoomGoal = baseZoom;
    
    // Create multiple levels of route smoothing for dynamic camera behavior
    function createSmoothedRoute(coordinates) {
      // Skip if too few points
      if (coordinates.length <= 10) return [...coordinates];
      
      // Create multiple levels of smoothing for different zoom levels
      // We'll calculate different smoothing for low, medium and high zoom levels
      // This allows more stable camera movement when zoomed out
      
      // ===== MULTI-LEVEL SMOOTHING APPROACH =====
      
      // Determine base smoothing factors based on route length and complexity
      // We need different smoothing levels for different zoom levels
      const routeLength = coordinates.length;
      const baseSmoothing = Math.max(3, Math.floor(routeLength / 300));
      
      // Create multi-resolution smoothed paths
      const smoothed = [];
      
      // Always include the first point
      smoothed.push([...coordinates[0]]);
      
      // Adapt point inclusion based on route length
      // For longer routes, we need to skip more points to avoid excessive memory usage
      // while still maintaining route fidelity
      const skipFactor = Math.max(1, Math.ceil(routeLength / 1500)); 
      
      // Process interior points with adaptive smoothing
      for (let i = skipFactor; i < routeLength - skipFactor; i += skipFactor) {
        // Create adaptive smoothing that varies based on position in the route:
        // - More aggressive smoothing in the middle of the route
        // - Less aggressive smoothing near endpoints
        // - Special handling for significant elevation changes
        // This creates more natural camera behavior at endpoints and elevation changes
        
        // Calculate position-based smoothing factor
        // Distance from either end determines smoothing strength
        const positionFactor = Math.min(
          i / routeLength,                // Distance from start (0-1)
          (routeLength - i) / routeLength // Distance from end (0-1)
        ) * 4;                            // Scale up for more noticeable effect
        
        // Detect elevation significance - important for hills and downhill sections
        // We want to preserve significant elevation changes for camera look-ahead
        let elevationSignificance = 0;
        
        if (coordinates[i].length > 2 && 
            i > 0 && i < routeLength - 1 && 
            coordinates[i-1].length > 2 && coordinates[i+1].length > 2) {
          
          // Calculate elevation change rate (gradient)
          const elevChange = Math.abs(coordinates[i][2] - coordinates[i-1][2]);
          const elevChangeNext = Math.abs(coordinates[i+1][2] - coordinates[i][2]);
          
          // Higher values = less smoothing near significant elevation changes
          elevationSignificance = Math.min(1, (elevChange + elevChangeNext) / 10);
        }
        
        // Calculate final window size for this point
        // Smaller window = less smoothing, larger window = more smoothing
        // Three factors affect window size:
        // 1. Base smoothing (route length dependent)
        // 2. Position factor (middle vs. endpoints)
        // 3. Elevation significance (hills get less smoothing)
        const windowSize = Math.max(5, Math.round(
          baseSmoothing * (1 + positionFactor) * (1 - elevationSignificance * 0.5)
        ));
        
        // === WEIGHTED GAUSSIAN SMOOTHING ===
        // This produces much more natural curves than simple averaging
        let sumLng = 0;
        let sumLat = 0;
        let sumEle = 0;
        let totalWeight = 0;
        
        // Calculate weighted average with Gaussian falloff
        for (let j = i - windowSize; j <= i + windowSize; j++) {
          if (j >= 0 && j < routeLength) {
            // Calculate distance-based weight with Gaussian falloff
            const distFactor = Math.abs(i - j) / windowSize;
            
            // Steeper Gaussian falloff for more natural curves
            // Higher exponent = steeper falloff = less influence from distant points
            const weight = Math.exp(-5.5 * distFactor * distFactor);
            
            // Add weighted contribution
            sumLng += coordinates[j][0] * weight;
            sumLat += coordinates[j][1] * weight;
            totalWeight += weight;
            
            // Handle elevation data with special weighting to preserve route features
            if (coordinates[j].length > 2) {
              // For elevation, we use a modified weighting that preserves hills
              // by reducing the amount of smoothing applied to significant changes
              const elevWeight = weight * (1 - elevationSignificance * 0.5);
              sumEle += coordinates[j][2] * elevWeight;
            }
          }
        }
        
        // Create the smoothed point with normalized weights
        const smoothPoint = [
          sumLng / totalWeight,
          sumLat / totalWeight
        ];
        
        // Add elevation if it exists (with modified smoothing)
        if (coordinates[i].length > 2) {
          // If elevation significance is high, use less smoothing to preserve feature
          // This prevents camera from missing hills and valleys
          const rawElevation = coordinates[i][2];
          const smoothedElevation = sumEle / totalWeight;
          
          // Blend between raw and smoothed elevation based on significance
          // More significant elevation changes are preserved (less smoothing)
          const blendedElevation = 
            (smoothedElevation * (1 - elevationSignificance * 0.7)) + 
            (rawElevation * elevationSignificance * 0.7);
          
          smoothPoint.push(blendedElevation);
        }
        
        smoothed.push(smoothPoint);
      }
      
      // Always include the last point
      smoothed.push([...coordinates[routeLength - 1]]);
      
      console.log(`Route smoothed from ${routeLength} to ${smoothed.length} points with multi-level adaptive smoothing`);
      return smoothed;
    }
    
    // Helper function to efficiently calculate segment data for any distance
    // Uses binary search for much faster lookups, important for smooth animation
    function calculateSegmentForDistance(distanceKm, useSmoothedRoute = false) {
      // Choose which route and distances to use based on zoom level
      const distances = useSmoothedRoute ? smoothedRouteDistances : routeDistances;
      
      let beforeIdx = 0;
      let afterIdx = 1;
      let fraction = 0;
      
      // Handle edge cases for start and end of route
      if (distanceKm <= distances[0]) {
        return { beforeIdx: 0, afterIdx: 1, fraction: 0 };
      }
      if (distanceKm >= distances[distances.length - 1]) {
        return { 
          beforeIdx: distances.length - 2,
          afterIdx: distances.length - 1,
          fraction: 1
        };
      }
      
      // Binary search to find the closest segment for the given distance
      // This is much more efficient than linear search for long routes
      let start = 0, end = distances.length - 1;
      
      while (start <= end) {
        const mid = Math.floor((start + end) / 2);
        
        if (distances[mid] <= distanceKm && distances[mid + 1] >= distanceKm) {
          beforeIdx = mid;
          afterIdx = mid + 1;
          break;
        } else if (distances[mid] < distanceKm) {
          start = mid + 1;
        } else {
          end = mid - 1;
        }
      }
      
      // Calculate the interpolation fraction
      const segmentLength = distances[afterIdx] - distances[beforeIdx];
      fraction = segmentLength > 0 ? 
        (distanceKm - distances[beforeIdx]) / segmentLength : 0;
      
      return { beforeIdx, afterIdx, fraction };
    }

    // Calculate bearing between two coordinates
    function calculateBearing(start, end) {
      // Safety check for invalid coordinates
      if (!start || !end || !Array.isArray(start) || !Array.isArray(end) || 
          start.length < 2 || end.length < 2) {
        console.warn('Invalid coordinates for bearing calculation:', start, end);
        return 0; // Default bearing
      }
      
      try {
        const startLat = start[1] * Math.PI / 180;
        const startLng = start[0] * Math.PI / 180;
        const endLat = end[1] * Math.PI / 180;
        const endLng = end[0] * Math.PI / 180;
        
        const y = Math.sin(endLng - startLng) * Math.cos(endLat);
        const x = Math.cos(startLat) * Math.sin(endLat) - 
                  Math.sin(startLat) * Math.cos(endLat) * Math.cos(endLng - startLng);
        
        const bearing = Math.atan2(y, x) * 180 / Math.PI;
        return (bearing + 360) % 360;
      } catch (e) {
        console.warn('Error calculating bearing:', e);
        return 0; // Default bearing on error
      }
    }
    
    // Update point position
    function updatePointPosition(coord) {
      // Safety check to prevent errors
      if (!coord || !Array.isArray(coord) || coord.length < 2) {
        console.warn('Invalid coordinate passed to updatePointPosition:', coord);
        return;
      }
      
      // Create a GeoJSON point
      const point = {
        type: 'Feature',
        properties: {},
        geometry: {
          type: 'Point',
          coordinates: [coord[0], coord[1]]
        }
      };
      
      // Update the point source if it exists
      if (map && map.getSource('point')) {
        try {
          map.getSource('point').setData(point);
        } catch (e) {
          console.warn('Error updating point position:', e);
        }
      }
    }
    
    // TARGET-POINT MODULE: Simplified direct target position calculation
    function calculateTargetPoint(bikerPos, bikerVel) {
      // Safety checks for NaN values
      if (isNaN(bikerPos.x) || isNaN(bikerPos.y) || isNaN(bikerPos.z) ||
          isNaN(bikerVel.x) || isNaN(bikerVel.y) || isNaN(bikerVel.z)) {
        console.warn('NaN values detected in biker position or velocity');
        // Return a safe fallback position
        return {
          x: bikerPos.x || 0,
          y: bikerPos.y || 0,
          z: (bikerPos.z || 0) + verticalOffset
        };
      }
      
      // Get the current camera angle
      const angleControl = document.getElementById('camera-angle');
      let angle = 45; // Default pitch angle
      
      if (angleControl) {
        const sliderValue = parseInt(angleControl.value);
        // Calculate inverted angle - when slider is at min (10), we want max angle (85)
        angle = 95 - sliderValue; // 95 - 10 = 85, 95 - 85 = 10
      }
      
      // Calculate speed for adaptive behavior
      const speed = Math.sqrt(
        bikerVel.x * bikerVel.x + 
        bikerVel.y * bikerVel.y + 
        bikerVel.z * bikerVel.z
      );
      
      // Apply reasonable limits to speed
      const safeSpeed = Math.max(0, Math.min(100, speed));
      
      // Direct simplified approach that keeps rider in view
      let targetX, targetY, targetZ;
      
      // Get direction of movement
      let moveX = 0, moveY = 0, moveZ = 0;
      if (safeSpeed > 0.001) {
        moveX = bikerVel.x / safeSpeed;
        moveY = bikerVel.y / safeSpeed;
        moveZ = bikerVel.z / safeSpeed;
        
        // Extremely simplified look-ahead based on viewing angle:
        // - High angle: Almost no look-ahead (directly above rider)
        // - Middle angle: Moderate look-ahead
        // - Low angle: More look-ahead
        
        // Base look-ahead distance (much reduced from before)
        const baseLookAhead = Math.min(40, Math.max(5, safeSpeed * 2));
        
        // Adjust look-ahead based on viewing angle
        let lookAhead;
        if (angle > 75) { // Near vertical
          lookAhead = baseLookAhead * 0.1; // Minimal look-ahead (10%)
        } else if (angle > 60) { // High angle
          lookAhead = baseLookAhead * 0.3; // Very little look-ahead (30%)
        } else if (angle > 45) { // Medium-high angle
          lookAhead = baseLookAhead * 0.5; // Moderate look-ahead (50%)
        } else if (angle > 30) { // Medium angle
          lookAhead = baseLookAhead * 0.7; // More look-ahead (70%)
        } else { // Low angle
          lookAhead = baseLookAhead; // Full look-ahead (100%)
        }
        
        // Calculate vertical offset - higher at lower angles
        const verticalOffsetMultiplier = Math.max(0.5, Math.min(2.0, 2.0 - (angle / 90)));
        const adaptiveVerticalOffset = verticalOffset * verticalOffsetMultiplier;
        
        // Calculate target position with look-ahead
        targetX = bikerPos.x + moveX * lookAhead;
        targetY = bikerPos.y + moveY * lookAhead;
        targetZ = bikerPos.z + moveZ * lookAhead * 0.5 + adaptiveVerticalOffset;
      } else {
        // If speed is very low, use a simple offset based on angle already calculated
        
        // Calculate vertical offset based on angle
        const verticalOffsetMultiplier = Math.max(0.5, Math.min(2.0, 2.0 - (angle / 90)));
        const adaptiveVerticalOffset = verticalOffset * verticalOffsetMultiplier;
        
        // For high angles when stationary, position camera slightly behind rider
        if (angle > 65) { // Near vertical view
          // Position camera slightly offset to give better perspective
          const positionOffset = 0.00005;
          targetX = bikerPos.x - positionOffset;
          targetY = bikerPos.y - positionOffset;
          targetZ = bikerPos.z + adaptiveVerticalOffset;
        } else {
          // For lower angles, position directly above
          targetX = bikerPos.x;
          targetY = bikerPos.y;
          targetZ = bikerPos.z + adaptiveVerticalOffset;
        }
      }
      
      // Final safety check for NaN values
      if (isNaN(targetX) || isNaN(targetY) || isNaN(targetZ)) {
        console.warn('NaN values detected in target calculation');
        return {
          x: bikerPos.x || 0,
          y: bikerPos.y || 0,
          z: (bikerPos.z || 0) + verticalOffset
        };
      }
      
      return {
        x: targetX,
        y: targetY,
        z: targetZ
      };
    }
    
    // FRAMING CONTROLLER: Check rider position in viewport and manage zoom
    function framingController(bikerScreenPos) {
      if (!bikerScreenPos) return;
      
      try {
        // Ensure valid input
        if (isNaN(bikerScreenPos.x) || isNaN(bikerScreenPos.y)) {
          console.warn('Invalid biker screen position for framing controller');
          return;
        }
        
        // Normalize screen coordinates to NDC space (-1 to 1) with safety checks
        const viewportWidth = map.getContainer().offsetWidth || 1000; // Default fallback
        const viewportHeight = map.getContainer().offsetHeight || 600; // Default fallback
        
        const bikerNDC = {
          x: (bikerScreenPos.x / viewportWidth) * 2 - 1,
          y: (bikerScreenPos.y / viewportHeight) * 2 - 1
        };
        
        // Apply reasonable limits to NDC coordinates
        bikerNDC.x = Math.max(-1.5, Math.min(1.5, bikerNDC.x));
        bikerNDC.y = Math.max(-1.5, Math.min(1.5, bikerNDC.y));
        
        // Calculate zoom alpha (0: zoomed in, 1: zoomed out) with safety limits
        const zoomRange = Math.max(0.1, zoomMax - baseZoom);
        const zoomAlpha = Math.max(0, Math.min(1, (cameraFOV - baseZoom) / zoomRange));
        
        // Get current angle for adaptive framing
        const angleControl = document.getElementById('camera-angle');
        let angle = 45; // Default pitch angle
        
        if (angleControl) {
          const sliderValue = parseInt(angleControl.value);
          angle = 95 - sliderValue; // 95 - 10 = 85, 95 - 85 = 10
        }
        
        // For high angles, use a tighter framing box
        // This keeps the rider more centered when looking down
        let adaptedTightBox, adaptedLooseBox;
        
        if (angle > 65) { // Very high angle (near vertical)
          // Much tighter box to keep rider more centered
          adaptedTightBox = { 
            x: tightBox.x * 0.6, 
            y: tightBox.y * 0.6 
          };
          adaptedLooseBox = { 
            x: looseBox.x * 0.7, 
            y: looseBox.y * 0.7 
          };
        } else if (angle > 45) { // Moderate high angle
          // Somewhat tighter box
          adaptedTightBox = { 
            x: tightBox.x * 0.8, 
            y: tightBox.y * 0.8 
          };
          adaptedLooseBox = { 
            x: looseBox.x * 0.85, 
            y: looseBox.y * 0.85 
          };
        } else { // Normal angles
          adaptedTightBox = tightBox;
          adaptedLooseBox = looseBox;
        }
        
        // Dynamically size the framing box based on zoom level
        const innerBoxSize = {
          x: adaptedTightBox.x + (adaptedLooseBox.x - adaptedTightBox.x) * zoomAlpha,
          y: adaptedTightBox.y + (adaptedLooseBox.y - adaptedTightBox.y) * zoomAlpha
        };
        
        // Check if biker is leaving inner box
        const isLeaving = 
          Math.abs(bikerNDC.x) > innerBoxSize.x || 
          Math.abs(bikerNDC.y) > innerBoxSize.y;
        
        // Check if biker is inside outer box
        const isInsideOuterBox = 
          Math.abs(bikerNDC.x) < outerBox.x && 
          Math.abs(bikerNDC.y) < outerBox.y;
        
        // Check if manual zoom level is active via slider
        const heightControl = document.getElementById('camera-height');
        let isManualZoomActive = false;
        let manualZoomAmount = 0;
        
        if (heightControl) {
          const heightValue = parseInt(heightControl.value);
          // If user has moved slider significantly from center (25-75 range), consider manual zoom active
          isManualZoomActive = heightValue < 25 || heightValue > 75;
          // Calculate how far from center (0-50, where 50 = at either extreme)
          manualZoomAmount = Math.abs(heightValue - 50);
        }
        
        // Frame timer
        stateTimer += dt;
        
        // Cap timer to prevent overflow
        stateTimer = Math.min(stateTimer, 10); 
        
        // Make state transitions more robust
        let nextState = framingState;
        let nextZoomGoal = zoomGoal;
        
        // State machine from CAMERA.md, modified to respect manual zoom
        if (isManualZoomActive && manualZoomAmount > 40) {
          // When manual zoom is at extremes, defer to manual control completely
          // Exit the automatic state machine
          const manualZoomFOV = baseZoom + ((zoomMax - baseZoom) * heightControl.value / 100);
          nextZoomGoal = manualZoomFOV;
          nextState = "IN_SAFE"; // Reset state
        } else {
          // Handle automatic zoom with the state machine from CAMERA.md
          switch (framingState) {
            case "IN_SAFE":
              if (isLeaving) {
                // Calculate zoom step based on how far rider is outside the frame
                const xExcess = Math.max(0, Math.abs(bikerNDC.x) - innerBoxSize.x);
                const yExcess = Math.max(0, Math.abs(bikerNDC.y) - innerBoxSize.y);
                const maxExcess = Math.max(xExcess, yExcess);
                
                // Scale zoom step based on how far outside the frame (smoother transitions)
                // More aggressive zoom out when rider is far outside the frame
                const adaptiveStep = zoomStep * (1 + maxExcess * 2);
                
                nextZoomGoal = Math.min(cameraFOV + adaptiveStep, zoomMax);
                nextState = "ZOOMING_OUT";
                stateTimer = 0;
              }
              break;
              
            case "ZOOMING_OUT":
              // Add hysteresis margin to avoid oscillation
              const hysteresisMargin = 0.05; // 5% margin
              const isWellInsideOuterBox = 
                Math.abs(bikerNDC.x) < (outerBox.x - hysteresisMargin) && 
                Math.abs(bikerNDC.y) < (outerBox.y - hysteresisMargin);
                
              if (isWellInsideOuterBox) {
                nextState = "COOLDOWN";
              }
              break;
              
            case "COOLDOWN":
              if (stateTimer > stableTime) {
                nextZoomGoal = baseZoom;
                nextState = "ZOOMING_IN";
              } else if (isLeaving) {
                // Gradual zoom step based on how far outside the frame (smoother)
                const xExcess = Math.max(0, Math.abs(bikerNDC.x) - innerBoxSize.x);
                const yExcess = Math.max(0, Math.abs(bikerNDC.y) - innerBoxSize.y);
                const maxExcess = Math.max(xExcess, yExcess);
                const adaptiveStep = zoomStep * (1 + maxExcess * 2);
                
                nextZoomGoal = Math.min(cameraFOV + adaptiveStep, zoomMax);
                nextState = "ZOOMING_OUT";
                stateTimer = 0;
              }
              break;
              
            case "ZOOMING_IN":
              if (isLeaving) {
                nextZoomGoal = cameraFOV; // Abort zoom-in
                nextState = "ZOOMING_OUT";
              } else if (Math.abs(zoomGoal - cameraFOV) < 0.1) {
                nextState = "IN_SAFE";
              }
              break;
              
            default:
              // Handle invalid state by resetting
              console.warn('Invalid framing state:', framingState);
              nextState = "IN_SAFE";
              nextZoomGoal = baseZoom;
          }
        }
        
        // Blend automatic and manual zoom control
        if (heightControl && !isManualZoomActive) {
          const heightValue = parseInt(heightControl.value);
          // Calculate manual influence (0-1 scale, higher at extremes)
          const manualInfluence = Math.pow(manualZoomAmount / 50, 2) * 0.7; // Squared for non-linear influence
          
          // Calculate manual FOV from height slider
          const manualFOV = baseZoom + ((zoomMax - baseZoom) * heightValue / 100);
          
          // Blend automatic and manual control
          nextZoomGoal = nextZoomGoal * (1 - manualInfluence) + manualFOV * manualInfluence;
        }
        
        // Update state
        framingState = nextState;
        zoomGoal = nextZoomGoal;
        
      } catch (e) {
        console.warn('Error in framing controller:', e);
        // Reset to safe defaults
        framingState = "IN_SAFE";
        zoomGoal = baseZoom;
      }
    }
    
    // CAMERA SOLVER: Predictive direct-follow camera system
    function updateCameraPhysics(targetPos, targetFOV) {
      // Apply safety limits to FOV
      targetFOV = Math.max(baseZoom, Math.min(zoomMax, targetFOV));
      
      // Calculate zoom alpha (0: zoomed in, 1: zoomed out)
      const zoomAlpha = Math.max(0, Math.min(1, (cameraFOV - baseZoom) / (zoomMax - baseZoom)));
      
      // Update FOV with simple direct approach (removed kFOV reference)
      // Move directly 40% of the way to target FOV each frame
      cameraFOV = cameraFOV + (targetFOV - cameraFOV) * 0.4;
      
      // Apply safety limits to FOV
      cameraFOV = Math.max(baseZoom, Math.min(zoomMax, cameraFOV));
      
      // Predictive factor: How far to keep camera ahead of movement
      // This directly follows where the bike is going
      // Based on the current speed and the route itself
      let predictiveFactor = 0.80; // 80% of the way to target position
      
      // Special case for high viewing angles - use almost direct positioning
      // This keeps the rider in view at all times
      const angleControl = document.getElementById('camera-angle');
      if (angleControl) {
        const sliderValue = parseInt(angleControl.value);
        const angle = 95 - sliderValue; // Convert to pitch
        
        if (angle > 70) { // Very high angles
          predictiveFactor = 0.95; // Almost direct positioning (95% of the way)
        } else if (angle > 50) {
          predictiveFactor = 0.90; // Stronger tracking (90% of the way)
        }
      }
      
      // Implement critically-damped spring physics for camera position (per CAMERA.md)
      // For each axis (x,y,z):
      // k = stiffness(zoomLevel)
      // c = 2√k (critical damping)
      // a = k * (goal - pos) - c * vel
      // vel_new = vel + a * dt
      // pos_new = pos + vel_new * dt
      
      const dx = targetPos.x - cameraPos.x;
      const dy = targetPos.y - cameraPos.y;
      const dz = targetPos.z - cameraPos.z;
      
      // Calculate stiffness based on zoom level - higher when zoomed in
      // "Stiffness scales linearly with inverse zoom: k = kBase * lerp(1, kZoomedOutMul, zoomAlpha)"
      // Using existing zoomAlpha variable already calculated above
      const kFOV = kBase * (1 + (kZoomedOutMul - 1) * zoomAlpha);
      
      // Critical damping coefficient
      const c = 2 * Math.sqrt(kFOV);
      
      // Calculate acceleration for each axis
      const ax = kFOV * dx - c * cameraVel.x;
      const ay = kFOV * dy - c * cameraVel.y;
      const az = kFOV * dz - c * cameraVel.z;
      
      // Update velocity
      cameraVel.x = cameraVel.x + ax * dt;
      cameraVel.y = cameraVel.y + ay * dt;
      cameraVel.z = cameraVel.z + az * dt;
      
      // Update position
      cameraPos.x = cameraPos.x + cameraVel.x * dt;
      cameraPos.y = cameraPos.y + cameraVel.y * dt;
      cameraPos.z = cameraPos.z + cameraVel.z * dt;
      
      // Hard limit on how far the camera can be from the target position
      // This ensures the camera never lags too far behind (safety fallback)
      const maxDistance = 0.0003;
      const distance = Math.sqrt(dx*dx + dy*dy);
      
      if (distance > maxDistance) {
        // Move camera directly toward target at max distance (emergency correction)
        const scale = maxDistance / distance;
        cameraPos.x = targetPos.x - dx * scale;
        cameraPos.y = targetPos.y - dy * scale;
        
        // Reset velocity when performing emergency correction to avoid oscillation
        cameraVel.x = 0;
        cameraVel.y = 0;
      }
      
      // Manual zoom blending is now handled in the framing controller
      // This is a cleaner architecture where the framing controller decides the
      // target FOV and the camera solver just applies physics to reach it
      
      // Implement proper spring physics for FOV as specified in CAMERA.md
      // k = stiffness(zoomLevel)
      // c = 2√k (critical damping)
      // a = k * (goal - pos) - c * vel
      // vel_new = vel + a * dt
      // pos_new = pos + vel_new * dt

      // Initialize FOV velocity if not exists
      if (typeof cameraFOVVel === 'undefined') {
        cameraFOVVel = 0;
      }

      // Use the same zoom alpha calculation for FOV as we did for position
      // Using the same zoomAlpha variable already calculated above
      
      // Critical damping coefficient - reuse the same constants
      const cFOV = 2 * Math.sqrt(kFOV);
      
      // Calculate acceleration
      const a = kFOV * (targetFOV - cameraFOV) - cFOV * cameraFOVVel;
      
      // Update velocity and position
      cameraFOVVel = cameraFOVVel + a * dt;
      cameraFOV = cameraFOV + cameraFOVVel * dt;
      
      // Apply safety limits to FOV
      cameraFOV = Math.max(baseZoom, Math.min(zoomMax, cameraFOV));
      
      // Calculate bearing, ensuring it doesn't swing wildly
      let bearing;
      try {
        bearing = calculateBearing([cameraPos.x, cameraPos.y], [targetPos.x, targetPos.y]);
      } catch (e) {
        // If calculation fails, maintain current bearing
        bearing = map.getBearing();
      }
      
      // FOV was already updated earlier in the function
      
      // Improved conversion from FOV to mapbox zoom level
      // With our new settings (FOV 50-75)
      // FOV 50 -> zoom 18, FOV 75 -> zoom 14
      const zoom = 22 - ((cameraFOV - 40) / 5);
      
      // Convert to map coordinates
      return {
        center: [cameraPos.x, cameraPos.y],
        bearing: bearing,
        pitch: cameraAngle,
        zoom: zoom
      };
    }
    
    // Get biker position on screen
    function getBikerScreenPosition() {
      // Safety check
      if (!map || !map.getSource('point')) return null;
      
      try {
        // Get the rider's current position
        const pointSource = map.getSource('point');
        if (!pointSource || !pointSource._data) return null;
        
        const pointFeature = pointSource._data;
        if (!pointFeature || !pointFeature.geometry || !pointFeature.geometry.coordinates) return null;
      
        const riderCoords = pointFeature.geometry.coordinates;
        
        // Convert rider coordinates to screen coordinates
        return map.project(riderCoords);
      } catch (e) {
        console.warn('Error getting rider screen position:', e);
        return null;
      }
    }
    
    // Clean, optimized animation function that implements the architecture from CAMERA.md
    function animateRoute() {
      // Safety check to avoid errors if route data isn't loaded
      if (!routeCoordinates || routeCoordinates.length === 0 || !routeDistances || routeDistances.length === 0) {
        pauseAnimation();
        console.warn('No route coordinates available for animation');
        return;
      }
      
      // Check if we've reached the end of the route
      if (currentRouteDistance >= routeDistances[routeDistances.length - 1] * 1000) { // Convert km to m
        pauseAnimation();
        // Reset button text to "Start" when animation completes
        const toggleBtn = document.getElementById('toggle-btn');
        if (toggleBtn) toggleBtn.textContent = "Start";
        
        // Ensure map interactions are re-enabled at the end of animation
        map.dragPan.enable();
        map.scrollZoom.enable();
        map.doubleClickZoom.enable();
        map.touchZoomRotate.enable();
        
        // Enable position slider
        const positionSlider = document.getElementById('position-slider');
        if (positionSlider) positionSlider.disabled = false;
        
        return;
      }
      
      // Speed in meters per frame - consistent regardless of point spacing
      // animationSpeed is a multiplier (0.1 to 1.0)
      // Base speed of 5 meters per frame * speed multiplier
      const distanceIncrement = 5 * animationSpeed;
      
      // Update current distance along route
      currentRouteDistance += distanceIncrement;
      
      // Convert to km for route lookup
      const currentDistanceKm = currentRouteDistance / 1000;
      
      // Get segment using the route
      const riderSegment = calculateSegmentForDistance(currentDistanceKm, false);
      const riderBeforeIdx = riderSegment.beforeIdx;
      const riderAfterIdx = riderSegment.afterIdx;
      const riderFraction = riderSegment.fraction;
      
      // Get the points for rider interpolation
      const riderBeforePoint = routeCoordinates[riderBeforeIdx];
      const riderAfterPoint = routeCoordinates[riderAfterIdx];
      
      // Create interpolated point for the rider position
      const interpolatedPoint = [
        riderBeforePoint[0] + (riderAfterPoint[0] - riderBeforePoint[0]) * riderFraction,
        riderBeforePoint[1] + (riderAfterPoint[1] - riderBeforePoint[1]) * riderFraction
      ];
      
      // Include elevation if available
      if (riderBeforePoint.length > 2 && riderAfterPoint.length > 2) {
        interpolatedPoint[2] = riderBeforePoint[2] + (riderAfterPoint[2] - riderBeforePoint[2]) * riderFraction;
      } else {
        interpolatedPoint[2] = 0;
      }
      
      // Update the rider marker position
      updatePointPosition(interpolatedPoint);
      
      // Update tracking information for UI display
      currentPoint = riderBeforeIdx;
      currentPointFloat = riderBeforeIdx + riderFraction;
      
      // Calculate the bearing between current and next point
      const bearing = calculateBearing(riderBeforePoint, riderAfterPoint);
      
      // ===== CAMERA SYSTEM ARCHITECTURE PER CAMERA.md =====
      
      // 1. BIKER STATE
      const bikerPos = {
        x: interpolatedPoint[0],
        y: interpolatedPoint[1],
        z: interpolatedPoint[2]
      };
      
      // Calculate velocity with robust safety checks
      // Get the next point to determine direction, handling edge cases
      const lookAheadIdx = Math.min(riderAfterIdx + 1, routeCoordinates.length - 1);
      const nextPoint = routeCoordinates[lookAheadIdx];
      
      let bikerVel;
      // Safety check for valid points
      if (!nextPoint || !Array.isArray(nextPoint) || nextPoint.length < 2 || 
          !interpolatedPoint || !Array.isArray(interpolatedPoint) || interpolatedPoint.length < 2) {
        console.warn('Invalid points for velocity calculation');
        // Provide a safe default velocity
        bikerVel = { x: 0, y: 0, z: 0 };
      } else {
        // Calculate velocity with scaled magnitude
        const dx = nextPoint[0] - interpolatedPoint[0];
        const dy = nextPoint[1] - interpolatedPoint[1];
        const dz = (nextPoint.length > 2 && interpolatedPoint.length > 2) ? 
                    (nextPoint[2] - interpolatedPoint[2]) : 0;
        
        // Scale velocity by animation speed, but keep it reasonable
        const scaleFactor = Math.min(1.0, animationSpeed) * 0.0005;
        
        bikerVel = {
          x: dx * scaleFactor,
          y: dy * scaleFactor,
          z: dz * scaleFactor
        };
      }
      
      // 2. TARGET-POINT MODULE
      const targetPoint = calculateTargetPoint(bikerPos, bikerVel);
      
      // 3. FRAMING CONTROLLER
      const bikerScreenPos = getBikerScreenPosition();
      framingController(bikerScreenPos);
      
      // 4. CAMERA SOLVER
      const newCameraState = updateCameraPhysics(targetPoint, zoomGoal);
      
      // Apply the new camera state
      map.jumpTo(newCameraState);
      
      // Update UI elements
      updateProgress();
      
      // Continue animation
      animationId = requestAnimationFrame(animateRoute);
    }
    
    // Helper functions and UI-related code (mostly unchanged)
    
    // Update progress and UI
    function updateProgress() {
      if (routeCoordinates.length === 0 || routeDistances.length === 0) return;
      
      // Calculate progress percentage based on distance
      const totalDistanceMeters = routeDistances[routeDistances.length - 1] * 1000; // km to m
      const progress = currentRouteDistance / totalDistanceMeters;
      
      // Update progress element
      const progressEl = document.getElementById('progress');
      progressEl.textContent = `${Math.round(progress * 100)}%`;
      
      // Update distance traveled
      const distanceTraveledEl = document.getElementById('distance-traveled');
      distanceTraveledEl.textContent = `${(currentRouteDistance / 1000).toFixed(1)} km`;
      
      // Update position slider without triggering its change event
      const positionSlider = document.getElementById('position-slider');
      positionSlider.value = progress * 100;
      
      // Update elevation marker
      updateElevationMarker(progress);
      
      // Get current and next points for interpolation
      const currentIdx = Math.floor(currentPointFloat);
      const nextIdx = Math.min(currentIdx + 1, routeCoordinates.length - 1);
      const pointFraction = currentPointFloat - currentIdx;
      
      // Get interpolated elevation
      let currentElevation;
      if (routeCoordinates[currentIdx].length > 2 && routeCoordinates[nextIdx].length > 2) {
        currentElevation = routeCoordinates[currentIdx][2] + 
                          (routeCoordinates[nextIdx][2] - routeCoordinates[currentIdx][2]) * pointFraction;
      } else {
        currentElevation = routeCoordinates[currentIdx][2] || 0;
      }
      
      const currentElevationEl = document.getElementById('current-elevation');
      currentElevationEl.textContent = `${Math.round(currentElevation)} m`;
      
      // Calculate gradient using about 100m look-behind distance
      // Find a point ~100m back from our current position
      let lookBehindDistance = Math.max(0, currentRouteDistance - 100); // meters
      let lookBehindDistanceKm = lookBehindDistance / 1000;
      let prevPointIdx = 0;
      
      // Find the closest point for our look-behind distance
      for (let i = 0; i < routeDistances.length; i++) {
        if (routeDistances[i] >= lookBehindDistanceKm) {
          prevPointIdx = Math.max(0, i - 1);
          break;
        }
      }
      
      // Calculate the elevation change over this distance
      const prevElevation = routeCoordinates[prevPointIdx][2] || 0;
      const elevationChange = currentElevation - prevElevation;
      
      // Calculate the actual distance between these points
      const actualDistance = (currentRouteDistance - (routeDistances[prevPointIdx] * 1000)); // in meters
      
      const currentGradientEl = document.getElementById('current-gradient');
      if (actualDistance > 10) { // Only calculate gradient if we have sufficient distance
        const gradient = (elevationChange / actualDistance) * 100;
        currentGradientEl.textContent = `${gradient.toFixed(1)}%`;
        
        // Change gradient text color based on steepness
        if (gradient > 8) {
          currentGradientEl.style.color = '#e74c3c'; // Steep - red
        } else if (gradient > 4) {
          currentGradientEl.style.color = '#f39c12'; // Moderate - orange
        } else if (gradient < -4) {
          currentGradientEl.style.color = '#2ecc71'; // Descent - green
        } else {
          currentGradientEl.style.color = '#2c3e50'; // Flat - default
        }
      }
    }
    
    // Update elevation marker on the profile
    function updateElevationMarker(progress) {
      const elevationMarker = document.getElementById('elevation-marker');
      if (!elevationMarker) return;
      
      const elevationProfile = document.querySelector('.elevation-profile');
      if (!elevationProfile) return;
      
      const profileWidth = elevationProfile.offsetWidth;
      const markerPosition = profileWidth * progress;
      
      elevationMarker.style.left = `${markerPosition}px`;
      elevationMarker.style.display = 'block';
    }
    
    // Add terrain and common sources/layers function
    function addTerrainAndSources(exaggerationValue = 1.0) {
      try {
        // Add terrain source if it doesn't exist
        if (!map.getSource('mapbox-dem')) {
          map.addSource('mapbox-dem', {
            'type': 'raster-dem',
            'url': 'mapbox://mapbox.mapbox-terrain-dem-v1',
            'tileSize': 512,
            'maxzoom': 14
          });
        }
        
        // Add sky layer if it doesn't exist
        if (!map.getLayer('sky')) {
          map.addLayer({
            'id': 'sky',
            'type': 'sky',
            'paint': {
              'sky-type': 'atmosphere',
              'sky-atmosphere-sun': [0.0, 0.0],
              'sky-atmosphere-sun-intensity': 15
            }
          });
        }
        
        // Use fixed 1.0 terrain exaggeration - no slider adjustment
        const exaggeration = exaggerationValue;
        
        // Add 3D terrain
        map.setTerrain({ 'source': 'mapbox-dem', 'exaggeration': exaggeration });
        
        // Add route source and layer if needed
        if (!map.getSource('route') && routeCoordinates.length > 0) {
          map.addSource('route', {
            type: 'geojson',
            data: {
              type: 'Feature',
              properties: {},
              geometry: {
                type: 'LineString',
                coordinates: routeCoordinates.map(coord => [coord[0], coord[1]])
              }
            }
          });
          
          map.addLayer({
            id: 'route',
            type: 'line',
            source: 'route',
            layout: {
              'line-join': 'round',
              'line-cap': 'round'
            },
            paint: {
              'line-color': '#3498db',
              'line-width': 5,
              'line-opacity': 0.8
            }
          });
        }
        
        // Add point source and layer if needed
        if (!map.getSource('point') && routeCoordinates.length > 0) {
          map.addSource('point', {
            type: 'geojson',
            data: {
              type: 'Feature',
              properties: {},
              geometry: {
                type: 'Point',
                coordinates: [routeCoordinates[currentPoint][0], routeCoordinates[currentPoint][1]]
              }
            }
          });
          
          map.addLayer({
            id: 'point',
            type: 'circle',
            source: 'point',
            paint: {
              'circle-radius': 8,
              'circle-color': '#e74c3c',
              'circle-stroke-width': 2,
              'circle-stroke-color': '#ffffff'
            }
          });
        }
        
        return true;
      } catch (e) {
        console.warn('Error adding terrain or sources:', e);
        return false;
      }
    }
    
    // Initialize the map
    function initMap() {
      map = new mapboxgl.Map({
        container: 'map',
        style: 'mapbox://styles/mapbox/satellite-streets-v12',
        center: [0, 0], // Will be updated when route is loaded
        zoom: 13,
        pitch: 50,
        bearing: 0,
        antialias: true, // Smoother lines
        attributionControl: false
      });
      
      // Add attribution separately to have more control over its position
      map.addControl(new mapboxgl.AttributionControl({
        compact: true
      }));
      
      // Add navigation controls
      map.addControl(new mapboxgl.NavigationControl(), 'top-right');
      
      // Initialize the camera position and velocity
      map.on('load', () => {
        cameraPos = {
          x: map.getCenter().lng,
          y: map.getCenter().lat,
          z: 0
        };
        cameraVel = { x: 0, y: 0, z: 0 };
        cameraFOV = baseZoom;
        cameraFOVVel = 0; // Initialize velocity for spring physics
      });
    }
    
    // Load a GPX route
    async function loadRoute(routeFile, applyHeightImmediately = false) {
      document.getElementById('loading').style.display = 'flex';
      
      try {
        const response = await axios.get(`gpx/${routeFile}`);
        const gpxData = response.data;
        
        // Parse GPX data
        const parser = new DOMParser();
        const gpx = parser.parseFromString(gpxData, 'text/xml');
        
        // Extract track points
        const trackPoints = gpx.querySelectorAll('trkpt');
        
        // Reset route data
        routeCoordinates = [];
        totalDistance = 0;
        routeDistances = [];
        
        // Extract elevation gain
        elevationGain = 0;
        let previousElevation = null;
        let minElevation = Infinity;
        let maxElevation = -Infinity;
        
        // Parse route coordinates and calculate cumulative distance
        for (let i = 0; i < trackPoints.length; i++) {
          const point = trackPoints[i];
          const lat = parseFloat(point.getAttribute('lat'));
          const lon = parseFloat(point.getAttribute('lon'));
          const ele = point.querySelector('ele');
          const elevation = ele ? parseFloat(ele.textContent) : 0;
          
          if (elevation < minElevation) minElevation = elevation;
          if (elevation > maxElevation) maxElevation = elevation;
          
          // Calculate elevation gain
          if (previousElevation !== null && elevation > previousElevation) {
            elevationGain += elevation - previousElevation;
          }
          previousElevation = elevation;
          
          const coordinate = [lon, lat, elevation];
          routeCoordinates.push(coordinate);
          
          // Calculate distance from previous point
          if (i > 0) {
            const prevPoint = [routeCoordinates[i-1][0], routeCoordinates[i-1][1]];
            const currentPoint = [lon, lat];
            const segmentDistance = turf.distance(turf.point(prevPoint), turf.point(currentPoint));
            totalDistance += segmentDistance;
          }
          
          // Store cumulative distance at each point (in kilometers)
          routeDistances.push(totalDistance);
        }
        
        // Calculate smoothed route coordinates for camera
        smoothedRouteCoordinates = createSmoothedRoute(routeCoordinates);
        
        // Calculate distances for smoothed route
        if (smoothedRouteCoordinates.length > 0) {
          let smoothedDistance = 0;
          smoothedRouteDistances = [0]; // First point has distance 0
          
          for (let i = 1; i < smoothedRouteCoordinates.length; i++) {
            const prevPoint = [smoothedRouteCoordinates[i-1][0], smoothedRouteCoordinates[i-1][1]];
            const currentPoint = [smoothedRouteCoordinates[i][0], smoothedRouteCoordinates[i][1]];
            const segmentDistance = turf.distance(turf.point(prevPoint), turf.point(currentPoint));
            smoothedDistance += segmentDistance;
            smoothedRouteDistances.push(smoothedDistance);
          }
        }
        
        // Initialize map and camera
        if (routeCoordinates.length > 0) {
          // Save total distance for progress calculations
          totalDistanceMeters = totalDistance * 1000; // km to meters
          
          // Update UI
          document.getElementById('total-distance').textContent = `${totalDistance.toFixed(1)} km`;
          document.getElementById('elevation-gain').textContent = `${Math.round(elevationGain)} m`;
          
          // Set map center to start of route
          map.flyTo({
            center: [routeCoordinates[0][0], routeCoordinates[0][1]],
            zoom: 13,
            pitch: cameraAngle,
            bearing: 0,
            duration: 1500
          });
          
          // Initialize camera position and state
          // Start with a good initial position slightly behind and above the route start
          if (routeCoordinates.length > 5) {
            // Calculate initial direction from first few points
            const startPoint = routeCoordinates[0];
            const aheadPoint = routeCoordinates[5];
            const initialBearing = calculateBearing(startPoint, aheadPoint);
            
            // Convert to radians for offset calculation
            const bearingRad = (initialBearing + 180) % 360 * Math.PI / 180;
            
            // Position camera slightly behind and above the start point
            cameraPos = {
              x: startPoint[0] - 0.0002 * Math.sin(bearingRad),
              y: startPoint[1] - 0.0002 * Math.cos(bearingRad),
              z: (startPoint[2] || 0) + verticalOffset
            };
            
            // Reset camera state
            cameraFOV = baseZoom;
            framingState = "IN_SAFE";
            zoomGoal = baseZoom;
          } else {
            // Fallback for routes with fewer points
            cameraPos = {
              x: routeCoordinates[0][0],
              y: routeCoordinates[0][1],
              z: (routeCoordinates[0][2] || 0) + verticalOffset
            };
          }
          
          // When map is ready, add terrain and layers
          map.once('moveend', () => {
            updateInitialMapView(applyHeightImmediately);
            
            // Draw elevation profile
            drawElevationProfile();
            
            // Hide loading spinner
            document.getElementById('loading').style.display = 'none';
            
            // Enable buttons
            document.getElementById('toggle-btn').disabled = false;
            document.getElementById('reset-btn').disabled = false;
          });
        }
      } catch (error) {
        console.error('Error loading GPX route:', error);
        document.getElementById('loading').style.display = 'none';
      }
    }
    
    // Update initial map view
    function updateInitialMapView(applyHeightImmediately = false) {
      if (!map || routeCoordinates.length === 0) return;
      
      // Add terrain and layers
      addTerrainAndSources(1.0);
      
      // Reset position
      currentPoint = 0;
      currentPointFloat = 0;
      currentRouteDistance = 0;
      
      // Update point position
      if (map.getSource('point')) {
        updatePointPosition(routeCoordinates[0]);
      }
      
      // Update camera position
      cameraPos = {
        x: routeCoordinates[0][0],
        y: routeCoordinates[0][1],
        z: routeCoordinates[0][2] || 0
      };
      
      // Reset velocity
      cameraVel = { x: 0, y: 0, z: 0 };
      cameraFOVVel = 0; // Reset FOV velocity for spring physics
      
      // Reset framing controller
      framingState = "IN_SAFE";
      stateTimer = 0;
      zoomGoal = baseZoom;
      
      // Update progress UI
      updateProgress();
    }
    
    // Draw elevation profile
    function drawElevationProfile() {
      const canvas = document.getElementById('elevation-canvas');
      if (!canvas || routeCoordinates.length === 0) return;
      
      const ctx = canvas.getContext('2d');
      const canvasWidth = canvas.clientWidth;
      const canvasHeight = canvas.clientHeight;
      
      // Set canvas dimensions to match display size
      canvas.width = canvasWidth;
      canvas.height = canvasHeight;
      
      // Clear canvas
      ctx.clearRect(0, 0, canvasWidth, canvasHeight);
      
      // Find min and max elevation
      let minEle = Infinity;
      let maxEle = -Infinity;
      
      for (const point of routeCoordinates) {
        if (point.length > 2) {
          minEle = Math.min(minEle, point[2]);
          maxEle = Math.max(maxEle, point[2]);
        }
      }
      
      // Add padding to elevation range
      const padding = (maxEle - minEle) * 0.1;
      minEle = Math.max(0, minEle - padding);
      maxEle = maxEle + padding;
      
      // Draw elevation profile
      ctx.beginPath();
      ctx.moveTo(0, canvasHeight);
      
      for (let i = 0; i < routeCoordinates.length; i++) {
        const x = (i / (routeCoordinates.length - 1)) * canvasWidth;
        const elevation = routeCoordinates[i].length > 2 ? routeCoordinates[i][2] : 0;
        const y = canvasHeight - ((elevation - minEle) / (maxEle - minEle)) * canvasHeight;
        
        if (i === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      }
      
      // Complete the path to the bottom of the canvas
      ctx.lineTo(canvasWidth, canvasHeight);
      ctx.lineTo(0, canvasHeight);
      
      // Fill the elevation profile
      const gradient = ctx.createLinearGradient(0, 0, 0, canvasHeight);
      gradient.addColorStop(0, 'rgba(46, 204, 113, 0.8)');
      gradient.addColorStop(1, 'rgba(52, 152, 219, 0.4)');
      
      ctx.fillStyle = gradient;
      ctx.fill();
      
      // Draw the profile line
      ctx.beginPath();
      for (let i = 0; i < routeCoordinates.length; i++) {
        const x = (i / (routeCoordinates.length - 1)) * canvasWidth;
        const elevation = routeCoordinates[i].length > 2 ? routeCoordinates[i][2] : 0;
        const y = canvasHeight - ((elevation - minEle) / (maxEle - minEle)) * canvasHeight;
        
        if (i === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      }
      
      ctx.strokeStyle = 'rgba(41, 128, 185, 0.8)';
      ctx.lineWidth = 2;
      ctx.stroke();
    }
    
    // Toggle animation
    function toggleAnimation() {
      const toggleBtn = document.getElementById('toggle-btn');
      if (animationId) {
        pauseAnimation();
        if (toggleBtn) toggleBtn.textContent = "Start";
      } else {
        startAnimation();
        if (toggleBtn) toggleBtn.textContent = "Pause";
      }
    }
    
    // Start animation
    function startAnimation() {
      if (animationId) return; // Already running
      
      // Disable interactions during animation
      map.dragPan.disable();
      map.scrollZoom.disable();
      map.doubleClickZoom.disable();
      map.touchZoomRotate.disable();
      
      // Disable position slider during animation
      document.getElementById('position-slider').disabled = true;
      
      // Enable reset button
      document.getElementById('reset-btn').disabled = false;
      
      // Start animation
      animationId = requestAnimationFrame(animateRoute);
    }
    
    // Pause animation
    function pauseAnimation() {
      if (animationId) {
        cancelAnimationFrame(animationId);
        animationId = null;
      }
      
      // Re-enable interactions
      map.dragPan.enable();
      map.scrollZoom.enable();
      map.doubleClickZoom.enable();
      map.touchZoomRotate.enable();
      
      // Enable position slider
      document.getElementById('position-slider').disabled = false;
    }
    
    // Reset animation
    function resetAnimation() {
      // Pause animation if running
      pauseAnimation();
      
      // Reset position
      currentPoint = 0;
      currentPointFloat = 0;
      currentRouteDistance = 0;
      
      // Update point position
      if (map.getSource('point')) {
        updatePointPosition(routeCoordinates[0]);
      }
      
      // Reset camera position
      cameraPos = {
        x: routeCoordinates[0][0],
        y: routeCoordinates[0][1],
        z: routeCoordinates[0][2] || 0
      };
      
      // Reset camera state
      cameraFOV = baseZoom;
      
      // Update camera position
      map.flyTo({
        center: [routeCoordinates[0][0], routeCoordinates[0][1]],
        zoom: 13,
        pitch: cameraAngle,
        bearing: 0,
        duration: 1000
      });
      
      // Reset framing controller
      framingState = "IN_SAFE";
      stateTimer = 0;
      zoomGoal = baseZoom;
      
      // Update progress UI
      updateProgress();
      
      // Reset button text
      const toggleBtn = document.getElementById('toggle-btn');
      if (toggleBtn) toggleBtn.textContent = "Start";
    }
    
    // Function to manually update position based on slider
    function updatePositionManually(positionPercent) {
      // Safety check
      if (!routeCoordinates || routeCoordinates.length === 0 || !routeDistances || routeDistances.length === 0) {
        return;
      }
      
      // Calculate the distance along the route
      const totalDistanceMeters = routeDistances[routeDistances.length - 1] * 1000; // km to m
      currentRouteDistance = positionPercent * totalDistanceMeters;
      
      // Convert current distance to km for comparison with routeDistances
      const currentDistanceKm = currentRouteDistance / 1000;
      
      // Get segment using the route
      const segment = calculateSegmentForDistance(currentDistanceKm, false);
      const beforeIdx = segment.beforeIdx;
      const afterIdx = segment.afterIdx;
      const fraction = segment.fraction;
      
      // Get the two points
      const beforePoint = routeCoordinates[beforeIdx];
      const afterPoint = routeCoordinates[afterIdx];
      
      // Create interpolated point
      const interpolatedPoint = [
        beforePoint[0] + (afterPoint[0] - beforePoint[0]) * fraction,
        beforePoint[1] + (afterPoint[1] - beforePoint[1]) * fraction
      ];
      
      // Include elevation if available
      if (beforePoint.length > 2 && afterPoint.length > 2) {
        interpolatedPoint[2] = beforePoint[2] + (afterPoint[2] - beforePoint[2]) * fraction;
      }
      
      // Update rider position
      updatePointPosition(interpolatedPoint);
      
      // Update current tracking point indices
      currentPoint = beforeIdx;
      currentPointFloat = beforeIdx + fraction;
      
      // Update UI
      updateProgress();
      
      // Update camera position
      // Calculate the bearing
      const bearing = calculateBearing(beforePoint, afterPoint);
      
      // Update biker position
      const bikerPos = {
        x: interpolatedPoint[0],
        y: interpolatedPoint[1],
        z: interpolatedPoint[2] || 0
      };
      
      // Calculate velocity based on next point
      const lookAheadIdx = Math.min(afterIdx + 1, routeCoordinates.length - 1);
      const nextPoint = routeCoordinates[lookAheadIdx];
      
      let bikerVel;
      // Safety check for valid points
      if (!nextPoint || !Array.isArray(nextPoint) || nextPoint.length < 2 || 
          !interpolatedPoint || !Array.isArray(interpolatedPoint) || interpolatedPoint.length < 2) {
        console.warn('Invalid points for velocity calculation in manual update');
        // Provide a safe default velocity
        bikerVel = { x: 0, y: 0, z: 0 };
      } else {
        // Calculate velocity with scaled magnitude
        const dx = nextPoint[0] - interpolatedPoint[0];
        const dy = nextPoint[1] - interpolatedPoint[1];
        const dz = (nextPoint.length > 2 && interpolatedPoint.length > 2) ? 
                    (nextPoint[2] - interpolatedPoint[2]) : 0;
        
        // Scale velocity for manual updates
        const scaleFactor = 0.0002;
        
        bikerVel = {
          x: dx * scaleFactor,
          y: dy * scaleFactor,
          z: dz * scaleFactor
        };
      }
      
      // Calculate target position
      const targetPoint = calculateTargetPoint(bikerPos, bikerVel);
      
      // Set the camera position directly for manual positioning
      cameraPos = {
        x: targetPoint.x,
        y: targetPoint.y,
        z: targetPoint.z
      };
      
      // Jump to the new position
      map.jumpTo({
        center: [targetPoint.x, targetPoint.y],
        zoom: 13,
        bearing: bearing,
        pitch: cameraAngle
      });
    }
    
    // Calculate bearing between two coordinates
    function calculateBearing(start, end) {
      // Safety check for invalid coordinates
      if (!start || !end || !Array.isArray(start) || !Array.isArray(end) || 
          start.length < 2 || end.length < 2) {
        console.warn('Invalid coordinates for bearing calculation:', start, end);
        return 0; // Default bearing
      }
      
      try {
        const startLat = start[1] * Math.PI / 180;
        const startLng = start[0] * Math.PI / 180;
        const endLat = end[1] * Math.PI / 180;
        const endLng = end[0] * Math.PI / 180;
        
        const y = Math.sin(endLng - startLng) * Math.cos(endLat);
        const x = Math.cos(startLat) * Math.sin(endLat) - 
                  Math.sin(startLat) * Math.cos(endLat) * Math.cos(endLng - startLng);
        
        const bearing = Math.atan2(y, x) * 180 / Math.PI;
        return (bearing + 360) % 360;
      } catch (e) {
        console.warn('Error calculating bearing:', e);
        return 0; // Default bearing on error
      }
    }
    
    // Event listeners
    document.addEventListener('DOMContentLoaded', () => {
      initMap();
      
      // DOM elements
      const routeSelect = document.getElementById('route-select');
      const heightControl = document.getElementById('camera-height');
      const angleControl = document.getElementById('camera-angle');
      const speedControl = document.getElementById('speed-control');
      const positionSlider = document.getElementById('position-slider');
      const toggleBtn = document.getElementById('toggle-btn');
      const resetBtn = document.getElementById('reset-btn');
      
      // Check URL parameters for requested route
      const initialRoute = parseUrlParams();
      
      // Load the initial route from URL parameter if available
      if (initialRoute) {
        loadRoute(initialRoute, true);
      }
      
      routeSelect.addEventListener('change', () => {
        loadRoute(routeSelect.value, true); // Apply camera height immediately on route change
        
        // Update URL hash to make the current route shareable
        window.location.hash = `route=${routeSelect.value}`;
      });
      
      toggleBtn.addEventListener('click', toggleAnimation);
      resetBtn.addEventListener('click', resetAnimation);
      
      // Camera height handler - updates view immediately
      heightControl.addEventListener('input', () => {
        cameraHeight = parseInt(heightControl.value);
        
        // Update UI only - the actual zoom behavior is now handled in the camera solver
        // to allow blending between automatic and manual control
        
        // If animation is not running, update the view immediately
        if (!animationId && routeCoordinates.length > 0) {
          // Calculate zoom level based on height slider
          const heightRatio = cameraHeight / 100;
          const targetFOV = baseZoom + ((zoomMax - baseZoom) * heightRatio);
          
          // Convert FOV to mapbox zoom
          const zoomLevel = 21 - ((targetFOV - 40) / 10);
          
          // Update the map view with new zoom
          map.easeTo({
            zoom: zoomLevel,
            pitch: cameraAngle,
            duration: 500
          });
        }
      });
      
      // Camera angle handler - updates view immediately
      angleControl.addEventListener('input', () => {
        // Invert the values - slider shows low to high (10-85)
        const sliderValue = parseInt(angleControl.value);
        
        // Calculate inverted angle - when slider is at min (10), we want max angle (85)
        // and vice versa
        cameraAngle = 95 - sliderValue; // 95 - 10 = 85, 95 - 85 = 10
        
        // If animation is not running, update the view immediately
        if (!animationId && routeCoordinates.length > 0) {
          updateInitialMapView();
        }
      });
      
      speedControl.addEventListener('input', () => {
        animationSpeed = parseFloat(speedControl.value);
      });
      
      // Position slider handler
      positionSlider.addEventListener('input', () => {
        // Only allow manual positioning when animation is not running
        if (!animationId) {
          const positionPercent = parseFloat(positionSlider.value) / 100;
          updatePositionManually(positionPercent);
        }
      });
    });
    
    // Function to parse URL parameters and hash fragments
    function parseUrlParams() {
      // Check for route parameter in the URL query string
      const urlParams = new URLSearchParams(window.location.search);
      const routeParam = urlParams.get('route');
      
      // Check for route in the hash fragment (e.g. #route=D1_East_Long.gpx)
      const hashParams = new URLSearchParams(window.location.hash.substring(1));
      const hashRoute = hashParams.get('route');
      
      // Use the parameter from query string or hash if available
      const requestedRoute = routeParam || hashRoute;
      
      if (requestedRoute) {
        // Find the matching option in the select element
        const options = Array.from(document.getElementById('route-select').options);
        const matchingOption = options.find(option => option.value === requestedRoute);
        
        if (matchingOption) {
          // Set the select element to the requested route
          document.getElementById('route-select').value = requestedRoute;
          return requestedRoute;
        }
      }
      
      // Return default route if no valid route parameter found
      return document.getElementById('route-select').value;
    }
  </script>
</body>
</html>