<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>King of the Road 2025 - Route Flyover</title>
  <link rel="stylesheet" href="https://unpkg.com/mapbox-gl@2.15.0/dist/mapbox-gl.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />
  <script src="https://unpkg.com/mapbox-gl@2.15.0/dist/mapbox-gl.js"></script>
  <script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>
  <script src="https://unpkg.com/axios/dist/axios.min.js"></script>
  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      background: #f9f9f9;
      color: #333;
    }
    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
      display: flex;
      flex-wrap: wrap;
      gap: 20px;
    }
    h1 {
      width: 100%;
      text-align: center;
      margin-bottom: 10px;
      color: #222;
    }
    #map {
      flex: 1;
      min-width: 700px;
      height: 600px;
      border-radius: 8px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.05);
    }
    .controls {
      width: 280px;
      padding: 15px;
      background: white;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.05);
      display: flex;
      flex-direction: column;
      gap: 20px;
    }
    select, button {
      padding: 10px 15px;
      border-radius: 5px;
      border: 1px solid #ddd;
      background: white;
      font-size: 14px;
      width: 100%;
    }
    button {
      background: linear-gradient(to bottom, #3498db, #2980b9);
      color: white;
      cursor: pointer;
      border: none;
      transition: all 0.2s;
      font-weight: 600;
    }
    button:hover {
      background: linear-gradient(to bottom, #2980b9, #2471a3);
      transform: translateY(-1px);
    }
    button:disabled {
      background: #ccc;
      cursor: not-allowed;
    }
    label {
      font-weight: 600;
      margin-bottom: 5px;
      display: block;
      color: #444;
    }
    .control-group {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .route-info {
      background: white;
      border-radius: 8px;
      padding: 15px;
      margin-top: 20px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    }
    .info-grid {
      display: flex;
      justify-content: space-between;
      flex-wrap: nowrap;
      gap: 15px;
      margin-top: 10px;
    }
    .info-item {
      flex: 1;
      text-align: center;
      padding: 12px;
      background: #f5f9ff;
      border-radius: 5px;
    }
    .info-label {
      font-size: 12px;
      color: #666;
      margin-bottom: 5px;
    }
    .info-value {
      font-size: 20px;
      font-weight: 600;
      color: #2c3e50;
    }
    .elevation-profile {
      width: 100%;
      height: 120px;
      background: white;
      margin-top: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.05);
      position: relative;
    }
    #elevation-canvas {
      width: 100%;
      height: 100%;
      border-radius: 8px;
    }
    .elevation-marker {
      position: absolute;
      top: 0;
      width: 2px;
      height: 120px;
      background: red;
      z-index: 10;
      pointer-events: none;
    }
    .loading {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(255,255,255,0.8);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }
    .loading-spinner {
      border: 5px solid #f3f3f3;
      border-top: 5px solid #3498db;
      border-radius: 50%;
      width: 50px;
      height: 50px;
      animation: spin 1s linear infinite;
      margin-bottom: 15px;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    .slider-container {
      margin-top: 5px;
    }
    .range-labels {
      display: flex;
      justify-content: space-between;
      font-size: 12px;
      color: #666;
      margin-top: 5px;
    }
    input[type="range"] {
      width: 100%;
      margin: 0;
      -webkit-appearance: none;
      appearance: none;
      height: 6px;
      background: #e0e0e0;
      border-radius: 3px;
      outline: none;
    }
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: #3498db;
      cursor: pointer;
      border: 2px solid white;
      box-shadow: 0 1px 3px rgba(0,0,0,0.2);
    }
    input[type="range"]::-moz-range-thumb {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: #3498db;
      cursor: pointer;
      border: 2px solid white;
      box-shadow: 0 1px 3px rgba(0,0,0,0.2);
    }
  </style>
</head>
<body>
  <div class="container">
    <div style="display: flex; justify-content: space-between; align-items: center; width: 100%; margin-bottom: 10px;">
      <a href="index.html" style="text-decoration: none; color: #3498db; display: flex; align-items: center;">
        <i class="fas fa-arrow-left" style="margin-right: 5px;"></i> Back to routes
      </a>
    </div>
    <h1>King of the Road 2025 - 3D Route Flyover</h1>
    
    <div class="controls">
      <div class="control-group">
        <label for="route-select">Select Route:</label>
        <select id="route-select">
          <option value="D0_Warm-up.gpx">Day 0 - Warm-up</option>
          <option value="D1_East Short.gpx">Day 1 - East (Short)</option>
          <option value="D1_East_Long.gpx">Day 1 - East (Long)</option>
          <option value="D2_North_Short.gpx">Day 2 - North (Short)</option>
          <option value="D2_North_Long.gpx">Day 2 - North (Long)</option>
          <option value="D3_West_Short.gpx">Day 3 - West (Short)</option>
          <option value="D3_West_Long.gpx">Day 3 - West (Long)</option>
        </select>
      </div>
      
      <div class="control-group">
        <label for="camera-height">Zoom:</label>
        <div class="slider-container">
          <input type="range" id="camera-height" min="1" max="100" step="1" value="25">
          <div class="range-labels">
            <span>In</span>
            <span>Out</span>
          </div>
        </div>
      </div>
      
      <div class="control-group">
        <label for="camera-angle">View Angle:</label>
        <div class="slider-container">
          <input type="range" id="camera-angle" min="10" max="85" step="1" value="45">
          <div class="range-labels">
            <span>Low</span>
            <span>High</span>
          </div>
        </div>
      </div>
      
      <div class="control-group">
        <label for="speed-control">Animation Speed:</label>
        <div class="slider-container">
          <input type="range" id="speed-control" min="0.1" max="1" step="0.1" value="0.5">
          <div class="range-labels">
            <span>Slow</span>
            <span>Fast</span>
          </div>
        </div>
      </div>
      
      <div class="control-group">
        <label for="position-slider">Position:</label>
        <div class="slider-container">
          <input type="range" id="position-slider" min="0" max="100" step="0.1" value="0">
          <div class="range-labels">
            <span>Start</span>
            <span>End</span>
          </div>
        </div>
      </div>
      
      <div class="control-group" style="margin-top: 10px;">
        <button id="toggle-btn">Start</button>
        <button id="reset-btn" disabled>Reset</button>
      </div>
    </div>
    
    <div id="map"></div>
    
    <div class="elevation-profile">
      <canvas id="elevation-canvas"></canvas>
      <div class="elevation-marker" id="elevation-marker" style="display: none;"></div>
    </div>
    
    <div class="route-info">
      <div class="info-header">
        <h3>Route Information</h3>
      </div>
      <div class="info-grid">
        <div class="info-item">
          <div class="info-label">Total Distance</div>
          <div class="info-value" id="total-distance">--</div>
        </div>
        <div class="info-item">
          <div class="info-label">Distance Traveled</div>
          <div class="info-value" id="distance-traveled">0.0 km</div>
        </div>
        <div class="info-item">
          <div class="info-label">Elevation Gain</div>
          <div class="info-value" id="elevation-gain">--</div>
        </div>
        <div class="info-item">
          <div class="info-label">Current Elevation</div>
          <div class="info-value" id="current-elevation">--</div>
        </div>
        <div class="info-item">
          <div class="info-label">Current Gradient</div>
          <div class="info-value" id="current-gradient">--</div>
        </div>
        <div class="info-item">
          <div class="info-label">Progress</div>
          <div class="info-value" id="progress">0%</div>
        </div>
      </div>
    </div>
  </div>
  
  <div class="loading" id="loading">
    <div class="loading-spinner"></div>
    <p>Loading route data...</p>
  </div>
  
  <script>
    // Replace with your Mapbox access token
    mapboxgl.accessToken = 'pk.eyJ1IjoiZWJvd21hbiIsImEiOiJjbWE1ZWVwdzYwODhwMmlzZnU4NTlyem1rIn0.E10X5hj2NTgViJexKpvrOg';
    
    // Global variables
    let map;
    let routeData = null;
    let animationId = null;
    let currentPoint = 0;
    let elevationProfile = [];
    let maxElevation = 0;
    let minElevation = Infinity;
    let totalDistance = 0;
    let elevationGain = 0;
    let routeCoordinates = [];
    let smoothedRouteCoordinates = []; // Smoothed version of coordinates for camera movement when zoomed out
    let routeDistances = []; // Array to store cumulative distances along route
    let smoothedRouteDistances = []; // Array to store distances for smoothed route
    let animationSpeed = 0.5;
    let cameraHeight = 25; // Default camera height (slider position, not actual meters)
    let cameraAngle = 50; // Default camera angle (pitch) in degrees (inverted from slider value of 45)
    let currentRouteDistance = 0; // Current distance along route in meters
    let totalDistanceMeters = 0; // Total distance of the route in meters
    let lastPreCalcHeight = 25; // Track the last height value used for calculation
    let prevBearing; // Track previous bearing for smoother camera movement
    
    // We've simplified the animation and removed pre-calculation 
    // to reduce potential causes of glitches
    
    // Function to create a smoothed version of the route with adaptive smoothing
    // This creates a path that is more smoothed when zoomed out, less when zoomed in
    function createSmoothedRoute(coordinates) {
      // Skip if too few points
      if (coordinates.length <= 10) return [...coordinates];
      
      // Create multiple levels of smoothing for different zoom levels
      // Level 1: Minimal smoothing (used when zoomed in)
      // Level 2: Moderate smoothing (used at medium zoom)
      // Level 3: Maximum smoothing (used when far zoomed out)
      
      // Determine base smoothing factor based on route length
      const baseSmoothing = Math.max(3, Math.floor(coordinates.length / 300));
      
      // Create smoothed route with variable smoothing, preserving elevation data
      const smoothed = [];
      
      // Always include the first point
      smoothed.push([...coordinates[0]]);
      
      // Add interior points with adaptive smoothing
      const skipFactor = Math.max(2, Math.ceil(coordinates.length / 1000)); // Skip more points on very long routes
      
      for (let i = skipFactor; i < coordinates.length - skipFactor; i += skipFactor) {
        // Variable smoothing window based on position in the route
        // Use wider window in the middle of the route, narrower at endpoints
        // This creates more natural behavior at route ends
        const positionFactor = Math.min(
          i / coordinates.length,
          (coordinates.length - i) / coordinates.length
        ) * 4;
        
        // Window size grows with position factor (larger in middle of route)
        const windowSize = Math.max(5, Math.round(baseSmoothing * (1 + positionFactor)));
        
        // Get weighted average of points in the smoothing window
        let sumLng = 0;
        let sumLat = 0;
        let sumEle = 0;
        let totalWeight = 0;
        
        // Use Gaussian-like weighting for smoother transitions
        for (let j = i - windowSize; j <= i + windowSize; j++) {
          if (j >= 0 && j < coordinates.length) {
            // Calculate distance-based weight with Gaussian falloff
            // This creates more natural curves than linear weighting
            const distFactor = Math.abs(i - j) / windowSize;
            const weight = Math.exp(-5 * distFactor * distFactor); // Gaussian-like falloff
            
            sumLng += coordinates[j][0] * weight;
            sumLat += coordinates[j][1] * weight;
            totalWeight += weight;
            
            // If elevation data exists, smooth it too
            if (coordinates[j].length > 2) {
              sumEle += coordinates[j][2] * weight;
            }
          }
        }
        
        // Create the smoothed point with normalized weights
        const smoothPoint = [
          sumLng / totalWeight,
          sumLat / totalWeight
        ];
        
        // Add elevation if it exists (slightly smoothed)
        if (coordinates[i].length > 2) {
          smoothPoint.push(sumEle / totalWeight);
        }
        
        smoothed.push(smoothPoint);
      }
      
      // Always include the last point
      smoothed.push([...coordinates[coordinates.length - 1]]);
      
      console.log(`Route smoothed from ${coordinates.length} to ${smoothed.length} points with adaptive smoothing`);
      return smoothed;
    }
    
    // Helper function to efficiently calculate segment data for any distance
    // Uses binary search for much faster lookups, important for smooth animation
    function calculateSegmentForDistance(distanceKm, useSmoothedRoute = false) {
      // Choose which route and distances to use based on zoom level
      const distances = useSmoothedRoute ? smoothedRouteDistances : routeDistances;
      
      let beforeIdx = 0;
      let afterIdx = 1;
      let fraction = 0;
      
      // Handle edge cases for start and end of route
      if (distanceKm <= distances[0]) {
        return { beforeIdx: 0, afterIdx: 1, fraction: 0 };
      }
      
      if (distanceKm >= distances[distances.length - 1]) {
        return { 
          beforeIdx: distances.length - 2, 
          afterIdx: distances.length - 1, 
          fraction: 1 
        };
      }
      
      // Binary search for faster lookup - critical for smooth animation
      let left = 0;
      let right = distances.length - 1;
      
      while (left <= right) {
        const mid = Math.floor((left + right) / 2);
        
        if (distances[mid] === distanceKm) {
          // Exact match
          beforeIdx = mid;
          afterIdx = Math.min(mid + 1, distances.length - 1);
          fraction = 0;
          break;
        }
        
        if (distances[mid] < distanceKm) {
          if (mid < distances.length - 1 && distances[mid + 1] > distanceKm) {
            // Found the segment
            beforeIdx = mid;
            afterIdx = mid + 1;
            break;
          }
          left = mid + 1;
        } else {
          right = mid - 1;
        }
      }
      
      // Calculate the interpolation fraction
      const segmentLength = distances[afterIdx] - distances[beforeIdx];
      if (segmentLength > 0) {
        fraction = (distanceKm - distances[beforeIdx]) / segmentLength;
        fraction = Math.max(0, Math.min(1, fraction));
      }
      
      return { beforeIdx, afterIdx, fraction };
    }
    
    // DOM Elements
    const routeSelect = document.getElementById('route-select');
    const toggleBtn = document.getElementById('toggle-btn');
    const resetBtn = document.getElementById('reset-btn');
    const speedControl = document.getElementById('speed-control');
    const heightControl = document.getElementById('camera-height');
    const angleControl = document.getElementById('camera-angle');
    const positionSlider = document.getElementById('position-slider');
    const elevationCanvas = document.getElementById('elevation-canvas');
    const elevationMarker = document.getElementById('elevation-marker');
    const totalDistanceEl = document.getElementById('total-distance');
    const distanceTraveledEl = document.getElementById('distance-traveled');
    const elevationGainEl = document.getElementById('elevation-gain');
    const currentElevationEl = document.getElementById('current-elevation');
    const currentGradientEl = document.getElementById('current-gradient');
    const progressEl = document.getElementById('progress');
    const loadingEl = document.getElementById('loading');
    
    // Initialize map
    function initMap() {
      map = new mapboxgl.Map({
        container: 'map',
        style: 'mapbox://styles/mapbox/satellite-streets-v12', // Fixed to Satellite with street overlay
        center: [14.5, 46.05], // Ljubljana, Slovenia
        zoom: 11,
        pitch: 45,
        bearing: 0,
        maxPitch: 85 // Allow a higher maximum pitch for better forward visibility
      });
      
      // Global flag to track initialization
      let mapInitialized = false;
      
      // Add terrain for 3D hills after style loads with fixed 1x exaggeration
      map.on('style.load', () => {
        addTerrainAndSources(1.0); // Lock terrain exaggeration to 1.0x
      });
      
      map.on('load', () => {
        // Initial terrain setup
        addTerrainAndSources();
        
        mapInitialized = true;
      });
      
      // Handle source errors by adding an error handler
      map.on('error', (e) => {
        // Only log to console, don't alert the user for common map errors
        if (e.error && e.error.message && e.error.message.includes('There is already a source with this ID')) {
          console.warn('Map source already exists - this is normal during style changes:', e.error.message);
        } else {
          console.error('Map error:', e.error);
        }
      });
    }
    
    // Load GPX route
    async function loadRoute(routeFile, applyInitialView = false) {
      loadingEl.style.display = 'flex';
      
      try {
        const response = await fetch(`gpx/${routeFile}`);
        const gpxData = await response.text();
        
        // Parse GPX
        const parser = new DOMParser();
        const gpx = parser.parseFromString(gpxData, 'text/xml');
        const trackPoints = gpx.querySelectorAll('trkpt');
        
        // Extract coordinates and elevation
        routeCoordinates = [];
        elevationProfile = [];
        maxElevation = 0;
        minElevation = Infinity;
        let prevElevation = null;
        elevationGain = 0;
        
        trackPoints.forEach(point => {
          const lat = parseFloat(point.getAttribute('lat'));
          const lon = parseFloat(point.getAttribute('lon'));
          let ele = 0;
          
          const eleTag = point.querySelector('ele');
          if (eleTag && eleTag.textContent) {
            ele = parseFloat(eleTag.textContent);
          }
          
          if (ele > maxElevation) maxElevation = ele;
          if (ele < minElevation) minElevation = ele;
          
          if (prevElevation !== null && ele > prevElevation) {
            elevationGain += (ele - prevElevation);
          }
          
          prevElevation = ele;
          
          routeCoordinates.push([lon, lat, ele]);
          elevationProfile.push(ele);
        });
        
        // Calculate segment distances and cumulative distances
        totalDistance = 0;
        routeDistances = [0]; // Start with 0 for the first point
        
        for (let i = 1; i < routeCoordinates.length; i++) {
          const from = turf.point([routeCoordinates[i-1][0], routeCoordinates[i-1][1]]);
          const to = turf.point([routeCoordinates[i][0], routeCoordinates[i][1]]);
          const segmentDistance = turf.distance(from, to, {units: 'kilometers'});
          totalDistance += segmentDistance;
          // Store cumulative distance at each point in kilometers
          routeDistances.push(totalDistance);
        }
        
        // Set the global total distance in meters
        totalDistanceMeters = totalDistance * 1000;
        
        // Create a simplified version of the route for smooth camera movement when zoomed out
        smoothedRouteCoordinates = createSmoothedRoute(routeCoordinates);
        
        // Calculate distances for the smoothed route
        let smoothedTotalDistance = 0;
        smoothedRouteDistances = [0]; // Start with 0
        
        for (let i = 1; i < smoothedRouteCoordinates.length; i++) {
          const from = turf.point([smoothedRouteCoordinates[i-1][0], smoothedRouteCoordinates[i-1][1]]);
          const to = turf.point([smoothedRouteCoordinates[i][0], smoothedRouteCoordinates[i][1]]);
          const segmentDistance = turf.distance(from, to, {units: 'kilometers'});
          smoothedTotalDistance += segmentDistance;
          smoothedRouteDistances.push(smoothedTotalDistance);
        }
        
        // Update route on map
        const geojson = {
          type: 'Feature',
          properties: {},
          geometry: {
            type: 'LineString',
            coordinates: routeCoordinates.map(coord => [coord[0], coord[1]])
          }
        };
        
        // Check if source exists before updating
        try {
          if (map.getSource('route')) {
            map.getSource('route').setData(geojson);
          } else {
            // Add source and layer if they don't exist yet
            map.addSource('route', {
              type: 'geojson',
              data: geojson
            });
            
            map.addLayer({
              id: 'route',
              type: 'line',
              source: 'route',
              layout: {
                'line-join': 'round',
                'line-cap': 'round'
              },
              paint: {
                'line-color': '#3498db',
                'line-width': 5,
                'line-opacity': 0.8
              }
            });
          }
          
          // Initialize or update point location
          if (map.getSource('point')) {
            updatePointPosition(routeCoordinates[0]);
          } else {
            map.addSource('point', {
              type: 'geojson',
              data: {
                type: 'Feature',
                properties: {},
                geometry: {
                  type: 'Point',
                  coordinates: [routeCoordinates[0][0], routeCoordinates[0][1]]
                }
              }
            });
            
            map.addLayer({
              id: 'point',
              type: 'circle',
              source: 'point',
              paint: {
                'circle-radius': 8,
                'circle-color': '#e74c3c',
                'circle-stroke-width': 2,
                'circle-stroke-color': '#ffffff'
              }
            });
          }
        } catch (e) {
          console.warn('Had to wait for map style to load:', e);
          
          // Wait for style to load and retry
          map.once('style.load', () => {
            // Add terrain, sources and layers again
            addTerrainAndSources();
            
            // Now try to update data again
            if (map.getSource('route')) {
              map.getSource('route').setData(geojson);
            }
            
            if (map.getSource('point')) {
              updatePointPosition(routeCoordinates[0]);
            }
          });
        }
        
        // Fit map to route
        const bounds = new mapboxgl.LngLatBounds();
        routeCoordinates.forEach(coord => {
          bounds.extend([coord[0], coord[1]]);
        });
        map.fitBounds(bounds, { padding: 50 });
        
        // Update UI
        totalDistanceEl.textContent = `${totalDistance.toFixed(1)} km`;
        elevationGainEl.textContent = `${elevationGain.toFixed(0)} m`;
        
        // Draw elevation profile
        drawElevationProfile();
        
        // Reset animation
        resetAnimation();
        
        // Reset button text and position slider
        toggleBtn.textContent = "Start";
        positionSlider.value = 0;
        
        // Pre-calculate route data for smooth animation
        preCalculateRouteData();
        
        // If requested, apply camera height to initial view
        if (applyInitialView) {
          updateInitialMapView();
        }
        
        // Hide loading
        loadingEl.style.display = 'none';
      } catch (error) {
        console.error('Error loading route:', error);
        alert('Error loading route data. Please try again.');
        loadingEl.style.display = 'none';
      }
    }
    
    // Draw elevation profile
    function drawElevationProfile() {
      const ctx = elevationCanvas.getContext('2d');
      const width = elevationCanvas.clientWidth;
      const height = elevationCanvas.clientHeight;
      
      // Set canvas dimensions
      elevationCanvas.width = width;
      elevationCanvas.height = height;
      
      // Clear canvas
      ctx.clearRect(0, 0, width, height);
      
      // Calculate elevation range with padding
      const padding = (maxElevation - minElevation) * 0.1;
      const elevationMin = Math.max(0, minElevation - padding);
      const elevationMax = maxElevation + padding;
      const elevationRange = elevationMax - elevationMin;
      
      // Draw profile
      ctx.beginPath();
      ctx.moveTo(0, height - ((elevationProfile[0] - elevationMin) / elevationRange * height));
      
      for (let i = 1; i < elevationProfile.length; i++) {
        const x = i / (elevationProfile.length - 1) * width;
        const y = height - ((elevationProfile[i] - elevationMin) / elevationRange * height);
        ctx.lineTo(x, y);
      }
      
      // Close path at bottom
      ctx.lineTo(width, height);
      ctx.lineTo(0, height);
      ctx.closePath();
      
      // Fill gradient
      const gradient = ctx.createLinearGradient(0, 0, 0, height);
      gradient.addColorStop(0, 'rgba(231, 76, 60, 0.7)');
      gradient.addColorStop(0.5, 'rgba(41, 128, 185, 0.5)');
      gradient.addColorStop(1, 'rgba(41, 128, 185, 0.2)');
      ctx.fillStyle = gradient;
      ctx.fill();
      
      // Draw outline
      ctx.beginPath();
      ctx.moveTo(0, height - ((elevationProfile[0] - elevationMin) / elevationRange * height));
      
      for (let i = 1; i < elevationProfile.length; i++) {
        const x = i / (elevationProfile.length - 1) * width;
        const y = height - ((elevationProfile[i] - elevationMin) / elevationRange * height);
        ctx.lineTo(x, y);
      }
      
      ctx.strokeStyle = '#3498db';
      ctx.lineWidth = 2;
      ctx.stroke();
      
      // Draw axes
      ctx.beginPath();
      ctx.moveTo(0, height);
      ctx.lineTo(width, height);
      ctx.strokeStyle = '#aaa';
      ctx.lineWidth = 1;
      ctx.stroke();
      
      // Draw labels
      ctx.fillStyle = '#666';
      ctx.font = '10px sans-serif';
      ctx.fillText(`${Math.round(elevationMin)}m`, 5, height - 5);
      ctx.fillText(`${Math.round(elevationMax)}m`, 5, 15);
      ctx.fillText('0 km', 5, height - 20);
      ctx.fillText(`${totalDistance.toFixed(1)} km`, width - 40, height - 20);
    }
    
    // Update elevation marker
    function updateElevationMarker(progress) {
      const width = elevationCanvas.clientWidth;
      const position = progress * width;
      
      elevationMarker.style.display = 'block';
      elevationMarker.style.left = `${position}px`;
    }
    
    // Variable to track animation state
    let animationStopped = false;
    
    // Toggle animation (start/pause/resume)
    function toggleAnimation() {
      // Check if animation is currently running
      const isAnimationRunning = !!animationId;
      
      if (isAnimationRunning) {
        // If running, pause the animation
        pauseAnimation();
      } else {
        // If not running, start or resume the animation
        startAnimation();
      }
    }
    
    // Start or resume animation
    function startAnimation() {
      // Cancel any existing animation (just to be safe)
      if (animationId) {
        cancelAnimationFrame(animationId);
        animationId = null;
      }
      
      // Safety check for route data
      if (!routeCoordinates || routeCoordinates.length === 0) {
        console.warn('Cannot start animation: No route data loaded');
        alert('Please select a route first');
        return;
      }
      
      // Disable map interactions during animation
      map.dragPan.disable();
      map.scrollZoom.disable();
      map.doubleClickZoom.disable();
      map.touchZoomRotate.disable();
      
      // Update button states
      toggleBtn.textContent = "Pause";
      resetBtn.disabled = false;
      positionSlider.disabled = true;
      
      // Reset to beginning if at end of route
      if (currentRouteDistance >= routeDistances[routeDistances.length - 1] * 1000) {
        currentPoint = 0;
        currentPointFloat = 0;
        currentRouteDistance = 0;
        animationStopped = false;
      }
      
      // Only reset camera position if starting a new animation, not resuming from pause
      // This ensures smooth transitions when resuming animation after using the slider
      if (routeCoordinates.length > 0 && !animationStopped) {
        // For brand new animation (not resume), initialize camera position
        currentCameraPos = { 
          lng: routeCoordinates[currentPoint][0], 
          lat: routeCoordinates[currentPoint][1] 
        };
        targetCameraPos = { 
          lng: routeCoordinates[currentPoint][0], 
          lat: routeCoordinates[currentPoint][1] 
        };
        
        // Calculate initial bearing if we have enough points
        if (routeCoordinates.length > currentPoint + 1) {
          const bearing = calculateBearing(
            routeCoordinates[currentPoint], 
            routeCoordinates[Math.min(currentPoint + 5, routeCoordinates.length - 1)]
          );
          currentCameraBearing = bearing;
          targetCameraBearing = bearing;
        } else {
          currentCameraBearing = 0;
          targetCameraBearing = 0;
        }
        
        // Reset the look-ahead index
        lastLookAheadIndex = currentPoint;
      }
      // When resuming from a pause (especially after slider adjustments),
      // we don't reset camera position as it would cause a jump
      
      // Clear the stopped flag when starting again
      animationStopped = false;
      
      // Start the animation
      animateRoute();
    }
    
    // Pause animation
    function pauseAnimation() {
      if (animationId) {
        cancelAnimationFrame(animationId);
        animationId = null;
      }
      
      // Re-enable map interactions when animation stops
      map.dragPan.enable();
      map.scrollZoom.enable();
      map.doubleClickZoom.enable();
      map.touchZoomRotate.enable();
      
      // Set the flag so we know animation was stopped mid-way
      animationStopped = true;
      
      // Update UI elements
      toggleBtn.textContent = "Resume";
      resetBtn.disabled = false;
      positionSlider.disabled = false;
    }
    
    // Reset animation
    function resetAnimation() {
      if (animationId) {
        cancelAnimationFrame(animationId);
        animationId = null;
      }
      
      // Ensure map interactions are enabled
      map.dragPan.enable();
      map.scrollZoom.enable();
      map.doubleClickZoom.enable();
      map.touchZoomRotate.enable();
      
      // Reset position counters
      currentPoint = 0;
      currentPointFloat = 0;
      currentRouteDistance = 0;
      
      // Clear tracking variables
      animationStopped = false;
      prevBearing = undefined; // Reset bearing history
      
      // Reset toggle button text
      toggleBtn.textContent = "Start";
      
      if (routeCoordinates.length > 0) {
        updatePointPosition(routeCoordinates[0]);
        
        // Reset camera and camera tracking variables
        currentCameraPos = { 
          lng: routeCoordinates[0][0], 
          lat: routeCoordinates[0][1] 
        };
        targetCameraPos = { 
          lng: routeCoordinates[0][0], 
          lat: routeCoordinates[0][1] 
        };
        currentCameraBearing = 0;
        targetCameraBearing = 0;
        lastLookAheadIndex = 0;
        
        // Use our new camera system for a smooth initial view
        const riderCoord = {
          lng: routeCoordinates[0][0],
          lat: routeCoordinates[0][1]
        };
        
        updateCamera(riderCoord, 0, {
          transitionDuration: 1500
        });
      }
      
      // Reset UI elements
      elevationMarker.style.display = 'none';
      distanceTraveledEl.textContent = '0.0 km';
      currentElevationEl.textContent = '–';
      currentGradientEl.textContent = '–';
      progressEl.textContent = '0%';
      positionSlider.value = 0;
      
      // Update button states
      toggleBtn.disabled = false;
      resetBtn.disabled = true;
      positionSlider.disabled = false;
    }
    
    // Function to update map view based on current camera height and angle
    function updateInitialMapView() {
      if (routeCoordinates.length === 0) return;
      
      // Convert slider value (1-100) to actual camera parameters
      // For a closer minimum zoom (2x closer) and less far maximum (2x closer)
      const sliderMin = 1;
      const sliderMax = 100;
      
      // Adjusted height range - making closest view much closer
      const actualMinHeight = 0.8;  // Much closer view (was 2.5m)
      const actualMaxHeight = 250;  // Keep this the same
      
      // Map slider value to actual height using exponential scale for better control
      // This gives finer control at closer distances
      const normalizedSliderValue = (cameraHeight - sliderMin) / (sliderMax - sliderMin);
      const actualHeight = actualMinHeight * Math.pow(actualMaxHeight / actualMinHeight, normalizedSliderValue);
      
      // Zoom range (higher number = closer)
      // Increase minimum zoom for a much closer view at minimum height
      const minZoom = 19.0; // Increased from 16.5 for a much closer view
      const maxZoom = 11.5; // Keep maximum zoom the same
      
      // Calculate zoom level (logarithmic scale)
      const zoomLevel = maxZoom + ((Math.log(actualMaxHeight) - Math.log(actualHeight)) / 
                                  (Math.log(actualMaxHeight) - Math.log(actualMinHeight))) * (minZoom - maxZoom);
      
      // Use the camera angle directly from the slider instead of calculating based on height
      const pitch = cameraAngle;
      
      // Apply the new view
      map.flyTo({
        center: [routeCoordinates[0][0], routeCoordinates[0][1]],
        zoom: zoomLevel,
        pitch: pitch,
        bearing: 0
      });
    }
    
    // Global variables for smooth camera system
    let currentCameraPos = { lng: 0, lat: 0 };
    let currentCameraBearing = 0;
    let currentCameraZoom = 15; // Default zoom level
    let currentCameraPitch = 45; // Default pitch (degrees)
    let currentCameraBearingRad = 0; // Bearing in radians
    
    // Add variable to track fractional position 
    let currentPointFloat = 0;
    
    // Variables for camera interpolation
    let cameraInterpolationActive = false;
    let cameraInterpolationStartTime = 0;
    let cameraInterpolationDuration = 0;
    let cameraStartPos = { lng: 0, lat: 0 };
    let cameraTargetPos = { lng: 0, lat: 0 };
    let cameraStartBearing = 0;
    let cameraTargetBearing = 0;
    let cameraStartPitch = 45;
    let cameraTargetPitch = 45;
    let cameraStartZoom = 13;
    let cameraTargetZoom = 13;
    
    // Clean, simplified animation function that uses our new camera system
    function animateRoute() {
      // Safety check to avoid errors if route data isn't loaded
      if (!routeCoordinates || routeCoordinates.length === 0 || !routeDistances || routeDistances.length === 0) {
        pauseAnimation();
        console.warn('No route coordinates available for animation');
        return;
      }
      
      // Check if we've reached the end of the route
      if (currentRouteDistance >= routeDistances[routeDistances.length - 1] * 1000) { // Convert km to m
        pauseAnimation();
        // Reset button text to "Start" when animation completes
        toggleBtn.textContent = "Start";
        animationStopped = false;
        
        // Ensure map interactions are re-enabled at the end of animation
        map.dragPan.enable();
        map.scrollZoom.enable();
        map.doubleClickZoom.enable();
        map.touchZoomRotate.enable();
        
        // Enable position slider
        positionSlider.disabled = false;
        
        return;
      }
      
      // Update the camera smoothly - always call this regardless of active flag
      updateCameraInterpolation();
      
      // Check if rider is visible and adjust camera if needed
      checkRiderVisibility();
      
      // Speed in meters per frame - consistent regardless of point spacing
      // animationSpeed is a multiplier (0.1 to 1.0)
      // Base speed of 5 meters per frame * speed multiplier
      const distanceIncrement = 5 * animationSpeed;
      
      // Update current distance along route
      currentRouteDistance += distanceIncrement;
      
      // Convert to km for route lookup
      const currentDistanceKm = currentRouteDistance / 1000;
      
      // Always use the detailed route for rider position
      const riderSegment = calculateSegmentForDistance(currentDistanceKm, false);
      const riderBeforeIdx = riderSegment.beforeIdx;
      const riderAfterIdx = riderSegment.afterIdx;
      const riderFraction = riderSegment.fraction;
      
      // Get the points for rider interpolation
      const riderBeforePoint = routeCoordinates[riderBeforeIdx];
      const riderAfterPoint = routeCoordinates[riderAfterIdx];
      
      // Create interpolated point for the rider position
      const interpolatedPoint = [
        riderBeforePoint[0] + (riderAfterPoint[0] - riderBeforePoint[0]) * riderFraction,
        riderBeforePoint[1] + (riderAfterPoint[1] - riderBeforePoint[1]) * riderFraction
      ];
      
      // Include elevation if available
      if (riderBeforePoint.length > 2 && riderAfterPoint.length > 2) {
        interpolatedPoint[2] = riderBeforePoint[2] + (riderAfterPoint[2] - riderBeforePoint[2]) * riderFraction;
      }
      
      // Update position
      updatePointPosition(interpolatedPoint);
      
      // Update tracking information
      currentPoint = riderBeforeIdx;
      currentPointFloat = riderBeforeIdx + riderFraction;
      
      // Get the rider's current position as a coordinate object
      const riderCoord = {
        lng: interpolatedPoint[0],
        lat: interpolatedPoint[1]
      };
      
      // Update camera position every frame if we're not in the middle of a smooth transition
      // This creates a butter-smooth camera that follows the rider
      if (!cameraInterpolationActive) {
        // Calculate the bearing between current and next point
        const nextBearing = calculateBearing(
          riderBeforePoint,
          riderAfterPoint
        );
        
        // Store for next frame
        currentCameraBearing = nextBearing;
        
        // Initiate camera update with the current parameters
        updateCamera(riderCoord, nextBearing, {
          // Use a consistent longer duration for smoother transitions
          transitionDuration: 2000
        });
      }
      
      // Update UI
      updateProgress();
      
      // Continue animation
      animationId = requestAnimationFrame(animateRoute);
    }
    
    // Calculate perpendicular offset for drone view
    function calculatePerpendicularOffset(point, bearing, distance) {
      // Convert bearing to radians and add 90 degrees to get perpendicular
      const perpBearing = ((bearing + 90) % 360) * Math.PI / 180;
      
      // Calculate offset
      return {
        lng: point.lng + distance * Math.sin(perpBearing),
        lat: point.lat + distance * Math.cos(perpBearing)
      };
    }
    
    // Update point position
    function updatePointPosition(coord) {
      // Safety check to prevent errors
      if (!coord || !Array.isArray(coord) || coord.length < 2) {
        console.warn('Invalid coordinate passed to updatePointPosition:', coord);
        return;
      }
      
      // Always use the detailed route for rider position
      const riderSegment = calculateSegmentForDistance(currentDistanceKm, false);
      const riderBeforeIdx = riderSegment.beforeIdx;
      const riderAfterIdx = riderSegment.afterIdx;
      const riderFraction = riderSegment.fraction;
      
      // Get the points for rider interpolation
      const riderBeforePoint = routeCoordinates[riderBeforeIdx];
      const riderAfterPoint = routeCoordinates[riderAfterIdx];
      
      // Create interpolated point for the rider position
      const interpolatedPoint = [
        riderBeforePoint[0] + (riderAfterPoint[0] - riderBeforePoint[0]) * riderFraction,
        riderBeforePoint[1] + (riderAfterPoint[1] - riderBeforePoint[1]) * riderFraction
      ];
      
      // Include elevation if available
      if (riderBeforePoint.length > 2 && riderAfterPoint.length > 2) {
        interpolatedPoint[2] = riderBeforePoint[2] + (riderAfterPoint[2] - riderBeforePoint[2]) * riderFraction;
      }
      
      // Update position
      updatePointPosition(interpolatedPoint);
      
      // Update tracking information
      currentPoint = riderBeforeIdx;
      currentPointFloat = riderBeforeIdx + riderFraction;
      
      // Get the rider's current position as a coordinate object
      const riderCoord = {
        lng: interpolatedPoint[0],
        lat: interpolatedPoint[1]
      };
      
      // Update camera position every frame if we're not in the middle of a smooth transition
      // This creates a butter-smooth camera that follows the rider
      if (!cameraInterpolationActive) {
        // Calculate the bearing between current and next points
        // This gives us the direction of travel
        let bearing = currentCameraBearing; // Use current bearing as fallback
        
        // Calculate bearing from current and next point
        const nextBearing = calculateBearing(
          riderBeforePoint,
          riderAfterPoint
        );
        
        // Use the newly calculated bearing
        bearing = nextBearing;
        
        // Store for next frame
        currentCameraBearing = bearing;
        
        // Initiate camera update with the current parameters
        updateCamera(riderCoord, bearing, {
          // Use a consistent longer duration for smoother transitions
          transitionDuration: 2000
        });
      }
      
      // Update UI
      updateProgress();
      
      // Continue animation
      animationId = requestAnimationFrame(animateRoute);
    }
    
    // Calculate perpendicular offset for drone view
    function calculatePerpendicularOffset(point, bearing, distance) {
      // Convert bearing to radians and add 90 degrees to get perpendicular
      const perpBearing = ((bearing + 90) % 360) * Math.PI / 180;
      
      // Calculate offset
      return {
        lng: point.lng + distance * Math.sin(perpBearing),
        lat: point.lat + distance * Math.cos(perpBearing)
      };
    }
    
    // Update point position
    function updatePointPosition(coord) {
      // Safety check to prevent errors
      if (!coord || !Array.isArray(coord) || coord.length < 2) {
        console.warn('Invalid coordinate passed to updatePointPosition:', coord);
        return;
      }
      
      const point = {
        type: 'Feature',
        properties: {},
        geometry: {
          type: 'Point',
          coordinates: [coord[0], coord[1]]
        }
      };
      
      // Check if the map and source exist before updating
      if (map && map.getSource('point')) {
        try {
          map.getSource('point').setData(point);
        } catch (e) {
          console.warn('Error updating point position:', e);
        }
      }
    }
    
    // Check if the rider marker is visible within the viewport's safe area
    // and make camera adjustments if needed, especially for downhill sections
    function checkRiderVisibility() {
      // Ensure map is initialized
      if (!map || !map.getSource('point')) return;
      
      try {
        // Get the current position of the rider marker
        const pointData = map.getSource('point')._data;
        if (!pointData || !pointData.geometry || !pointData.geometry.coordinates) return;
        
        // Convert the geographic coordinate to screen coordinates
        const riderPoint = map.project([
          pointData.geometry.coordinates[0], 
          pointData.geometry.coordinates[1]
        ]);
        
        // Get viewport dimensions
        const viewport = map.getContainer();
        const viewportWidth = viewport.offsetWidth;
        const viewportHeight = viewport.offsetHeight;
        
        // Define a safe area rectangle where the rider should remain visible
        // More generous safe area to avoid constant adjustments
        const safeArea = {
          left: viewportWidth * 0.25,    // 25% from left edge
          right: viewportWidth * 0.75,   // 75% from left edge (25% from right)
          top: viewportHeight * 0.4,     // 40% from top 
          bottom: viewportHeight * 0.9   // 90% from top (near bottom of screen)
        };
        
        // Check if the rider is outside the safe area
        const isRiderVisible = 
          riderPoint.x >= safeArea.left && 
          riderPoint.x <= safeArea.right && 
          riderPoint.y >= safeArea.top && 
          riderPoint.y <= safeArea.bottom;
        
        // If the rider is not visible in the safe area, adjust the camera target
        // This will be smoothly applied by our interpolation system
        if (!isRiderVisible) {
          // Get rider geographic coordinates
          const riderCoord = {
            lng: pointData.geometry.coordinates[0],
            lat: pointData.geometry.coordinates[1]
          };
          
          // Current values
          const currentBearing = map.getBearing();
          
          // Determine direction adjustments
          let lookAheadDistanceAdjust = 0;
          let sideDistanceAdjust = 0;
          
          // Horizontal adjustments (left-right)
          if (riderPoint.x < safeArea.left) {
            // Rider is too far left - adjust side offset
            sideDistanceAdjust = -1 * ((safeArea.left - riderPoint.x) / viewportWidth) * 0.05;
          } else if (riderPoint.x > safeArea.right) {
            // Rider is too far right - adjust side offset
            sideDistanceAdjust = ((riderPoint.x - safeArea.right) / viewportWidth) * 0.05;
          }
          
          // Vertical adjustments (top-bottom)
          if (riderPoint.y < safeArea.top) {
            // Rider is too high (near horizon) - decrease look-ahead, increase zoom
            lookAheadDistanceAdjust = -1 * ((safeArea.top - riderPoint.y) / viewportHeight) * 0.05;
            
            // Also adjust target zoom to come in closer
            const zoomAdjust = ((safeArea.top - riderPoint.y) / viewportHeight) * 0.5;
            cameraTargetZoom = Math.min(19, currentCameraZoom + zoomAdjust);
          } else if (riderPoint.y > safeArea.bottom) {
            // Rider is too low on screen - increase look-ahead, decrease zoom
            lookAheadDistanceAdjust = ((riderPoint.y - safeArea.bottom) / viewportHeight) * 0.05;
            
            // Also adjust target pitch to look more downward
            const pitchAdjust = ((riderPoint.y - safeArea.bottom) / viewportHeight) * 5;
            cameraTargetPitch = Math.min(85, currentCameraPitch + pitchAdjust);
          }
          
          // Apply adjustments to the target camera position
          // Our smooth camera system will gradually move to this target
          if (lookAheadDistanceAdjust !== 0 || sideDistanceAdjust !== 0) {
            // Get ideal camera position for current rider position and adjust it
            const idealCameraPos = calculateIdealCameraPosition(
              riderCoord, 
              currentBearing, 
              animationSpeed,
              cameraHeight, 
              cameraTargetPitch,
              sideDistanceAdjust, // Pass the side offset adjustment
              lookAheadDistanceAdjust // Pass the look-ahead adjustment
            );
            
            // Update the target position - our interpolation system will smoothly move there
            cameraTargetPos = idealCameraPos;
          }
        }
      } catch (e) {
        console.warn('Error checking rider visibility:', e);
      }
    }
    
    // Calculate bearing between two coordinates
    function calculateBearing(start, end) {
      // Safety check for invalid coordinates
      if (!start || !end || !Array.isArray(start) || !Array.isArray(end) || 
          start.length < 2 || end.length < 2) {
        console.warn('Invalid coordinates for bearing calculation:', start, end);
        return 0; // Default bearing
      }
      
      try {
        const startLat = start[1] * Math.PI / 180;
        const startLng = start[0] * Math.PI / 180;
        const endLat = end[1] * Math.PI / 180;
        const endLng = end[0] * Math.PI / 180;
        
        const y = Math.sin(endLng - startLng) * Math.cos(endLat);
        const x = Math.cos(startLat) * Math.sin(endLat) - 
                  Math.sin(startLat) * Math.cos(endLat) * Math.cos(endLng - startLng);
        
        const bearing = Math.atan2(y, x) * 180 / Math.PI;
        return (bearing + 360) % 360;
      } catch (e) {
        console.warn('Error calculating bearing:', e);
        return 0; // Default bearing on error
      }
    }
    
    // Update progress and UI
    function updateProgress() {
      if (routeCoordinates.length === 0 || routeDistances.length === 0) return;
      
      // Calculate progress percentage based on distance
      const totalDistanceMeters = routeDistances[routeDistances.length - 1] * 1000; // km to m
      const progress = currentRouteDistance / totalDistanceMeters;
      
      // Update progress element
      progressEl.textContent = `${Math.round(progress * 100)}%`;
      
      // Update distance traveled
      distanceTraveledEl.textContent = `${(currentRouteDistance / 1000).toFixed(1)} km`;
      
      // Update position slider without triggering its change event
      positionSlider.value = progress * 100;
      
      // Update elevation marker
      updateElevationMarker(progress);
      
      // Get current and next points for interpolation
      const currentIdx = Math.floor(currentPointFloat);
      const nextIdx = Math.min(currentIdx + 1, routeCoordinates.length - 1);
      const pointFraction = currentPointFloat - currentIdx;
      
      // Get interpolated elevation
      let currentElevation;
      if (routeCoordinates[currentIdx].length > 2 && routeCoordinates[nextIdx].length > 2) {
        currentElevation = routeCoordinates[currentIdx][2] + 
                          (routeCoordinates[nextIdx][2] - routeCoordinates[currentIdx][2]) * pointFraction;
      } else {
        currentElevation = routeCoordinates[currentIdx][2] || 0;
      }
      
      currentElevationEl.textContent = `${Math.round(currentElevation)} m`;
      
      // Calculate gradient using about 100m look-behind distance
      // Find a point ~100m back from our current position
      let lookBehindDistance = Math.max(0, currentRouteDistance - 100); // meters
      let lookBehindDistanceKm = lookBehindDistance / 1000;
      let prevPointIdx = 0;
      
      // Find the closest point for our look-behind distance
      for (let i = 0; i < routeDistances.length; i++) {
        if (routeDistances[i] >= lookBehindDistanceKm) {
          prevPointIdx = Math.max(0, i - 1);
          break;
        }
      }
      
      // Calculate the elevation change over this distance
      const prevElevation = routeCoordinates[prevPointIdx][2] || 0;
      const elevationChange = currentElevation - prevElevation;
      
      // Calculate the actual distance between these points
      const actualDistance = (currentRouteDistance - (routeDistances[prevPointIdx] * 1000)); // in meters
      
      if (actualDistance > 10) { // Only calculate gradient if we have sufficient distance
        const gradient = (elevationChange / actualDistance) * 100;
        currentGradientEl.textContent = `${gradient.toFixed(1)}%`;
        
        // Change gradient text color based on steepness
        if (gradient > 8) {
          currentGradientEl.style.color = '#e74c3c'; // Steep - red
        } else if (gradient > 4) {
          currentGradientEl.style.color = '#f39c12'; // Moderate - orange
        } else if (gradient < -4) {
          currentGradientEl.style.color = '#2ecc71'; // Descent - green
        } else {
          currentGradientEl.style.color = '#2c3e50'; // Flat - default
        }
        
        // We've removed the proactive camera adjustment from here and moved the logic
        // to our main animation loop with better handling of downhill sections
      }
    }
    
    // Add terrain and common sources/layers function
    function addTerrainAndSources(exaggerationValue = 1.0) {
      try {
        // Add terrain source if it doesn't exist
        if (!map.getSource('mapbox-dem')) {
          map.addSource('mapbox-dem', {
            'type': 'raster-dem',
            'url': 'mapbox://mapbox.mapbox-terrain-dem-v1',
            'tileSize': 512,
            'maxzoom': 14
          });
        }
        
        // Add sky layer if it doesn't exist
        if (!map.getLayer('sky')) {
          map.addLayer({
            'id': 'sky',
            'type': 'sky',
            'paint': {
              'sky-type': 'atmosphere',
              'sky-atmosphere-sun': [0.0, 0.0],
              'sky-atmosphere-sun-intensity': 15
            }
          });
        }
        
        // Use fixed 1.0 terrain exaggeration - no slider adjustment
        const exaggeration = exaggerationValue;
        
        // Add 3D terrain
        map.setTerrain({ 'source': 'mapbox-dem', 'exaggeration': exaggeration });
        
        // Success!
        return true;
      } catch (e) {
        console.warn('Error setting up terrain:', e);
        return false;
      }
    }
    
    // Terrain exaggeration is now fixed at 1.0x - function removed
    
    // Simple pre-calculation function to update the cached height value
    function preCalculateRouteData() {
      // Simply update the stored height value
      lastPreCalcHeight = cameraHeight;
      // All actual calculations are done in real-time during animation
    }
  
    // Helper function to get the current rider position on screen
    function getRiderScreenPosition() {
      // Safety check
      if (!map || !map.getSource('point')) return null;
      
      try {
        // Get the rider's current position
        const pointSource = map.getSource('point');
        if (!pointSource || !pointSource._data) return null;
        
        const pointFeature = pointSource._data;
        if (!pointFeature || !pointFeature.geometry || !pointFeature.geometry.coordinates) return null;
      
        const riderCoords = pointFeature.geometry.coordinates;
        
        // Convert rider coordinates to screen coordinates
        const riderScreenPoint = map.project(riderCoords);
        return riderScreenPoint;
      } catch (e) {
        console.warn('Error getting rider screen position:', e);
        return null;
      }
    }
    
    // Helper function to check if the rider is completely out of view
    function isRiderCompletelyOutOfView(riderPoint) {
      if (!riderPoint) return false;
      
      const viewport = map.getContainer();
      const viewportWidth = viewport.offsetWidth;
      const viewportHeight = viewport.offsetHeight;
      
      // Check if rider is completely off screen (more conservative check)
      return (
        riderPoint.x < 0 ||
        riderPoint.x > viewportWidth ||
        riderPoint.y < 0 ||
        riderPoint.y > viewportHeight
      );
    }
    
    // Helper function to adjust camera to keep rider visible
    function adjustCameraToKeepRiderVisible(riderPoint, aggressive = true) {
      if (!riderPoint) return;
      
      const viewport = map.getContainer();
      const viewportWidth = viewport.offsetWidth;
      const viewportHeight = viewport.offsetHeight;
      
      // Define the safe area based on whether we need aggressive adjustment
      const safeArea = aggressive ? {
        left: viewportWidth * 0.3,    // 30% from left
        right: viewportWidth * 0.7,   // 70% from left
        top: viewportHeight * 0.4,    // 40% from top
        bottom: viewportHeight * 0.8  // 80% from top
      } : {
        left: 20,                     // Just inside screen
        right: viewportWidth - 20,    // Just inside screen
        bottom: viewportHeight - 20,  // Just inside screen
        top: 20                       // Just inside screen
      };
      
      // Calculate adjustments
      let adjustX = 0;
      let adjustY = 0;
      
      if (riderPoint.x < safeArea.left) {
        adjustX = (riderPoint.x - safeArea.left) / viewportWidth;
      } else if (riderPoint.x > safeArea.right) {
        adjustX = (riderPoint.x - safeArea.right) / viewportWidth;
      }
      
      if (riderPoint.y < safeArea.top) {
        adjustY = (riderPoint.y - safeArea.top) / viewportHeight;
      } else if (riderPoint.y > safeArea.bottom) {
        adjustY = (riderPoint.y - safeArea.bottom) / viewportHeight;
      }
      
      // Get current camera settings
      const currentCenter = map.getCenter();
      const bearingRad = map.getBearing() * Math.PI / 180;
      
      // Rotate adjustment based on camera bearing
      const cosB = Math.cos(bearingRad);
      const sinB = Math.sin(bearingRad);
      const rotX = adjustX * cosB - adjustY * sinB;
      const rotY = adjustX * sinB + adjustY * cosB;
      
      // Apply adjustment
      const zoomFactor = Math.pow(0.5, map.getZoom() - 10);
      map.panBy([
        rotX * viewportWidth * (aggressive ? 0.5 : 0.3),
        rotY * viewportHeight * (aggressive ? 0.5 : 0.3)
      ], {
        duration: aggressive ? 500 : 1000
      });
    }
    
    // Calculate perpendicular offset for drone view
    function calculatePerpendicularOffset(point, bearing, distance) {
      // Convert bearing to radians and add 90 degrees to get perpendicular
      const perpBearing = ((bearing + 90) % 360) * Math.PI / 180;
      
      // Calculate offset
      return {
        lng: point.lng + distance * Math.sin(perpBearing),
        lat: point.lat + distance * Math.cos(perpBearing)
      };
    }
    
    // Update point position
    function updatePointPosition(coord) {
      // Safety check to prevent errors
      if (!coord || !Array.isArray(coord) || coord.length < 2) {
        console.warn('Invalid coordinate passed to updatePointPosition:', coord);
        return;
      }
      
      const point = {
        type: 'Feature',
        properties: {},
        geometry: {
          type: 'Point',
          coordinates: [coord[0], coord[1]]
        }
      };
      
      // Check if the map and source exist before updating
      if (map && map.getSource('point')) {
        try {
          map.getSource('point').setData(point);
        } catch (e) {
          console.warn('Error updating point position:', e);
        }
      }
    }
    
    
    // Calculate bearing between two coordinates
    function calculateBearing(start, end) {
      // Safety check for invalid coordinates
      if (!start || !end || !Array.isArray(start) || !Array.isArray(end) || 
          start.length < 2 || end.length < 2) {
        console.warn('Invalid coordinates for bearing calculation:', start, end);
        return 0; // Default bearing
      }
      
      try {
        const startLat = start[1] * Math.PI / 180;
        const startLng = start[0] * Math.PI / 180;
        const endLat = end[1] * Math.PI / 180;
        const endLng = end[0] * Math.PI / 180;
        
        const y = Math.sin(endLng - startLng) * Math.cos(endLat);
        const x = Math.cos(startLat) * Math.sin(endLat) - 
                  Math.sin(startLat) * Math.cos(endLat) * Math.cos(endLng - startLng);
        
        const bearing = Math.atan2(y, x) * 180 / Math.PI;
        return (bearing + 360) % 360;
      } catch (e) {
        console.warn('Error calculating bearing:', e);
        return 0; // Default bearing on error
      }
    }
    
    // Update progress and UI
    function updateProgress() {
      if (routeCoordinates.length === 0 || routeDistances.length === 0) return;
      
      // Calculate progress percentage based on distance
      const totalDistanceMeters = routeDistances[routeDistances.length - 1] * 1000; // km to m
      const progress = currentRouteDistance / totalDistanceMeters;
      
      // Update progress element
      progressEl.textContent = `${Math.round(progress * 100)}%`;
      
      // Update distance traveled
      distanceTraveledEl.textContent = `${(currentRouteDistance / 1000).toFixed(1)} km`;
      
      // Update position slider without triggering its change event
      positionSlider.value = progress * 100;
      
      // Update elevation marker
      updateElevationMarker(progress);
      
      // Get current and next points for interpolation
      const currentIdx = Math.floor(currentPointFloat);
      const nextIdx = Math.min(currentIdx + 1, routeCoordinates.length - 1);
      const pointFraction = currentPointFloat - currentIdx;
      
      // Get interpolated elevation
      let currentElevation;
      if (routeCoordinates[currentIdx].length > 2 && routeCoordinates[nextIdx].length > 2) {
        currentElevation = routeCoordinates[currentIdx][2] + 
                          (routeCoordinates[nextIdx][2] - routeCoordinates[currentIdx][2]) * pointFraction;
      } else {
        currentElevation = routeCoordinates[currentIdx][2] || 0;
      }
      
      currentElevationEl.textContent = `${Math.round(currentElevation)} m`;
      
      // Calculate gradient using about 100m look-behind distance
      // Find a point ~100m back from our current position
      let lookBehindDistance = Math.max(0, currentRouteDistance - 100); // meters
      let lookBehindDistanceKm = lookBehindDistance / 1000;
      let prevPointIdx = 0;
      
      // Find the closest point for our look-behind distance
      for (let i = 0; i < routeDistances.length; i++) {
        if (routeDistances[i] >= lookBehindDistanceKm) {
          prevPointIdx = Math.max(0, i - 1);
          break;
        }
      }
      
      // Calculate the elevation change over this distance
      const prevElevation = routeCoordinates[prevPointIdx][2] || 0;
      const elevationChange = currentElevation - prevElevation;
      
      // Calculate the actual distance between these points
      const actualDistance = (currentRouteDistance - (routeDistances[prevPointIdx] * 1000)); // in meters
      
      if (actualDistance > 10) { // Only calculate gradient if we have sufficient distance
        const gradient = (elevationChange / actualDistance) * 100;
        currentGradientEl.textContent = `${gradient.toFixed(1)}%`;
        
        // Change gradient text color based on steepness
        if (gradient > 8) {
          currentGradientEl.style.color = '#e74c3c'; // Steep - red
        } else if (gradient > 4) {
          currentGradientEl.style.color = '#f39c12'; // Moderate - orange
        } else if (gradient < -4) {
          currentGradientEl.style.color = '#2ecc71'; // Descent - green
        } else {
          currentGradientEl.style.color = '#2c3e50'; // Flat - default
        }
        
        // We've removed the proactive camera adjustment from here and moved the logic
        // to our main animation loop with better handling of downhill sections
      }
    }
    
    // Add terrain and common sources/layers function
    function addTerrainAndSources(exaggerationValue = 1.0) {
      try {
        // Add terrain source if it doesn't exist
        if (!map.getSource('mapbox-dem')) {
          map.addSource('mapbox-dem', {
            'type': 'raster-dem',
            'url': 'mapbox://mapbox.mapbox-terrain-dem-v1',
            'tileSize': 512,
            'maxzoom': 14
          });
        }
        
        // Add sky layer if it doesn't exist
        if (!map.getLayer('sky')) {
          map.addLayer({
            'id': 'sky',
            'type': 'sky',
            'paint': {
              'sky-type': 'atmosphere',
              'sky-atmosphere-sun': [0.0, 0.0],
              'sky-atmosphere-sun-intensity': 15
            }
          });
        }
        
        // Use fixed 1.0 terrain exaggeration - no slider adjustment
        const exaggeration = exaggerationValue;
        
        // Add 3D terrain
        map.setTerrain({ 'source': 'mapbox-dem', 'exaggeration': exaggeration });
        
        // Add route source and layer if needed
        if (!map.getSource('route') && routeCoordinates.length > 0) {
          map.addSource('route', {
            type: 'geojson',
            data: {
              type: 'Feature',
              properties: {},
              geometry: {
                type: 'LineString',
                coordinates: routeCoordinates.map(coord => [coord[0], coord[1]])
              }
            }
          });
          
          map.addLayer({
            id: 'route',
            type: 'line',
            source: 'route',
            layout: {
              'line-join': 'round',
              'line-cap': 'round'
            },
            paint: {
              'line-color': '#3498db',
              'line-width': 5,
              'line-opacity': 0.8
            }
          });
        }
        
        // Add point source and layer if needed
        if (!map.getSource('point') && routeCoordinates.length > 0) {
          map.addSource('point', {
            type: 'geojson',
            data: {
              type: 'Feature',
              properties: {},
              geometry: {
                type: 'Point',
                coordinates: [routeCoordinates[currentPoint][0], routeCoordinates[currentPoint][1]]
              }
            }
          });
          
          map.addLayer({
            id: 'point',
            type: 'circle',
            source: 'point',
            paint: {
              'circle-radius': 8,
              'circle-color': '#e74c3c',
              'circle-stroke-width': 2,
              'circle-stroke-color': '#ffffff'
            }
          });
        }
      } catch (e) {
        console.warn('Error adding terrain or sources:', e);
      }
    }
  
    // Map style is fixed to Satellite with Streets
    
    // Terrain exaggeration is now fixed at 1.0x - function removed
    
    // We've removed the complex pre-calculation function in favor of a simpler,
    // more direct approach that calculates what we need in real-time.
    
    // Simple pre-calculation function to update the cached height value
    function preCalculateRouteData() {
      // Simply update the stored height value
      lastPreCalcHeight = cameraHeight;
      // All actual calculations are done in real-time during animation
    }
  
    // Helper function to get the current rider position on screen
    function getRiderScreenPosition() {
      // Safety check
      if (!map || !map.getSource('point')) return null;
      
      try {
        // Get the rider's current position
        const pointSource = map.getSource('point');
        if (!pointSource || !pointSource._data) return null;
        
        const pointFeature = pointSource._data;
        if (!pointFeature || !pointFeature.geometry || !pointFeature.geometry.coordinates) return null;
      
        const riderCoords = pointFeature.geometry.coordinates;
        
        // Convert rider coordinates to screen coordinates
        const riderScreenPoint = map.project(riderCoords);
        
        // Get the map container dimensions
        const mapBounds = map.getContainer().getBoundingClientRect();
        const mapWidth = mapBounds.width;
        const mapHeight = mapBounds.height;
        
        return {
          x: riderScreenPoint.x,
          y: riderScreenPoint.y,
          mapWidth: mapWidth,
          mapHeight: mapHeight,
          coords: riderCoords
        };
      } catch (error) {
        console.warn('Error getting rider screen position:', error);
        return null;
      }
    }
    
    // ===== New camera system functions =====
    
    // Set up a camera transition with custom interpolation
    function setupCameraTransition(targetPos, targetBearing, targetPitch, targetZoom, duration = 2000) {
      // Simply store the target values - our continuous interpolation will handle the rest
      cameraTargetPos = targetPos;
      cameraTargetBearing = targetBearing;
      cameraTargetPitch = targetPitch;
      cameraTargetZoom = targetZoom;
    }
    
    // Smoothly interpolate camera position using a damping system, not time-based transitions
    function updateCameraInterpolation() {
      // Skip if no target or current position
      if (!cameraTargetPos || !currentCameraPos) return;
      
      // Camera lag factor (lower = more lag, smoother movement, but less responsive)
      // Adjust these values to fine-tune the camera follow behavior
      const positionLagFactor = 0.05;
      const bearingLagFactor = 0.05;
      const pitchLagFactor = 0.05;
      const zoomLagFactor = 0.05;
      
      // Interpolate position with inertia smoothing
      currentCameraPos = {
        lng: currentCameraPos.lng + (cameraTargetPos.lng - currentCameraPos.lng) * positionLagFactor,
        lat: currentCameraPos.lat + (cameraTargetPos.lat - currentCameraPos.lat) * positionLagFactor
      };
      
      // Handle bearing interpolation with special care for 0/360 boundary
      let targetBearingRad = cameraTargetBearing * Math.PI / 180;
      
      // Find shortest path around circle
      let bearingDiff = targetBearingRad - currentCameraBearingRad;
      if (bearingDiff > Math.PI) bearingDiff -= 2 * Math.PI;
      if (bearingDiff < -Math.PI) bearingDiff += 2 * Math.PI;
      
      // Apply smooth interpolation to bearing (in radians for smoother math)
      currentCameraBearingRad += bearingDiff * bearingLagFactor;
      
      // Convert back to degrees for mapbox
      const newBearing = (currentCameraBearingRad * 180 / Math.PI) % 360;
      
      // Interpolate pitch with inertia smoothing
      currentCameraPitch += (cameraTargetPitch - currentCameraPitch) * pitchLagFactor;
      
      // Interpolate zoom with inertia smoothing
      currentCameraZoom += (cameraTargetZoom - currentCameraZoom) * zoomLagFactor;
      
      // Apply the new camera values - using jumpTo for performance
      // This avoids Mapbox's own easing/smoothing which can cause stuttering
      map.jumpTo({
        center: currentCameraPos,
        bearing: newBearing,
        pitch: currentCameraPitch,
        zoom: currentCameraZoom
      });
    }
    
    // Calculate ideal camera position based on rider and look-ahead
    function calculateIdealCameraPosition(riderCoord, bearing, speed, height, pitch, sideOffset = 0, lookAheadAdjust = 0) {
      // Calculate look-ahead distance based on camera height and speed
      // The higher the camera, the further ahead we look
      // The faster we go, the further ahead we look
      
      // Normalize camera height to 0-1
      const normalizedHeight = (height - 1) / 99;
      
      // Base distance that scales with camera height (exponentially)
      // For low heights, we want minimal look-ahead
      // For high heights, we want significant look-ahead
      const heightFactor = Math.pow(normalizedHeight, 0.8); // Flattens the curve a bit at lower heights
      
      // Set base look-ahead depending on camera height
      // At minimum height: 10m look-ahead
      // At maximum height: 400m look-ahead
      const baseLookAhead = 10 + (390 * heightFactor);
      
      // Adjust for speed (minimum impact at low heights, more at high heights)
      const speedFactor = 1 + speed; // Range 1.1-2.0
      const speedImpact = heightFactor; // Speed matters more at height
      
      // Apply the look-ahead adjustment from visibility check (positive = more look ahead)
      const lookAheadAdjustment = baseLookAhead * lookAheadAdjust;
      // Apply adjustments for look-ahead and smooth transitions based on rider visibility
      const lookAheadMeters = (baseLookAhead + lookAheadAdjustment) * (1 + (speedImpact * speedFactor));
      
      // Convert bearing to radians
      const bearingRad = (bearing * Math.PI) / 180;
      
      // Calculate look-ahead point on the map
      const metersPerDegree = 111319.9; // Approximate meters per degree latitude
      
      // Calculate offsets
      const latOffset = Math.cos(bearingRad) * (lookAheadMeters / metersPerDegree);
      const lngOffset = Math.sin(bearingRad) * (lookAheadMeters / (metersPerDegree * Math.cos(riderCoord.lat * Math.PI / 180)));
      
      // Create look-ahead coordinate
      const lookAheadCoord = {
        lng: riderCoord.lng + lngOffset,
        lat: riderCoord.lat + latOffset
      };
      
      // Calculate distance to position camera behind the rider
      // We want to be further behind at lower camera heights (to see more of the rider)
      // Less behind at higher heights
      const behindDistanceDegrees = (0.0002 + (0.0002 * (1 - heightFactor))); // ranges from 0.0002 to 0.0004
      
      // Calculate the behind position (180° from bearing)
      const behindBearingRad = ((bearing + 180) % 360) * Math.PI / 180;
      const behindLatOffset = Math.cos(behindBearingRad) * behindDistanceDegrees;
      const behindLngOffset = Math.sin(behindBearingRad) * (behindDistanceDegrees / Math.cos(riderCoord.lat * Math.PI / 180));
      
      // Calculate the weighted position between rider and look-ahead
      // The blend depends on both height and pitch
      // Lower pitch (looking more horizontally) needs more look-ahead influence
      // Higher pitch (looking more down) needs more rider influence
      const normalizedPitch = pitch / 85; // 0-1 range
      
      // Lower pitches need more look-ahead
      // Higher pitches need less look-ahead
      const pitchFactor = 1 - Math.pow(normalizedPitch, 0.7);
      
      // Adjust the weighting based on both height and pitch
      const lookAheadWeight = 0.8 * heightFactor * pitchFactor;
      const riderWeight = 1 - lookAheadWeight;
      
      // Blend the coordinates
      const blendedCoord = {
        lng: (riderCoord.lng * riderWeight) + (lookAheadCoord.lng * lookAheadWeight),
        lat: (riderCoord.lat * riderWeight) + (lookAheadCoord.lat * lookAheadWeight)
      };
      
      // Calculate side offset (perpendicular to the direction of travel)
      // This is used to adjust the camera position left or right to keep the rider in view
      let sideLatOffset = 0;
      let sideLngOffset = 0;
      
      if (sideOffset !== 0) {
        // Calculate perpendicular bearing (90° to the direction of travel)
        const sideBearingRad = ((bearing + 90) % 360) * Math.PI / 180;
        // Scale the side offset based on camera height and distance
        const sideOffsetDistance = sideOffset * 0.0005 * (1 + heightFactor);
        
        // Calculate offset in lat/lng
        sideLatOffset = Math.cos(sideBearingRad) * sideOffsetDistance;
        sideLngOffset = Math.sin(sideBearingRad) * (sideOffsetDistance / Math.cos(riderCoord.lat * Math.PI / 180));
      }
      
      // Apply the behind offset and side offset to the blended position
      const cameraPos = {
        lng: blendedCoord.lng + behindLngOffset + sideLngOffset,
        lat: blendedCoord.lat + behindLatOffset + sideLatOffset
      };
      
      return cameraPos;
    }
    
    // Update camera smoothly based on rider position
    function updateCamera(riderCoord, bearing, options = {}) {
      // Merge options with defaults
      const settings = {
        speed: animationSpeed,
        height: cameraHeight,
        pitch: cameraAngle,
        transitionDuration: 800, // ms
        ...options
      };
      
      // Calculate ideal camera position
      const targetCameraPos = calculateIdealCameraPosition(
        riderCoord, 
        bearing, 
        settings.speed, 
        settings.height, 
        settings.pitch
      );
      
      const targetZoom = calculateZoomFromHeight(settings.height);
      const targetPitch = settings.pitch;
      const targetBearingRad = bearing * Math.PI / 180;
      
      // Initialize camera position on first call
      if (currentCameraPos.lng === 0 && currentCameraPos.lat === 0) {
        currentCameraPos = map.getCenter();
        currentCameraZoom = map.getZoom();
        currentCameraPitch = map.getPitch();
        currentCameraBearingRad = map.getBearing() * Math.PI / 180;
        
        // First time, jump directly to position
        map.jumpTo({
          center: targetCameraPos,
          bearing: bearing,
          pitch: targetPitch,
          zoom: targetZoom
        });
        
        return;
      }
      
      // Don't use transitions at all - we'll handle the smooth movement ourselves
      // by directly updating the camera each frame during animation
      
      // Store the target values for the animation loop to use
      cameraTargetPos = targetCameraPos;
      cameraTargetBearing = bearing;
      cameraTargetPitch = targetPitch;
      cameraTargetZoom = targetZoom;
    }
    
    // Calculate the zoom level from camera height
    function calculateZoomFromHeight(height) {
      // Convert slider value (1-100) to actual parameters
      const sliderMin = 1;
      const sliderMax = 100;
      
      // Adjusted height range
      const actualMinHeight = 0.8;
      const actualMaxHeight = 250;
      
      // Normalize and calculate actual height (exponential scale)
      const normalizedSliderValue = (height - sliderMin) / (sliderMax - sliderMin);
      const actualHeight = actualMinHeight * Math.pow(actualMaxHeight / actualMinHeight, normalizedSliderValue);
      
      // Zoom range 
      const minZoom = 19.0; // Closer view
      const maxZoom = 11.5; // Farther view
      
      // Calculate zoom level (logarithmic scale)
      return maxZoom + ((Math.log(actualMaxHeight) - Math.log(actualHeight)) / 
                        (Math.log(actualMaxHeight) - Math.log(actualMinHeight))) * (minZoom - maxZoom);
    }
    
    // Function to parse URL parameters and hash fragments
    function parseUrlParams() {
      // Check for route parameter in the URL query string
      const urlParams = new URLSearchParams(window.location.search);
      const routeParam = urlParams.get('route');
      
      // Check for route in the hash fragment (e.g. #route=D1_East_Long.gpx)
      const hashParams = new URLSearchParams(window.location.hash.substring(1));
      const hashRoute = hashParams.get('route');
      
      // Use the parameter from query string or hash if available
      const requestedRoute = routeParam || hashRoute;
      
      if (requestedRoute) {
        // Find the matching option in the select element
        const options = Array.from(routeSelect.options);
        const matchingOption = options.find(option => option.value === requestedRoute);
        
        if (matchingOption) {
          // Set the select element to the requested route
          routeSelect.value = requestedRoute;
          return requestedRoute;
        }
      }
      
      // Return default route if no valid route parameter found
      return routeSelect.value;
    }

    // Event listeners
    document.addEventListener('DOMContentLoaded', () => {
      initMap();
      
      // Check URL parameters for requested route
      const initialRoute = parseUrlParams();
      
      // Load the initial route from URL parameter if available
      if (initialRoute) {
        loadRoute(initialRoute, true);
      }
      
      routeSelect.addEventListener('change', () => {
        loadRoute(routeSelect.value, true); // Apply camera height immediately on route change
        
        // Update URL hash to make the current route shareable
        window.location.hash = `route=${routeSelect.value}`;
      });
      
      toggleBtn.addEventListener('click', toggleAnimation);
      resetBtn.addEventListener('click', resetAnimation);
      
      // Map style is fixed to Satellite with Streets
      
      // Terrain exaggeration is now fixed at 1.0x - no handler needed
      
      // Camera height handler - updates view immediately
      heightControl.addEventListener('input', () => {
        try {
          cameraHeight = parseInt(heightControl.value);
          
          // If animation is not running, update the view immediately
          if (!animationId && routeCoordinates.length > 0) {
            updateInitialMapView();
            
            // After view update, check if rider is visible
            // Using a longer delay for smoother behavior
            setTimeout(() => {
              try {
                // Only check if the rider is completely out of view (less aggressive)
                const riderPosition = getRiderScreenPosition();
                if (riderPosition && isRiderCompletelyOutOfView(riderPosition)) {
                  // Use a very gentle, slow adjustment only when absolutely necessary
                  adjustCameraToKeepRiderVisible(riderPosition, false);
                }
              } catch (e) {
                console.warn('Error checking rider visibility after height change:', e);
              }
            }, 1200);
          }
          
          // Only recalculate if the height has changed significantly
          if (Math.abs(cameraHeight - lastPreCalcHeight) > 10) {
            // Wait a short delay if the user is actively adjusting the slider
            setTimeout(() => {
              try {
                // Only recalculate if the height hasn't changed again during the delay
                if (Math.abs(cameraHeight - lastPreCalcHeight) > 10) {
                  preCalculateRouteData();
                }
              } catch (e) {
                console.warn('Error in preCalculateRouteData:', e);
              }
            }, 500);
          }
        } catch (error) {
          console.error('Error in camera height handler:', error);
        }
      });
      
      // Camera angle handler - updates view immediately
      angleControl.addEventListener('input', () => {
        try {
          // Invert the values - slider shows low to high (10-85), but we need to reverse this
          // so that when slider is at "Low" position, we get a horizontal view (low angle value)
          // and when slider is at "High" position, we get an overhead view (high angle value)
          const sliderValue = parseInt(angleControl.value);
          
          // Calculate inverted angle - when slider is at min (10), we want max angle (85)
          // and vice versa
          cameraAngle = 95 - sliderValue; // 95 - 10 = 85, 95 - 85 = 10
          
          // If animation is not running, update the view immediately
          if (!animationId && routeCoordinates.length > 0) {
            updateInitialMapView();
            
            // After view update, check if rider is completely out of view
            // Using a longer delay for smoother behavior and being less aggressive
            setTimeout(() => {
              try {
                // Only check if the rider is completely out of view (less aggressive)
                const riderPosition = getRiderScreenPosition();
                if (riderPosition && isRiderCompletelyOutOfView(riderPosition)) {
                  // Use a very gentle, slow adjustment only when absolutely necessary
                  adjustCameraToKeepRiderVisible(riderPosition, false);
                }
              } catch (e) {
                console.warn('Error checking rider visibility after angle change:', e);
              }
            }, 1200);
          }
        } catch (error) {
          console.error('Error in camera angle handler:', error);
        }
      });
      
      speedControl.addEventListener('input', () => {
        animationSpeed = parseFloat(speedControl.value);
      });
      
      // Position slider handler
      positionSlider.addEventListener('input', () => {
        // Only allow manual positioning when animation is not running
        if (!animationId) {
          try {
            const positionPercent = parseFloat(positionSlider.value) / 100;
            updatePositionManually(positionPercent);
            
            // Wait for position update to complete, then check visibility
            // Using a longer delay for a smoother experience
            setTimeout(() => {
              try {
                const riderPosition = getRiderScreenPosition();
                if (riderPosition && !isRiderVisible(riderPosition)) {
                  // If rider isn't visible, make a smooth adjustment
                  adjustCameraToKeepRiderVisible(riderPosition);
                }
              } catch (e) {
                console.warn('Error in rider visibility check after position update:', e);
              }
            }, 1000);
          } catch (error) {
            console.error('Error updating position manually:', error);
          }
        }
      });
    });
    
    // Function to manually update position based on slider
    function updatePositionManually(positionPercent) {
      // Safety check
      if (!routeCoordinates || routeCoordinates.length === 0 || !routeDistances || routeDistances.length === 0) {
        return;
      }
      
      // Calculate the distance along the route
      const totalDistanceMeters = routeDistances[routeDistances.length - 1] * 1000; // km to m
      currentRouteDistance = positionPercent * totalDistanceMeters;
      
      // Convert current distance to km for comparison with routeDistances
      const currentDistanceKm = currentRouteDistance / 1000;
      
      // Get segment using the route
      const segment = calculateSegmentForDistance(currentDistanceKm, false);
      const beforeIdx = segment.beforeIdx;
      const afterIdx = segment.afterIdx;
      const fraction = segment.fraction;
      
      // Get the two points
      const beforePoint = routeCoordinates[beforeIdx];
      const afterPoint = routeCoordinates[afterIdx];
      
      // Create interpolated point
      const interpolatedPoint = [
        beforePoint[0] + (afterPoint[0] - beforePoint[0]) * fraction,
        beforePoint[1] + (afterPoint[1] - beforePoint[1]) * fraction
      ];
      
      // Include elevation if available
      if (beforePoint.length > 2 && afterPoint.length > 2) {
        interpolatedPoint[2] = beforePoint[2] + (afterPoint[2] - beforePoint[2]) * fraction;
      }
      
      // Update rider position
      updatePointPosition(interpolatedPoint);
      
      // Update current tracking point indices
      currentPoint = beforeIdx;
      currentPointFloat = beforeIdx + fraction;
      
      // Calculate bearing
      const bearing = calculateBearing(
        beforePoint,
        afterPoint
      );
      
      // Create a rider coordinate object
      const riderCoord = {
        lng: interpolatedPoint[0],
        lat: interpolatedPoint[1]
      };
      
      // Use our new camera system for consistency with animation
      updateCamera(riderCoord, bearing, {
        // Use a longer transition duration for slider updates
        transitionDuration: 1500
      });
      
      // Update UI
      updateProgress();
    }
  </script>
</body>
</html>