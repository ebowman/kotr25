<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>King of the Road 2025 - Route Flyover</title>
  <link rel="stylesheet" href="https://unpkg.com/mapbox-gl@2.15.0/dist/mapbox-gl.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />
  <script src="https://unpkg.com/mapbox-gl@2.15.0/dist/mapbox-gl.js"></script>
  <script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>
  <script src="https://unpkg.com/axios/dist/axios.min.js"></script>
  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      background: #f9f9f9;
      color: #333;
    }
    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
      display: flex;
      flex-wrap: wrap;
      gap: 20px;
    }
    h1 {
      width: 100%;
      text-align: center;
      margin-bottom: 10px;
      color: #222;
    }
    #map {
      flex: 1;
      min-width: 700px;
      height: 600px;
      border-radius: 8px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.05);
    }
    .controls {
      width: 280px;
      padding: 15px;
      background: white;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.05);
      display: flex;
      flex-direction: column;
      gap: 20px;
    }
    select, button {
      padding: 10px 15px;
      border-radius: 5px;
      border: 1px solid #ddd;
      background: white;
      font-size: 14px;
      width: 100%;
    }
    button {
      background: linear-gradient(to bottom, #3498db, #2980b9);
      color: white;
      cursor: pointer;
      border: none;
      transition: all 0.2s;
      font-weight: 600;
    }
    button:hover {
      background: linear-gradient(to bottom, #2980b9, #2471a3);
      transform: translateY(-1px);
    }
    button:disabled {
      background: #ccc;
      cursor: not-allowed;
    }
    label {
      font-weight: 600;
      margin-bottom: 5px;
      display: block;
      color: #444;
    }
    .control-group {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .route-info {
      background: white;
      border-radius: 8px;
      padding: 15px;
      margin-top: 20px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    }
    .info-grid {
      display: flex;
      justify-content: space-between;
      flex-wrap: nowrap;
      gap: 15px;
      margin-top: 10px;
    }
    .info-item {
      flex: 1;
      text-align: center;
      padding: 12px;
      background: #f5f9ff;
      border-radius: 5px;
    }
    .info-label {
      font-size: 12px;
      color: #666;
      margin-bottom: 5px;
    }
    .info-value {
      font-size: 20px;
      font-weight: 600;
      color: #2c3e50;
    }
    .elevation-profile {
      width: 100%;
      height: 120px;
      background: white;
      margin-top: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.05);
      position: relative;
    }
    #elevation-canvas {
      width: 100%;
      height: 100%;
      border-radius: 8px;
    }
    .elevation-marker {
      position: absolute;
      top: 0;
      width: 2px;
      height: 120px;
      background: red;
      z-index: 10;
      pointer-events: none;
    }
    .loading {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(255,255,255,0.8);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }
    .loading-spinner {
      border: 5px solid #f3f3f3;
      border-top: 5px solid #3498db;
      border-radius: 50%;
      width: 50px;
      height: 50px;
      animation: spin 1s linear infinite;
      margin-bottom: 15px;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    .slider-container {
      margin-top: 5px;
    }
    .range-labels {
      display: flex;
      justify-content: space-between;
      font-size: 12px;
      color: #666;
      margin-top: 5px;
    }
    input[type="range"] {
      width: 100%;
      margin: 0;
      -webkit-appearance: none;
      appearance: none;
      height: 6px;
      background: #e0e0e0;
      border-radius: 3px;
      outline: none;
    }
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: #3498db;
      cursor: pointer;
      border: 2px solid white;
      box-shadow: 0 1px 3px rgba(0,0,0,0.2);
    }
    input[type="range"]::-moz-range-thumb {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: #3498db;
      cursor: pointer;
      border: 2px solid white;
      box-shadow: 0 1px 3px rgba(0,0,0,0.2);
    }
  </style>
</head>
<body>
  <div class="container">
    <div style="display: flex; justify-content: space-between; align-items: center; width: 100%; margin-bottom: 10px;">
      <a href="index.html" style="text-decoration: none; color: #3498db; display: flex; align-items: center;">
        <i class="fas fa-arrow-left" style="margin-right: 5px;"></i> Back to routes
      </a>
    </div>
    <h1>King of the Road 2025 - 3D Route Flyover</h1>
    
    <div class="controls">
      <div class="control-group">
        <label for="route-select">Select Route:</label>
        <select id="route-select">
          <option value="D0_Warm-up.gpx">Day 0 - Warm-up</option>
          <option value="D1_East Short.gpx">Day 1 - East (Short)</option>
          <option value="D1_East_Long.gpx">Day 1 - East (Long)</option>
          <option value="D2_North_Short.gpx">Day 2 - North (Short)</option>
          <option value="D2_North_Long.gpx">Day 2 - North (Long)</option>
          <option value="D3_West_Short.gpx">Day 3 - West (Short)</option>
          <option value="D3_West_Long.gpx">Day 3 - West (Long)</option>
        </select>
      </div>
      
      <div class="control-group">
        <label for="camera-height">Zoom:</label>
        <div class="slider-container">
          <input type="range" id="camera-height" min="1" max="100" step="1" value="25">
          <div class="range-labels">
            <span>In</span>
            <span>Out</span>
          </div>
        </div>
      </div>
      
      <div class="control-group">
        <label for="camera-angle">View Angle:</label>
        <div class="slider-container">
          <input type="range" id="camera-angle" min="10" max="85" step="1" value="45">
          <div class="range-labels">
            <span>Low</span>
            <span>High</span>
          </div>
        </div>
      </div>
      
      <div class="control-group">
        <label for="speed-control">Animation Speed:</label>
        <div class="slider-container">
          <input type="range" id="speed-control" min="0.1" max="1" step="0.1" value="0.5">
          <div class="range-labels">
            <span>Slow</span>
            <span>Fast</span>
          </div>
        </div>
      </div>
      
      <div class="control-group">
        <label for="position-slider">Position:</label>
        <div class="slider-container">
          <input type="range" id="position-slider" min="0" max="100" step="0.1" value="0">
          <div class="range-labels">
            <span>Start</span>
            <span>End</span>
          </div>
        </div>
      </div>
      
      <div class="control-group" style="margin-top: 10px;">
        <button id="toggle-btn">Start</button>
        <button id="reset-btn" disabled>Reset</button>
      </div>
    </div>
    
    <div id="map"></div>
    
    <div class="elevation-profile">
      <canvas id="elevation-canvas"></canvas>
      <div class="elevation-marker" id="elevation-marker" style="display: none;"></div>
    </div>
    
    <div class="route-info">
      <div class="info-header">
        <h3>Route Information</h3>
      </div>
      <div class="info-grid">
        <div class="info-item">
          <div class="info-label">Total Distance</div>
          <div class="info-value" id="total-distance">--</div>
        </div>
        <div class="info-item">
          <div class="info-label">Distance Traveled</div>
          <div class="info-value" id="distance-traveled">0.0 km</div>
        </div>
        <div class="info-item">
          <div class="info-label">Elevation Gain</div>
          <div class="info-value" id="elevation-gain">--</div>
        </div>
        <div class="info-item">
          <div class="info-label">Current Elevation</div>
          <div class="info-value" id="current-elevation">--</div>
        </div>
        <div class="info-item">
          <div class="info-label">Current Gradient</div>
          <div class="info-value" id="current-gradient">--</div>
        </div>
        <div class="info-item">
          <div class="info-label">Progress</div>
          <div class="info-value" id="progress">0%</div>
        </div>
      </div>
    </div>
  </div>
  
  <div class="loading" id="loading">
    <div class="loading-spinner"></div>
    <p>Loading route data...</p>
  </div>
  
  <script>
    // Replace with your Mapbox access token
    mapboxgl.accessToken = 'pk.eyJ1IjoiZWJvd21hbiIsImEiOiJjbWE1ZWVwdzYwODhwMmlzZnU4NTlyem1rIn0.E10X5hj2NTgViJexKpvrOg';
    
    // Global variables
    let map;
    let routeData = null;
    let animationId = null;
    let currentPoint = 0;
    let elevationProfile = [];
    let maxElevation = 0;
    let minElevation = Infinity;
    let totalDistance = 0;
    let elevationGain = 0;
    let routeCoordinates = [];
    let smoothedRouteCoordinates = []; // Smoothed version of coordinates for camera movement when zoomed out
    let routeDistances = []; // Array to store cumulative distances along route
    let smoothedRouteDistances = []; // Array to store distances for smoothed route
    let animationSpeed = 0.5;
    let cameraHeight = 25; // Default camera height (slider position, not actual meters)
    let cameraAngle = 50; // Default camera angle (pitch) in degrees (inverted from slider value of 45)
    let currentRouteDistance = 0; // Current distance along route in meters
    let totalDistanceMeters = 0; // Total distance of the route in meters
    let lastPreCalcHeight = 25; // Track the last height value used for calculation
    let prevBearing; // Track previous bearing for smoother camera movement
    
    // We've simplified the animation and removed pre-calculation 
    // to reduce potential causes of glitches
    
    // Advanced function to create multiple levels of route smoothing for dynamic camera behavior
    // This creates different smoothing levels that can be selected based on zoom level
    function createSmoothedRoute(coordinates) {
      // Skip if too few points
      if (coordinates.length <= 10) return [...coordinates];
      
      // Create multiple levels of smoothing for different zoom levels
      // We'll calculate different smoothing for low, medium and high zoom levels
      // This allows more stable camera movement when zoomed out
      
      // ===== MULTI-LEVEL SMOOTHING APPROACH =====
      
      // Determine base smoothing factors based on route length and complexity
      // We need different smoothing levels for different zoom levels
      const routeLength = coordinates.length;
      const baseSmoothing = Math.max(3, Math.floor(routeLength / 300));
      
      // Create multi-resolution smoothed paths
      const smoothed = [];
      
      // Always include the first point
      smoothed.push([...coordinates[0]]);
      
      // Adapt point inclusion based on route length
      // For longer routes, we need to skip more points to avoid excessive memory usage
      // while still maintaining route fidelity
      const skipFactor = Math.max(1, Math.ceil(routeLength / 1500)); 
      
      // Process interior points with adaptive smoothing
      for (let i = skipFactor; i < routeLength - skipFactor; i += skipFactor) {
        // Create adaptive smoothing that varies based on position in the route:
        // - More aggressive smoothing in the middle of the route
        // - Less aggressive smoothing near endpoints
        // - Special handling for significant elevation changes
        // This creates more natural camera behavior at endpoints and elevation changes
        
        // Calculate position-based smoothing factor
        // Distance from either end determines smoothing strength
        const positionFactor = Math.min(
          i / routeLength,                // Distance from start (0-1)
          (routeLength - i) / routeLength // Distance from end (0-1)
        ) * 4;                            // Scale up for more noticeable effect
        
        // Detect elevation significance - important for hills and downhill sections
        // We want to preserve significant elevation changes for camera look-ahead
        let elevationSignificance = 0;
        
        if (coordinates[i].length > 2 && 
            i > 0 && i < routeLength - 1 && 
            coordinates[i-1].length > 2 && coordinates[i+1].length > 2) {
          
          // Calculate elevation change rate (gradient)
          const elevChange = Math.abs(coordinates[i][2] - coordinates[i-1][2]);
          const elevChangeNext = Math.abs(coordinates[i+1][2] - coordinates[i][2]);
          
          // Higher values = less smoothing near significant elevation changes
          elevationSignificance = Math.min(1, (elevChange + elevChangeNext) / 10);
        }
        
        // Calculate final window size for this point
        // Smaller window = less smoothing, larger window = more smoothing
        // Three factors affect window size:
        // 1. Base smoothing (route length dependent)
        // 2. Position factor (middle vs. endpoints)
        // 3. Elevation significance (hills get less smoothing)
        const windowSize = Math.max(5, Math.round(
          baseSmoothing * (1 + positionFactor) * (1 - elevationSignificance * 0.5)
        ));
        
        // === WEIGHTED GAUSSIAN SMOOTHING ===
        // This produces much more natural curves than simple averaging
        let sumLng = 0;
        let sumLat = 0;
        let sumEle = 0;
        let totalWeight = 0;
        
        // Calculate weighted average with Gaussian falloff
        for (let j = i - windowSize; j <= i + windowSize; j++) {
          if (j >= 0 && j < routeLength) {
            // Calculate distance-based weight with Gaussian falloff
            const distFactor = Math.abs(i - j) / windowSize;
            
            // Steeper Gaussian falloff for more natural curves
            // Higher exponent = steeper falloff = less influence from distant points
            const weight = Math.exp(-5.5 * distFactor * distFactor);
            
            // Add weighted contribution
            sumLng += coordinates[j][0] * weight;
            sumLat += coordinates[j][1] * weight;
            totalWeight += weight;
            
            // Handle elevation data with special weighting to preserve route features
            if (coordinates[j].length > 2) {
              // For elevation, we use a modified weighting that preserves hills
              // by reducing the amount of smoothing applied to significant changes
              const elevWeight = weight * (1 - elevationSignificance * 0.5);
              sumEle += coordinates[j][2] * elevWeight;
            }
          }
        }
        
        // Create the smoothed point with normalized weights
        const smoothPoint = [
          sumLng / totalWeight,
          sumLat / totalWeight
        ];
        
        // Add elevation if it exists (with modified smoothing)
        if (coordinates[i].length > 2) {
          // If elevation significance is high, use less smoothing to preserve feature
          // This prevents camera from missing hills and valleys
          const rawElevation = coordinates[i][2];
          const smoothedElevation = sumEle / totalWeight;
          
          // Blend between raw and smoothed elevation based on significance
          // More significant elevation changes are preserved (less smoothing)
          const blendedElevation = 
            (smoothedElevation * (1 - elevationSignificance * 0.7)) + 
            (rawElevation * elevationSignificance * 0.7);
          
          smoothPoint.push(blendedElevation);
        }
        
        smoothed.push(smoothPoint);
      }
      
      // Always include the last point
      smoothed.push([...coordinates[routeLength - 1]]);
      
      console.log(`Route smoothed from ${routeLength} to ${smoothed.length} points with multi-level adaptive smoothing`);
      return smoothed;
    }
    
    // Helper function to efficiently calculate segment data for any distance
    // Uses binary search for much faster lookups, important for smooth animation
    function calculateSegmentForDistance(distanceKm, useSmoothedRoute = false) {
      // Choose which route and distances to use based on zoom level
      const distances = useSmoothedRoute ? smoothedRouteDistances : routeDistances;
      
      let beforeIdx = 0;
      let afterIdx = 1;
      let fraction = 0;
      
      // Handle edge cases for start and end of route
      if (distanceKm <= distances[0]) {
        return { beforeIdx: 0, afterIdx: 1, fraction: 0 };
      }
      
      if (distanceKm >= distances[distances.length - 1]) {
        return { 
          beforeIdx: distances.length - 2, 
          afterIdx: distances.length - 1, 
          fraction: 1 
        };
      }
      
      // Binary search for faster lookup - critical for smooth animation
      let left = 0;
      let right = distances.length - 1;
      
      while (left <= right) {
        const mid = Math.floor((left + right) / 2);
        
        if (distances[mid] === distanceKm) {
          // Exact match
          beforeIdx = mid;
          afterIdx = Math.min(mid + 1, distances.length - 1);
          fraction = 0;
          break;
        }
        
        if (distances[mid] < distanceKm) {
          if (mid < distances.length - 1 && distances[mid + 1] > distanceKm) {
            // Found the segment
            beforeIdx = mid;
            afterIdx = mid + 1;
            break;
          }
          left = mid + 1;
        } else {
          right = mid - 1;
        }
      }
      
      // Calculate the interpolation fraction
      const segmentLength = distances[afterIdx] - distances[beforeIdx];
      if (segmentLength > 0) {
        fraction = (distanceKm - distances[beforeIdx]) / segmentLength;
        fraction = Math.max(0, Math.min(1, fraction));
      }
      
      return { beforeIdx, afterIdx, fraction };
    }
    
    // DOM Elements
    const routeSelect = document.getElementById('route-select');
    const toggleBtn = document.getElementById('toggle-btn');
    const resetBtn = document.getElementById('reset-btn');
    const speedControl = document.getElementById('speed-control');
    const heightControl = document.getElementById('camera-height');
    const angleControl = document.getElementById('camera-angle');
    const positionSlider = document.getElementById('position-slider');
    const elevationCanvas = document.getElementById('elevation-canvas');
    const elevationMarker = document.getElementById('elevation-marker');
    const totalDistanceEl = document.getElementById('total-distance');
    const distanceTraveledEl = document.getElementById('distance-traveled');
    const elevationGainEl = document.getElementById('elevation-gain');
    const currentElevationEl = document.getElementById('current-elevation');
    const currentGradientEl = document.getElementById('current-gradient');
    const progressEl = document.getElementById('progress');
    const loadingEl = document.getElementById('loading');
    
    // Initialize map
    function initMap() {
      map = new mapboxgl.Map({
        container: 'map',
        style: 'mapbox://styles/mapbox/satellite-streets-v12', // Fixed to Satellite with street overlay
        center: [14.5, 46.05], // Ljubljana, Slovenia
        zoom: 11,
        pitch: 45,
        bearing: 0,
        maxPitch: 85 // Allow a higher maximum pitch for better forward visibility
      });
      
      // Global flag to track initialization
      let mapInitialized = false;
      
      // Add terrain for 3D hills after style loads with fixed 1x exaggeration
      map.on('style.load', () => {
        addTerrainAndSources(1.0); // Lock terrain exaggeration to 1.0x
      });
      
      map.on('load', () => {
        // Initial terrain setup
        addTerrainAndSources();
        
        mapInitialized = true;
      });
      
      // Handle source errors by adding an error handler
      map.on('error', (e) => {
        // Only log to console, don't alert the user for common map errors
        if (e.error && e.error.message && e.error.message.includes('There is already a source with this ID')) {
          console.warn('Map source already exists - this is normal during style changes:', e.error.message);
        } else {
          console.error('Map error:', e.error);
        }
      });
    }
    
    // Load GPX route
    async function loadRoute(routeFile, applyInitialView = false) {
      loadingEl.style.display = 'flex';
      
      try {
        const response = await fetch(`gpx/${routeFile}`);
        const gpxData = await response.text();
        
        // Parse GPX
        const parser = new DOMParser();
        const gpx = parser.parseFromString(gpxData, 'text/xml');
        const trackPoints = gpx.querySelectorAll('trkpt');
        
        // Extract coordinates and elevation
        routeCoordinates = [];
        elevationProfile = [];
        maxElevation = 0;
        minElevation = Infinity;
        let prevElevation = null;
        elevationGain = 0;
        
        trackPoints.forEach(point => {
          const lat = parseFloat(point.getAttribute('lat'));
          const lon = parseFloat(point.getAttribute('lon'));
          let ele = 0;
          
          const eleTag = point.querySelector('ele');
          if (eleTag && eleTag.textContent) {
            ele = parseFloat(eleTag.textContent);
          }
          
          if (ele > maxElevation) maxElevation = ele;
          if (ele < minElevation) minElevation = ele;
          
          if (prevElevation !== null && ele > prevElevation) {
            elevationGain += (ele - prevElevation);
          }
          
          prevElevation = ele;
          
          routeCoordinates.push([lon, lat, ele]);
          elevationProfile.push(ele);
        });
        
        // Calculate segment distances and cumulative distances
        totalDistance = 0;
        routeDistances = [0]; // Start with 0 for the first point
        
        for (let i = 1; i < routeCoordinates.length; i++) {
          const from = turf.point([routeCoordinates[i-1][0], routeCoordinates[i-1][1]]);
          const to = turf.point([routeCoordinates[i][0], routeCoordinates[i][1]]);
          const segmentDistance = turf.distance(from, to, {units: 'kilometers'});
          totalDistance += segmentDistance;
          // Store cumulative distance at each point in kilometers
          routeDistances.push(totalDistance);
        }
        
        // Set the global total distance in meters
        totalDistanceMeters = totalDistance * 1000;
        
        // Create a simplified version of the route for smooth camera movement when zoomed out
        smoothedRouteCoordinates = createSmoothedRoute(routeCoordinates);
        
        // Calculate distances for the smoothed route
        let smoothedTotalDistance = 0;
        smoothedRouteDistances = [0]; // Start with 0
        
        for (let i = 1; i < smoothedRouteCoordinates.length; i++) {
          const from = turf.point([smoothedRouteCoordinates[i-1][0], smoothedRouteCoordinates[i-1][1]]);
          const to = turf.point([smoothedRouteCoordinates[i][0], smoothedRouteCoordinates[i][1]]);
          const segmentDistance = turf.distance(from, to, {units: 'kilometers'});
          smoothedTotalDistance += segmentDistance;
          smoothedRouteDistances.push(smoothedTotalDistance);
        }
        
        // Update route on map
        const geojson = {
          type: 'Feature',
          properties: {},
          geometry: {
            type: 'LineString',
            coordinates: routeCoordinates.map(coord => [coord[0], coord[1]])
          }
        };
        
        // Check if source exists before updating
        try {
          if (map.getSource('route')) {
            map.getSource('route').setData(geojson);
          } else {
            // Add source and layer if they don't exist yet
            map.addSource('route', {
              type: 'geojson',
              data: geojson
            });
            
            map.addLayer({
              id: 'route',
              type: 'line',
              source: 'route',
              layout: {
                'line-join': 'round',
                'line-cap': 'round'
              },
              paint: {
                'line-color': '#3498db',
                'line-width': 5,
                'line-opacity': 0.8
              }
            });
          }
          
          // Initialize or update point location
          if (map.getSource('point')) {
            updatePointPosition(routeCoordinates[0]);
          } else {
            map.addSource('point', {
              type: 'geojson',
              data: {
                type: 'Feature',
                properties: {},
                geometry: {
                  type: 'Point',
                  coordinates: [routeCoordinates[0][0], routeCoordinates[0][1]]
                }
              }
            });
            
            map.addLayer({
              id: 'point',
              type: 'circle',
              source: 'point',
              paint: {
                'circle-radius': 8,
                'circle-color': '#e74c3c',
                'circle-stroke-width': 2,
                'circle-stroke-color': '#ffffff'
              }
            });
          }
        } catch (e) {
          console.warn('Had to wait for map style to load:', e);
          
          // Wait for style to load and retry
          map.once('style.load', () => {
            // Add terrain, sources and layers again
            addTerrainAndSources();
            
            // Now try to update data again
            if (map.getSource('route')) {
              map.getSource('route').setData(geojson);
            }
            
            if (map.getSource('point')) {
              updatePointPosition(routeCoordinates[0]);
            }
          });
        }
        
        // Fit map to route
        const bounds = new mapboxgl.LngLatBounds();
        routeCoordinates.forEach(coord => {
          bounds.extend([coord[0], coord[1]]);
        });
        map.fitBounds(bounds, { padding: 50 });
        
        // Update UI
        totalDistanceEl.textContent = `${totalDistance.toFixed(1)} km`;
        elevationGainEl.textContent = `${elevationGain.toFixed(0)} m`;
        
        // Draw elevation profile
        drawElevationProfile();
        
        // Reset animation
        resetAnimation();
        
        // Reset button text and position slider
        toggleBtn.textContent = "Start";
        positionSlider.value = 0;
        
        // Pre-calculate route data for smooth animation
        preCalculateRouteData();
        
        // If requested, apply camera height to initial view
        if (applyInitialView) {
          updateInitialMapView();
        }
        
        // Hide loading
        loadingEl.style.display = 'none';
      } catch (error) {
        console.error('Error loading route:', error);
        alert('Error loading route data. Please try again.');
        loadingEl.style.display = 'none';
      }
    }
    
    // Draw elevation profile
    function drawElevationProfile() {
      const ctx = elevationCanvas.getContext('2d');
      const width = elevationCanvas.clientWidth;
      const height = elevationCanvas.clientHeight;
      
      // Set canvas dimensions
      elevationCanvas.width = width;
      elevationCanvas.height = height;
      
      // Clear canvas
      ctx.clearRect(0, 0, width, height);
      
      // Calculate elevation range with padding
      const padding = (maxElevation - minElevation) * 0.1;
      const elevationMin = Math.max(0, minElevation - padding);
      const elevationMax = maxElevation + padding;
      const elevationRange = elevationMax - elevationMin;
      
      // Draw profile
      ctx.beginPath();
      ctx.moveTo(0, height - ((elevationProfile[0] - elevationMin) / elevationRange * height));
      
      for (let i = 1; i < elevationProfile.length; i++) {
        const x = i / (elevationProfile.length - 1) * width;
        const y = height - ((elevationProfile[i] - elevationMin) / elevationRange * height);
        ctx.lineTo(x, y);
      }
      
      // Close path at bottom
      ctx.lineTo(width, height);
      ctx.lineTo(0, height);
      ctx.closePath();
      
      // Fill gradient
      const gradient = ctx.createLinearGradient(0, 0, 0, height);
      gradient.addColorStop(0, 'rgba(231, 76, 60, 0.7)');
      gradient.addColorStop(0.5, 'rgba(41, 128, 185, 0.5)');
      gradient.addColorStop(1, 'rgba(41, 128, 185, 0.2)');
      ctx.fillStyle = gradient;
      ctx.fill();
      
      // Draw outline
      ctx.beginPath();
      ctx.moveTo(0, height - ((elevationProfile[0] - elevationMin) / elevationRange * height));
      
      for (let i = 1; i < elevationProfile.length; i++) {
        const x = i / (elevationProfile.length - 1) * width;
        const y = height - ((elevationProfile[i] - elevationMin) / elevationRange * height);
        ctx.lineTo(x, y);
      }
      
      ctx.strokeStyle = '#3498db';
      ctx.lineWidth = 2;
      ctx.stroke();
      
      // Draw axes
      ctx.beginPath();
      ctx.moveTo(0, height);
      ctx.lineTo(width, height);
      ctx.strokeStyle = '#aaa';
      ctx.lineWidth = 1;
      ctx.stroke();
      
      // Draw labels
      ctx.fillStyle = '#666';
      ctx.font = '10px sans-serif';
      ctx.fillText(`${Math.round(elevationMin)}m`, 5, height - 5);
      ctx.fillText(`${Math.round(elevationMax)}m`, 5, 15);
      ctx.fillText('0 km', 5, height - 20);
      ctx.fillText(`${totalDistance.toFixed(1)} km`, width - 40, height - 20);
    }
    
    // Update elevation marker
    function updateElevationMarker(progress) {
      const width = elevationCanvas.clientWidth;
      const position = progress * width;
      
      elevationMarker.style.display = 'block';
      elevationMarker.style.left = `${position}px`;
    }
    
    // Variable to track animation state
    let animationStopped = false;
    
    // Toggle animation (start/pause/resume)
    function toggleAnimation() {
      // Check if animation is currently running
      const isAnimationRunning = !!animationId;
      
      if (isAnimationRunning) {
        // If running, pause the animation
        pauseAnimation();
      } else {
        // If not running, start or resume the animation
        startAnimation();
      }
    }
    
    // Start or resume animation
    function startAnimation() {
      // Cancel any existing animation (just to be safe)
      if (animationId) {
        cancelAnimationFrame(animationId);
        animationId = null;
      }
      
      // Safety check for route data
      if (!routeCoordinates || routeCoordinates.length === 0) {
        console.warn('Cannot start animation: No route data loaded');
        alert('Please select a route first');
        return;
      }
      
      // Disable map interactions during animation
      map.dragPan.disable();
      map.scrollZoom.disable();
      map.doubleClickZoom.disable();
      map.touchZoomRotate.disable();
      
      // Update button states
      toggleBtn.textContent = "Pause";
      resetBtn.disabled = false;
      positionSlider.disabled = true;
      
      // Reset to beginning if at end of route
      if (currentRouteDistance >= routeDistances[routeDistances.length - 1] * 1000) {
        currentPoint = 0;
        currentPointFloat = 0;
        currentRouteDistance = 0;
        animationStopped = false;
      }
      
      // Only reset camera position if starting a new animation, not resuming from pause
      // This ensures smooth transitions when resuming animation after using the slider
      if (routeCoordinates.length > 0 && !animationStopped) {
        // For brand new animation (not resume), initialize camera position
        currentCameraPos = { 
          lng: routeCoordinates[currentPoint][0], 
          lat: routeCoordinates[currentPoint][1] 
        };
        targetCameraPos = { 
          lng: routeCoordinates[currentPoint][0], 
          lat: routeCoordinates[currentPoint][1] 
        };
        
        // Calculate initial bearing if we have enough points
        if (routeCoordinates.length > currentPoint + 1) {
          const bearing = calculateBearing(
            routeCoordinates[currentPoint], 
            routeCoordinates[Math.min(currentPoint + 5, routeCoordinates.length - 1)]
          );
          currentCameraBearing = bearing;
          targetCameraBearing = bearing;
        } else {
          currentCameraBearing = 0;
          targetCameraBearing = 0;
        }
        
        // Reset the look-ahead index
        lastLookAheadIndex = currentPoint;
      }
      // When resuming from a pause (especially after slider adjustments),
      // we don't reset camera position as it would cause a jump
      
      // Clear the stopped flag when starting again
      animationStopped = false;
      
      // Start the animation
      animateRoute();
    }
    
    // Pause animation
    function pauseAnimation() {
      if (animationId) {
        cancelAnimationFrame(animationId);
        animationId = null;
      }
      
      // Re-enable map interactions when animation stops
      map.dragPan.enable();
      map.scrollZoom.enable();
      map.doubleClickZoom.enable();
      map.touchZoomRotate.enable();
      
      // Set the flag so we know animation was stopped mid-way
      animationStopped = true;
      
      // Update UI elements
      toggleBtn.textContent = "Resume";
      resetBtn.disabled = false;
      positionSlider.disabled = false;
    }
    
    // Reset animation
    function resetAnimation() {
      if (animationId) {
        cancelAnimationFrame(animationId);
        animationId = null;
      }
      
      // Ensure map interactions are enabled
      map.dragPan.enable();
      map.scrollZoom.enable();
      map.doubleClickZoom.enable();
      map.touchZoomRotate.enable();
      
      // Reset position counters
      currentPoint = 0;
      currentPointFloat = 0;
      currentRouteDistance = 0;
      
      // Clear tracking variables
      animationStopped = false;
      prevBearing = undefined; // Reset bearing history
      prevCameraPos = null; // Reset camera velocity tracking
      prevCameraBearingRad = undefined;
      prevCameraPitch = undefined;
      prevCameraZoom = undefined;
      
      // Reset toggle button text
      toggleBtn.textContent = "Start";
      
      if (routeCoordinates.length > 0) {
        updatePointPosition(routeCoordinates[0]);
        
        // Reset camera and camera tracking variables
        currentCameraPos = { 
          lng: routeCoordinates[0][0], 
          lat: routeCoordinates[0][1] 
        };
        targetCameraPos = { 
          lng: routeCoordinates[0][0], 
          lat: routeCoordinates[0][1] 
        };
        currentCameraBearing = 0;
        targetCameraBearing = 0;
        lastLookAheadIndex = 0;
        
        // Use our new camera system for a smooth initial view
        const riderCoord = {
          lng: routeCoordinates[0][0],
          lat: routeCoordinates[0][1]
        };
        
        updateCamera(riderCoord, 0, {
          transitionDuration: 1500
        });
      }
      
      // Reset UI elements
      elevationMarker.style.display = 'none';
      distanceTraveledEl.textContent = '0.0 km';
      currentElevationEl.textContent = '–';
      currentGradientEl.textContent = '–';
      progressEl.textContent = '0%';
      positionSlider.value = 0;
      
      // Update button states
      toggleBtn.disabled = false;
      resetBtn.disabled = true;
      positionSlider.disabled = false;
    }
    
    // Function to update map view based on current camera height and angle
    function updateInitialMapView() {
      if (routeCoordinates.length === 0) return;
      
      // Convert slider value (1-100) to actual camera parameters
      // For a closer minimum zoom (2x closer) and less far maximum (2x closer)
      const sliderMin = 1;
      const sliderMax = 100;
      
      // Adjusted height range - making closest view much closer
      const actualMinHeight = 0.8;  // Much closer view (was 2.5m)
      const actualMaxHeight = 250;  // Keep this the same
      
      // Map slider value to actual height using exponential scale for better control
      // This gives finer control at closer distances
      const normalizedSliderValue = (cameraHeight - sliderMin) / (sliderMax - sliderMin);
      const actualHeight = actualMinHeight * Math.pow(actualMaxHeight / actualMinHeight, normalizedSliderValue);
      
      // Zoom range (higher number = closer)
      // Increase minimum zoom for a much closer view at minimum height
      const minZoom = 19.0; // Increased from 16.5 for a much closer view
      const maxZoom = 11.5; // Keep maximum zoom the same
      
      // Calculate zoom level (logarithmic scale)
      const zoomLevel = maxZoom + ((Math.log(actualMaxHeight) - Math.log(actualHeight)) / 
                                  (Math.log(actualMaxHeight) - Math.log(actualMinHeight))) * (minZoom - maxZoom);
      
      // Use the camera angle directly from the slider instead of calculating based on height
      const pitch = cameraAngle;
      
      // Apply the new view
      map.flyTo({
        center: [routeCoordinates[0][0], routeCoordinates[0][1]],
        zoom: zoomLevel,
        pitch: pitch,
        bearing: 0
      });
    }
    
    // Global variables for smooth camera system
    let currentCameraPos = { lng: 0, lat: 0 };
    let currentCameraBearing = 0;
    let currentCameraZoom = 15; // Default zoom level
    let currentCameraPitch = 45; // Default pitch (degrees)
    let currentCameraBearingRad = 0; // Bearing in radians
    
    // Add variable to track fractional position 
    let currentPointFloat = 0;
    
    // Variables for advanced camera interpolation with velocity damping
    let prevCameraPos = null; // Previous camera position for velocity calculation
    let prevCameraBearingRad = undefined; // Previous bearing for velocity calculation
    let prevCameraPitch = undefined; // Previous pitch for velocity calculation
    let prevCameraZoom = undefined; // Previous zoom for velocity calculation
    
    // Variables for camera interpolation
    let cameraInterpolationActive = false;
    let cameraInterpolationStartTime = 0;
    let cameraInterpolationDuration = 0;
    let cameraStartPos = { lng: 0, lat: 0 };
    let cameraTargetPos = { lng: 0, lat: 0 };
    let cameraStartBearing = 0;
    let cameraTargetBearing = 0;
    let cameraStartPitch = 45;
    let cameraTargetPitch = 45;
    let cameraStartZoom = 13;
    let cameraTargetZoom = 13;
    
    // Variables for adaptive path smoothing
    let lastAppliedZoom = 0; // Track last zoom level used for path smoothing
    let lastLookAheadIndex = 0; // Track last index used for look-ahead calculation
    
    // Clean, simplified animation function that uses our new camera system
    function animateRoute() {
      // Safety check to avoid errors if route data isn't loaded
      if (!routeCoordinates || routeCoordinates.length === 0 || !routeDistances || routeDistances.length === 0) {
        pauseAnimation();
        console.warn('No route coordinates available for animation');
        return;
      }
      
      // Check if we've reached the end of the route
      if (currentRouteDistance >= routeDistances[routeDistances.length - 1] * 1000) { // Convert km to m
        pauseAnimation();
        // Reset button text to "Start" when animation completes
        toggleBtn.textContent = "Start";
        animationStopped = false;
        
        // Ensure map interactions are re-enabled at the end of animation
        map.dragPan.enable();
        map.scrollZoom.enable();
        map.doubleClickZoom.enable();
        map.touchZoomRotate.enable();
        
        // Enable position slider
        positionSlider.disabled = false;
        
        return;
      }
      
      // Update the camera smoothly - always call this regardless of active flag
      updateCameraInterpolation();
      
      // Check if rider is visible and adjust camera if needed
      checkRiderVisibility();
      
      // Speed in meters per frame - consistent regardless of point spacing
      // animationSpeed is a multiplier (0.1 to 1.0)
      // Base speed of 5 meters per frame * speed multiplier
      const distanceIncrement = 5 * animationSpeed;
      
      // Update current distance along route
      currentRouteDistance += distanceIncrement;
      
      // Convert to km for route lookup
      const currentDistanceKm = currentRouteDistance / 1000;
      
      // Always use the detailed route for rider position
      const riderSegment = calculateSegmentForDistance(currentDistanceKm, false);
      const riderBeforeIdx = riderSegment.beforeIdx;
      const riderAfterIdx = riderSegment.afterIdx;
      const riderFraction = riderSegment.fraction;
      
      // Get the points for rider interpolation
      const riderBeforePoint = routeCoordinates[riderBeforeIdx];
      const riderAfterPoint = routeCoordinates[riderAfterIdx];
      
      // Create interpolated point for the rider position
      const interpolatedPoint = [
        riderBeforePoint[0] + (riderAfterPoint[0] - riderBeforePoint[0]) * riderFraction,
        riderBeforePoint[1] + (riderAfterPoint[1] - riderBeforePoint[1]) * riderFraction
      ];
      
      // Include elevation if available
      if (riderBeforePoint.length > 2 && riderAfterPoint.length > 2) {
        interpolatedPoint[2] = riderBeforePoint[2] + (riderAfterPoint[2] - riderBeforePoint[2]) * riderFraction;
      }
      
      // Update position
      updatePointPosition(interpolatedPoint);
      
      // Update tracking information
      currentPoint = riderBeforeIdx;
      currentPointFloat = riderBeforeIdx + riderFraction;
      
      // Get the rider's current position as a coordinate object
      const riderCoord = {
        lng: interpolatedPoint[0],
        lat: interpolatedPoint[1]
      };
      
      // Update camera position every frame if we're not in the middle of a smooth transition
      // This creates a butter-smooth camera that follows the rider
      if (!cameraInterpolationActive) {
        // Calculate the bearing between current and next point
        const nextBearing = calculateBearing(
          riderBeforePoint,
          riderAfterPoint
        );
        
        // Store for next frame
        currentCameraBearing = nextBearing;
        
        // Initiate camera update with the current parameters
        updateCamera(riderCoord, nextBearing, {
          // Use a consistent longer duration for smoother transitions
          transitionDuration: 2000
        });
      }
      
      // Update UI
      updateProgress();
      
      // Continue animation
      animationId = requestAnimationFrame(animateRoute);
    }
    
    // Calculate perpendicular offset for drone view
    function calculatePerpendicularOffset(point, bearing, distance) {
      // Convert bearing to radians and add 90 degrees to get perpendicular
      const perpBearing = ((bearing + 90) % 360) * Math.PI / 180;
      
      // Calculate offset
      return {
        lng: point.lng + distance * Math.sin(perpBearing),
        lat: point.lat + distance * Math.cos(perpBearing)
      };
    }
    
    // Update point position
    function updatePointPosition(coord) {
      // Safety check to prevent errors
      if (!coord || !Array.isArray(coord) || coord.length < 2) {
        console.warn('Invalid coordinate passed to updatePointPosition:', coord);
        return;
      }
      
      // Always use the detailed route for rider position
      const riderSegment = calculateSegmentForDistance(currentDistanceKm, false);
      const riderBeforeIdx = riderSegment.beforeIdx;
      const riderAfterIdx = riderSegment.afterIdx;
      const riderFraction = riderSegment.fraction;
      
      // Get the points for rider interpolation
      const riderBeforePoint = routeCoordinates[riderBeforeIdx];
      const riderAfterPoint = routeCoordinates[riderAfterIdx];
      
      // Create interpolated point for the rider position
      const interpolatedPoint = [
        riderBeforePoint[0] + (riderAfterPoint[0] - riderBeforePoint[0]) * riderFraction,
        riderBeforePoint[1] + (riderAfterPoint[1] - riderBeforePoint[1]) * riderFraction
      ];
      
      // Include elevation if available
      if (riderBeforePoint.length > 2 && riderAfterPoint.length > 2) {
        interpolatedPoint[2] = riderBeforePoint[2] + (riderAfterPoint[2] - riderBeforePoint[2]) * riderFraction;
      }
      
      // Update position
      updatePointPosition(interpolatedPoint);
      
      // Update tracking information
      currentPoint = riderBeforeIdx;
      currentPointFloat = riderBeforeIdx + riderFraction;
      
      // Get the rider's current position as a coordinate object
      const riderCoord = {
        lng: interpolatedPoint[0],
        lat: interpolatedPoint[1]
      };
      
      // Update camera position every frame if we're not in the middle of a smooth transition
      // This creates a butter-smooth camera that follows the rider
      if (!cameraInterpolationActive) {
        // Calculate the bearing between current and next points
        // This gives us the direction of travel
        let bearing = currentCameraBearing; // Use current bearing as fallback
        
        // Calculate bearing from current and next point
        const nextBearing = calculateBearing(
          riderBeforePoint,
          riderAfterPoint
        );
        
        // Use the newly calculated bearing
        bearing = nextBearing;
        
        // Store for next frame
        currentCameraBearing = bearing;
        
        // Initiate camera update with the current parameters
        updateCamera(riderCoord, bearing, {
          // Use a consistent longer duration for smoother transitions
          transitionDuration: 2000
        });
      }
      
      // Update UI
      updateProgress();
      
      // Continue animation
      animationId = requestAnimationFrame(animateRoute);
    }
    
    // Calculate perpendicular offset for drone view
    function calculatePerpendicularOffset(point, bearing, distance) {
      // Convert bearing to radians and add 90 degrees to get perpendicular
      const perpBearing = ((bearing + 90) % 360) * Math.PI / 180;
      
      // Calculate offset
      return {
        lng: point.lng + distance * Math.sin(perpBearing),
        lat: point.lat + distance * Math.cos(perpBearing)
      };
    }
    
    // Update point position
    function updatePointPosition(coord) {
      // Safety check to prevent errors
      if (!coord || !Array.isArray(coord) || coord.length < 2) {
        console.warn('Invalid coordinate passed to updatePointPosition:', coord);
        return;
      }
      
      const point = {
        type: 'Feature',
        properties: {},
        geometry: {
          type: 'Point',
          coordinates: [coord[0], coord[1]]
        }
      };
      
      // Check if the map and source exist before updating
      if (map && map.getSource('point')) {
        try {
          map.getSource('point').setData(point);
        } catch (e) {
          console.warn('Error updating point position:', e);
        }
      }
    }
    
    // Advanced function to check rider visibility and make smooth adjustments
    // to keep rider centered in the viewport with adaptive behavior based on zoom level
    function checkRiderVisibility() {
      // Ensure map is initialized
      if (!map || !map.getSource('point')) return;
      
      try {
        // Get the current position of the rider marker
        const pointData = map.getSource('point')._data;
        if (!pointData || !pointData.geometry || !pointData.geometry.coordinates) return;
        
        // Convert the geographic coordinate to screen coordinates
        const riderPoint = map.project([
          pointData.geometry.coordinates[0], 
          pointData.geometry.coordinates[1]
        ]);
        
        // Get viewport dimensions
        const viewport = map.getContainer();
        const viewportWidth = viewport.offsetWidth;
        const viewportHeight = viewport.offsetHeight;
        
        // Get current zoom for adaptive behavior
        const currentZoom = map.getZoom();
        
        // Create zoom-based factors for adaptive behavior
        // Lower zoom = wider safe area (less camera movement)
        // Higher zoom = narrower safe area (keep centered)
        const zoomFactor = Math.min(1, Math.max(0.3, (currentZoom - 11) / 8)); // 0.3 at zoom 11, 1.0 at zoom 19
        
        // Calculate ideal target position within viewport
        // Center horizontally, slightly above vertical center
        const idealX = viewportWidth * 0.5;  // Center horizontally
        const idealY = viewportHeight * 0.45; // Slightly above center vertically
        
        // Define a safe area rectangle that's adaptive to zoom level
        // When zoomed out: larger safe area (less frequent adjustments)
        // When zoomed in: tighter safe area (more precise centering)
        const safeAreaWidth = viewportWidth * (0.4 - (0.2 * zoomFactor)); // 40% to 20% of viewport width
        const safeAreaHeight = viewportHeight * (0.4 - (0.2 * zoomFactor)); // 40% to 20% of viewport height
        
        const safeArea = {
          left: idealX - (safeAreaWidth / 2),
          right: idealX + (safeAreaWidth / 2),
          top: idealY - (safeAreaHeight / 2),
          bottom: idealY + (safeAreaHeight / 2)
        };
        
        // Check if the rider is outside the safe area
        const isRiderVisible = 
          riderPoint.x >= safeArea.left && 
          riderPoint.x <= safeArea.right && 
          riderPoint.y >= safeArea.top && 
          riderPoint.y <= safeArea.bottom;
        
        // If the rider is not visible in the safe area, adjust the camera target
        // This will be smoothly applied by our interpolation system
        if (!isRiderVisible) {
          // Get rider geographic coordinates
          const riderCoord = {
            lng: pointData.geometry.coordinates[0],
            lat: pointData.geometry.coordinates[1]
          };
          
          // Get current camera values
          const currentBearing = map.getBearing();
          
          // Calculate distance from rider to ideal position
          const distanceX = riderPoint.x - idealX;
          const distanceY = riderPoint.y - idealY;
          
          // Calculate adjustment strength based on distance from ideal position
          // More distance = stronger adjustment (proportional)
          // Apply zoom factor to make corrections stronger when zoomed in
          const xStrength = 0.05 + (0.1 * zoomFactor);
          const yStrength = 0.05 + (0.1 * zoomFactor);
          
          // Calculate look-ahead and side adjustments
          // We scale by viewport size to make adjustments relative to screen size
          let lookAheadDistanceAdjust = 0;
          let sideDistanceAdjust = 0;
          
          // Apply horizontal adjustment (transform to side offset)
          // We need to consider the bearing to translate screen space to map space
          if (Math.abs(distanceX) > safeAreaWidth / 2) {
            sideDistanceAdjust = -1 * (distanceX / viewportWidth) * xStrength;
          }
          
          // Apply vertical adjustment (transform to look-ahead distance)
          if (Math.abs(distanceY) > safeAreaHeight / 2) {
            // Above ideal = negative adjustment (look less ahead)
            // Below ideal = positive adjustment (look more ahead)
            lookAheadDistanceAdjust = (distanceY / viewportHeight) * yStrength;
            
            // For extreme cases, adjust zoom and pitch too
            if (Math.abs(distanceY) > viewportHeight * 0.3) {
              // If rider is way too high (near horizon)
              if (distanceY < 0) {
                // Increase zoom to bring rider closer
                const zoomAdjust = Math.min(0.5, Math.abs(distanceY) / viewportHeight);
                cameraTargetZoom = Math.min(19, currentCameraZoom + zoomAdjust);
              } 
              // If rider is way too low (near bottom)
              else {
                // Adjust pitch to look more downward
                const pitchAdjust = Math.min(5, Math.abs(distanceY) / viewportHeight * 10);
                cameraTargetPitch = Math.min(85, currentCameraPitch + pitchAdjust);
              }
            }
          }
          
          // Apply adjustments through our ideal camera position calculation
          // Our smooth camera system will gradually move to this target
          if (lookAheadDistanceAdjust !== 0 || sideDistanceAdjust !== 0) {
            const idealCameraPos = calculateIdealCameraPosition(
              riderCoord, 
              currentBearing, 
              animationSpeed,
              cameraHeight, 
              cameraTargetPitch,
              sideDistanceAdjust,
              lookAheadDistanceAdjust
            );
            
            // Visualize adjustment severity (optional) with color-coded marker
            const adjustmentMagnitude = Math.sqrt(
              Math.pow(lookAheadDistanceAdjust, 2) + 
              Math.pow(sideDistanceAdjust, 2)
            );
            
            // Set the target - the interpolation system handles smooth transition
            cameraTargetPos = idealCameraPos;
          }
        }
      } catch (e) {
        console.warn('Error checking rider visibility:', e);
      }
    }
    
    // Calculate bearing between two coordinates
    function calculateBearing(start, end) {
      // Safety check for invalid coordinates
      if (!start || !end || !Array.isArray(start) || !Array.isArray(end) || 
          start.length < 2 || end.length < 2) {
        console.warn('Invalid coordinates for bearing calculation:', start, end);
        return 0; // Default bearing
      }
      
      try {
        const startLat = start[1] * Math.PI / 180;
        const startLng = start[0] * Math.PI / 180;
        const endLat = end[1] * Math.PI / 180;
        const endLng = end[0] * Math.PI / 180;
        
        const y = Math.sin(endLng - startLng) * Math.cos(endLat);
        const x = Math.cos(startLat) * Math.sin(endLat) - 
                  Math.sin(startLat) * Math.cos(endLat) * Math.cos(endLng - startLng);
        
        const bearing = Math.atan2(y, x) * 180 / Math.PI;
        return (bearing + 360) % 360;
      } catch (e) {
        console.warn('Error calculating bearing:', e);
        return 0; // Default bearing on error
      }
    }
    
    // Update progress and UI
    function updateProgress() {
      if (routeCoordinates.length === 0 || routeDistances.length === 0) return;
      
      // Calculate progress percentage based on distance
      const totalDistanceMeters = routeDistances[routeDistances.length - 1] * 1000; // km to m
      const progress = currentRouteDistance / totalDistanceMeters;
      
      // Update progress element
      progressEl.textContent = `${Math.round(progress * 100)}%`;
      
      // Update distance traveled
      distanceTraveledEl.textContent = `${(currentRouteDistance / 1000).toFixed(1)} km`;
      
      // Update position slider without triggering its change event
      positionSlider.value = progress * 100;
      
      // Update elevation marker
      updateElevationMarker(progress);
      
      // Get current and next points for interpolation
      const currentIdx = Math.floor(currentPointFloat);
      const nextIdx = Math.min(currentIdx + 1, routeCoordinates.length - 1);
      const pointFraction = currentPointFloat - currentIdx;
      
      // Get interpolated elevation
      let currentElevation;
      if (routeCoordinates[currentIdx].length > 2 && routeCoordinates[nextIdx].length > 2) {
        currentElevation = routeCoordinates[currentIdx][2] + 
                          (routeCoordinates[nextIdx][2] - routeCoordinates[currentIdx][2]) * pointFraction;
      } else {
        currentElevation = routeCoordinates[currentIdx][2] || 0;
      }
      
      currentElevationEl.textContent = `${Math.round(currentElevation)} m`;
      
      // Calculate gradient using about 100m look-behind distance
      // Find a point ~100m back from our current position
      let lookBehindDistance = Math.max(0, currentRouteDistance - 100); // meters
      let lookBehindDistanceKm = lookBehindDistance / 1000;
      let prevPointIdx = 0;
      
      // Find the closest point for our look-behind distance
      for (let i = 0; i < routeDistances.length; i++) {
        if (routeDistances[i] >= lookBehindDistanceKm) {
          prevPointIdx = Math.max(0, i - 1);
          break;
        }
      }
      
      // Calculate the elevation change over this distance
      const prevElevation = routeCoordinates[prevPointIdx][2] || 0;
      const elevationChange = currentElevation - prevElevation;
      
      // Calculate the actual distance between these points
      const actualDistance = (currentRouteDistance - (routeDistances[prevPointIdx] * 1000)); // in meters
      
      if (actualDistance > 10) { // Only calculate gradient if we have sufficient distance
        const gradient = (elevationChange / actualDistance) * 100;
        currentGradientEl.textContent = `${gradient.toFixed(1)}%`;
        
        // Change gradient text color based on steepness
        if (gradient > 8) {
          currentGradientEl.style.color = '#e74c3c'; // Steep - red
        } else if (gradient > 4) {
          currentGradientEl.style.color = '#f39c12'; // Moderate - orange
        } else if (gradient < -4) {
          currentGradientEl.style.color = '#2ecc71'; // Descent - green
        } else {
          currentGradientEl.style.color = '#2c3e50'; // Flat - default
        }
        
        // We've removed the proactive camera adjustment from here and moved the logic
        // to our main animation loop with better handling of downhill sections
      }
    }
    
    // Add terrain and common sources/layers function
    function addTerrainAndSources(exaggerationValue = 1.0) {
      try {
        // Add terrain source if it doesn't exist
        if (!map.getSource('mapbox-dem')) {
          map.addSource('mapbox-dem', {
            'type': 'raster-dem',
            'url': 'mapbox://mapbox.mapbox-terrain-dem-v1',
            'tileSize': 512,
            'maxzoom': 14
          });
        }
        
        // Add sky layer if it doesn't exist
        if (!map.getLayer('sky')) {
          map.addLayer({
            'id': 'sky',
            'type': 'sky',
            'paint': {
              'sky-type': 'atmosphere',
              'sky-atmosphere-sun': [0.0, 0.0],
              'sky-atmosphere-sun-intensity': 15
            }
          });
        }
        
        // Use fixed 1.0 terrain exaggeration - no slider adjustment
        const exaggeration = exaggerationValue;
        
        // Add 3D terrain
        map.setTerrain({ 'source': 'mapbox-dem', 'exaggeration': exaggeration });
        
        // Success!
        return true;
      } catch (e) {
        console.warn('Error setting up terrain:', e);
        return false;
      }
    }
    
    // Terrain exaggeration is now fixed at 1.0x - function removed
    
    // Simple pre-calculation function to update the cached height value
    function preCalculateRouteData() {
      // Simply update the stored height value
      lastPreCalcHeight = cameraHeight;
      // All actual calculations are done in real-time during animation
    }
  
    // Helper function to get the current rider position on screen
    function getRiderScreenPosition() {
      // Safety check
      if (!map || !map.getSource('point')) return null;
      
      try {
        // Get the rider's current position
        const pointSource = map.getSource('point');
        if (!pointSource || !pointSource._data) return null;
        
        const pointFeature = pointSource._data;
        if (!pointFeature || !pointFeature.geometry || !pointFeature.geometry.coordinates) return null;
      
        const riderCoords = pointFeature.geometry.coordinates;
        
        // Convert rider coordinates to screen coordinates
        const riderScreenPoint = map.project(riderCoords);
        return riderScreenPoint;
      } catch (e) {
        console.warn('Error getting rider screen position:', e);
        return null;
      }
    }
    
    // Advanced function to check rider visibility with zoom-dependent safe zones
    function isRiderCompletelyOutOfView(riderPoint) {
      if (!riderPoint) return false;
      
      const viewport = map.getContainer();
      const viewportWidth = viewport.offsetWidth;
      const viewportHeight = viewport.offsetHeight;
      
      // Get current zoom level
      const currentZoom = map.getZoom();
      
      // Define a dynamic margin based on zoom level
      // Lower zoom = wider margin (more conservative)
      // Higher zoom = narrower margin (more aggressive)
      const zoomFactor = Math.min(1, Math.max(0.3, (currentZoom - 11) / 8)); // 0.3 to 1.0
      const margin = 50 * (1 - zoomFactor * 0.7); // 15px to 50px margin
      
      // Check if rider is completely off screen with dynamic margin
      // When zoomed out, we're more conservative about calling it "out of view"
      // When zoomed in, we're more aggressive about keeping rider centered
      return (
        riderPoint.x < -margin ||
        riderPoint.x > viewportWidth + margin ||
        riderPoint.y < -margin ||
        riderPoint.y > viewportHeight + margin
      );
    }
    
    // Enhanced helper function to check if rider is visible in optimal area
    function isRiderVisible(riderPoint) {
      if (!riderPoint) return false;
      
      const viewport = map.getContainer();
      const viewportWidth = viewport.offsetWidth;
      const viewportHeight = viewport.offsetHeight;
      
      // Get current zoom for adaptive behavior
      const currentZoom = map.getZoom();
      
      // Create zoom-based factors for adaptive behavior
      // Lower zoom = wider safe area (less camera movement)
      // Higher zoom = narrower safe area (more precise centering)
      const zoomFactor = Math.min(1, Math.max(0.3, (currentZoom - 11) / 8)); // 0.3 at zoom 11, 1.0 at zoom 19
      
      // Calculate ideal target position within viewport
      // Center horizontally, slightly above center vertically
      const idealX = viewportWidth * 0.5;  // Center horizontally
      const idealY = viewportHeight * 0.45; // Slightly above center vertically
      
      // Define a safe area rectangle that's adaptive to zoom level
      // When zoomed out: larger safe area (less frequent adjustments)
      // When zoomed in: tighter safe area (more precise centering)
      const safeAreaWidth = viewportWidth * (0.4 - (0.2 * zoomFactor)); // 40% to 20% of viewport width
      const safeAreaHeight = viewportHeight * (0.4 - (0.2 * zoomFactor)); // 40% to 20% of viewport height
      
      const safeArea = {
        left: idealX - (safeAreaWidth / 2),
        right: idealX + (safeAreaWidth / 2),
        top: idealY - (safeAreaHeight / 2),
        bottom: idealY + (safeAreaHeight / 2)
      };
      
      // Check if rider is within the optimal viewing area
      return (
        riderPoint.x >= safeArea.left && 
        riderPoint.x <= safeArea.right && 
        riderPoint.y >= safeArea.top && 
        riderPoint.y <= safeArea.bottom
      );
    }
    
    // Advanced function to adjust camera with smooth, natural movement
    // that's appropriate for the current zoom level and camera angle
    function adjustCameraToKeepRiderVisible(riderPoint, aggressive = true) {
      if (!riderPoint) return;
      
      const viewport = map.getContainer();
      const viewportWidth = viewport.offsetWidth;
      const viewportHeight = viewport.offsetHeight;
      
      // Get current zoom and pitch for adaptive behavior
      const currentZoom = map.getZoom();
      const currentPitch = map.getPitch();
      
      // Create adaptive factors based on zoom and pitch
      const zoomFactor = Math.min(1, Math.max(0.3, (currentZoom - 11) / 8)); // 0.3 to 1.0
      const pitchFactor = currentPitch / 85; // 0 to 1.0
      
      // Calculate ideal target position that feels natural at the current zoom level
      // For low pitch (looking forward), we want rider to be lower in frame
      // For high pitch (looking down), we want rider to be closer to center
      const idealX = viewportWidth * 0.5;  // Always center horizontally
      const idealY = viewportHeight * (0.6 - (0.15 * pitchFactor)); // Lower at low pitch, higher at high pitch
      
      // Define the safe area based on zoom level and adjustment aggressiveness
      // Aggressive = small safe area (precise centering)
      // Non-aggressive = larger safe area (only adjust when clearly needed)
      const safeAreaWidthPercent = aggressive ? 
        (0.2 + (0.1 * (1 - zoomFactor))) : // 20-30% for aggressive (smaller at high zoom)
        (0.4 + (0.2 * (1 - zoomFactor)));  // 40-60% for non-aggressive (smaller at high zoom)
      
      const safeAreaHeightPercent = aggressive ? 
        (0.2 + (0.1 * (1 - zoomFactor))) : // 20-30% for aggressive (smaller at high zoom)
        (0.4 + (0.2 * (1 - zoomFactor)));  // 40-60% for non-aggressive (smaller at high zoom)
      
      const safeArea = {
        left: idealX - (viewportWidth * safeAreaWidthPercent / 2),
        right: idealX + (viewportWidth * safeAreaWidthPercent / 2),
        top: idealY - (viewportHeight * safeAreaHeightPercent / 2),
        bottom: idealY + (viewportHeight * safeAreaHeightPercent / 2)
      };
      
      // Calculate distance from rider to ideal position
      const distanceX = riderPoint.x - idealX;
      const distanceY = riderPoint.y - idealY;
      
      // Only apply adjustments if rider is outside safe area
      const isOutsideX = riderPoint.x < safeArea.left || riderPoint.x > safeArea.right;
      const isOutsideY = riderPoint.y < safeArea.top || riderPoint.y > safeArea.bottom;
      
      if (!isOutsideX && !isOutsideY) return;
      
      // Calculate adjustments based on distance from ideal position
      // These are normalized to viewport size for consistent behavior
      let adjustX = 0;
      let adjustY = 0;
      
      if (isOutsideX) {
        adjustX = distanceX / viewportWidth;
      }
      
      if (isOutsideY) {
        adjustY = distanceY / viewportHeight;
      }
      
      // Get current camera settings
      const currentBearing = map.getBearing();
      const bearingRad = currentBearing * Math.PI / 180;
      
      // Apply bearing-adjusted transformations to get correct camera movement
      // This is critical for natural movement when the camera is rotated
      const cosB = Math.cos(bearingRad);
      const sinB = Math.sin(bearingRad);
      const rotX = adjustX * cosB - adjustY * sinB;
      const rotY = adjustX * sinB + adjustY * cosB;
      
      // Calculate adjustment strength based on how far outside safe area
      // and zoom level (more responsive at high zoom, more stable at low zoom)
      const adjustStrength = aggressive ? 
        (0.5 + (0.3 * zoomFactor)) : // 0.5-0.8 for aggressive (stronger at high zoom)
        (0.3 + (0.2 * zoomFactor));  // 0.3-0.5 for non-aggressive (stronger at high zoom)
      
      // Apply adjustment through smooth pan
      // For zoomed out view: slower, less aggressive movement
      // For zoomed in view: faster, more precise movement
      const panDuration = aggressive ? 
        300 - (100 * zoomFactor) : // 200-300ms for aggressive (faster at high zoom)
        800 - (300 * zoomFactor);  // 500-800ms for non-aggressive (faster at high zoom)
      
      // Apply the pan with bearing-corrected adjustments
      map.panBy([
        rotX * viewportWidth * adjustStrength,
        rotY * viewportHeight * adjustStrength
      ], {
        duration: panDuration,
        easing: t => 1 - Math.pow(1 - t, 3) // Cubic ease-out for smooth deceleration
      });
      
      // If rider is extremely out of view, also adjust camera pitch and zoom
      const extremeDistance = Math.sqrt(
        Math.pow(distanceX / viewportWidth, 2) + 
        Math.pow(distanceY / viewportHeight, 2)
      );
      
      if (extremeDistance > 0.4 && aggressive) { // If rider is way off (40% of viewport away)
        // Adjust pitch to help see rider
        // If too high on screen: increase pitch to look down more
        // If too low on screen: decrease pitch to look forward more
        if (Math.abs(distanceY) > Math.abs(distanceX)) {
          // Determine pitch adjustment direction based on rider position
          const pitchAdjust = distanceY > 0 ? 
            Math.min(10, Math.abs(distanceY / viewportHeight) * 20) : // If rider too low
            -Math.min(10, Math.abs(distanceY / viewportHeight) * 20);  // If rider too high
          
          // Apply pitch adjustment if significant
          if (Math.abs(pitchAdjust) > 3) {
            const newPitch = Math.min(85, Math.max(10, currentPitch + pitchAdjust));
            map.easeTo({
              pitch: newPitch,
              duration: 600
            });
          }
        }
      }
    }
    
    // Calculate perpendicular offset for drone view
    function calculatePerpendicularOffset(point, bearing, distance) {
      // Convert bearing to radians and add 90 degrees to get perpendicular
      const perpBearing = ((bearing + 90) % 360) * Math.PI / 180;
      
      // Calculate offset
      return {
        lng: point.lng + distance * Math.sin(perpBearing),
        lat: point.lat + distance * Math.cos(perpBearing)
      };
    }
    
    // Update point position
    function updatePointPosition(coord) {
      // Safety check to prevent errors
      if (!coord || !Array.isArray(coord) || coord.length < 2) {
        console.warn('Invalid coordinate passed to updatePointPosition:', coord);
        return;
      }
      
      const point = {
        type: 'Feature',
        properties: {},
        geometry: {
          type: 'Point',
          coordinates: [coord[0], coord[1]]
        }
      };
      
      // Check if the map and source exist before updating
      if (map && map.getSource('point')) {
        try {
          map.getSource('point').setData(point);
        } catch (e) {
          console.warn('Error updating point position:', e);
        }
      }
    }
    
    
    // Calculate bearing between two coordinates
    function calculateBearing(start, end) {
      // Safety check for invalid coordinates
      if (!start || !end || !Array.isArray(start) || !Array.isArray(end) || 
          start.length < 2 || end.length < 2) {
        console.warn('Invalid coordinates for bearing calculation:', start, end);
        return 0; // Default bearing
      }
      
      try {
        const startLat = start[1] * Math.PI / 180;
        const startLng = start[0] * Math.PI / 180;
        const endLat = end[1] * Math.PI / 180;
        const endLng = end[0] * Math.PI / 180;
        
        const y = Math.sin(endLng - startLng) * Math.cos(endLat);
        const x = Math.cos(startLat) * Math.sin(endLat) - 
                  Math.sin(startLat) * Math.cos(endLat) * Math.cos(endLng - startLng);
        
        const bearing = Math.atan2(y, x) * 180 / Math.PI;
        return (bearing + 360) % 360;
      } catch (e) {
        console.warn('Error calculating bearing:', e);
        return 0; // Default bearing on error
      }
    }
    
    // Update progress and UI
    function updateProgress() {
      if (routeCoordinates.length === 0 || routeDistances.length === 0) return;
      
      // Calculate progress percentage based on distance
      const totalDistanceMeters = routeDistances[routeDistances.length - 1] * 1000; // km to m
      const progress = currentRouteDistance / totalDistanceMeters;
      
      // Update progress element
      progressEl.textContent = `${Math.round(progress * 100)}%`;
      
      // Update distance traveled
      distanceTraveledEl.textContent = `${(currentRouteDistance / 1000).toFixed(1)} km`;
      
      // Update position slider without triggering its change event
      positionSlider.value = progress * 100;
      
      // Update elevation marker
      updateElevationMarker(progress);
      
      // Get current and next points for interpolation
      const currentIdx = Math.floor(currentPointFloat);
      const nextIdx = Math.min(currentIdx + 1, routeCoordinates.length - 1);
      const pointFraction = currentPointFloat - currentIdx;
      
      // Get interpolated elevation
      let currentElevation;
      if (routeCoordinates[currentIdx].length > 2 && routeCoordinates[nextIdx].length > 2) {
        currentElevation = routeCoordinates[currentIdx][2] + 
                          (routeCoordinates[nextIdx][2] - routeCoordinates[currentIdx][2]) * pointFraction;
      } else {
        currentElevation = routeCoordinates[currentIdx][2] || 0;
      }
      
      currentElevationEl.textContent = `${Math.round(currentElevation)} m`;
      
      // Calculate gradient using about 100m look-behind distance
      // Find a point ~100m back from our current position
      let lookBehindDistance = Math.max(0, currentRouteDistance - 100); // meters
      let lookBehindDistanceKm = lookBehindDistance / 1000;
      let prevPointIdx = 0;
      
      // Find the closest point for our look-behind distance
      for (let i = 0; i < routeDistances.length; i++) {
        if (routeDistances[i] >= lookBehindDistanceKm) {
          prevPointIdx = Math.max(0, i - 1);
          break;
        }
      }
      
      // Calculate the elevation change over this distance
      const prevElevation = routeCoordinates[prevPointIdx][2] || 0;
      const elevationChange = currentElevation - prevElevation;
      
      // Calculate the actual distance between these points
      const actualDistance = (currentRouteDistance - (routeDistances[prevPointIdx] * 1000)); // in meters
      
      if (actualDistance > 10) { // Only calculate gradient if we have sufficient distance
        const gradient = (elevationChange / actualDistance) * 100;
        currentGradientEl.textContent = `${gradient.toFixed(1)}%`;
        
        // Change gradient text color based on steepness
        if (gradient > 8) {
          currentGradientEl.style.color = '#e74c3c'; // Steep - red
        } else if (gradient > 4) {
          currentGradientEl.style.color = '#f39c12'; // Moderate - orange
        } else if (gradient < -4) {
          currentGradientEl.style.color = '#2ecc71'; // Descent - green
        } else {
          currentGradientEl.style.color = '#2c3e50'; // Flat - default
        }
        
        // We've removed the proactive camera adjustment from here and moved the logic
        // to our main animation loop with better handling of downhill sections
      }
    }
    
    // Add terrain and common sources/layers function
    function addTerrainAndSources(exaggerationValue = 1.0) {
      try {
        // Add terrain source if it doesn't exist
        if (!map.getSource('mapbox-dem')) {
          map.addSource('mapbox-dem', {
            'type': 'raster-dem',
            'url': 'mapbox://mapbox.mapbox-terrain-dem-v1',
            'tileSize': 512,
            'maxzoom': 14
          });
        }
        
        // Add sky layer if it doesn't exist
        if (!map.getLayer('sky')) {
          map.addLayer({
            'id': 'sky',
            'type': 'sky',
            'paint': {
              'sky-type': 'atmosphere',
              'sky-atmosphere-sun': [0.0, 0.0],
              'sky-atmosphere-sun-intensity': 15
            }
          });
        }
        
        // Use fixed 1.0 terrain exaggeration - no slider adjustment
        const exaggeration = exaggerationValue;
        
        // Add 3D terrain
        map.setTerrain({ 'source': 'mapbox-dem', 'exaggeration': exaggeration });
        
        // Add route source and layer if needed
        if (!map.getSource('route') && routeCoordinates.length > 0) {
          map.addSource('route', {
            type: 'geojson',
            data: {
              type: 'Feature',
              properties: {},
              geometry: {
                type: 'LineString',
                coordinates: routeCoordinates.map(coord => [coord[0], coord[1]])
              }
            }
          });
          
          map.addLayer({
            id: 'route',
            type: 'line',
            source: 'route',
            layout: {
              'line-join': 'round',
              'line-cap': 'round'
            },
            paint: {
              'line-color': '#3498db',
              'line-width': 5,
              'line-opacity': 0.8
            }
          });
        }
        
        // Add point source and layer if needed
        if (!map.getSource('point') && routeCoordinates.length > 0) {
          map.addSource('point', {
            type: 'geojson',
            data: {
              type: 'Feature',
              properties: {},
              geometry: {
                type: 'Point',
                coordinates: [routeCoordinates[currentPoint][0], routeCoordinates[currentPoint][1]]
              }
            }
          });
          
          map.addLayer({
            id: 'point',
            type: 'circle',
            source: 'point',
            paint: {
              'circle-radius': 8,
              'circle-color': '#e74c3c',
              'circle-stroke-width': 2,
              'circle-stroke-color': '#ffffff'
            }
          });
        }
      } catch (e) {
        console.warn('Error adding terrain or sources:', e);
      }
    }
  
    // Map style is fixed to Satellite with Streets
    
    // Terrain exaggeration is now fixed at 1.0x - function removed
    
    // We've removed the complex pre-calculation function in favor of a simpler,
    // more direct approach that calculates what we need in real-time.
    
    // Simple pre-calculation function to update the cached height value
    function preCalculateRouteData() {
      // Simply update the stored height value
      lastPreCalcHeight = cameraHeight;
      // All actual calculations are done in real-time during animation
    }
  
    // Helper function to get the current rider position on screen
    function getRiderScreenPosition() {
      // Safety check
      if (!map || !map.getSource('point')) return null;
      
      try {
        // Get the rider's current position
        const pointSource = map.getSource('point');
        if (!pointSource || !pointSource._data) return null;
        
        const pointFeature = pointSource._data;
        if (!pointFeature || !pointFeature.geometry || !pointFeature.geometry.coordinates) return null;
      
        const riderCoords = pointFeature.geometry.coordinates;
        
        // Convert rider coordinates to screen coordinates
        const riderScreenPoint = map.project(riderCoords);
        
        // Get the map container dimensions
        const mapBounds = map.getContainer().getBoundingClientRect();
        const mapWidth = mapBounds.width;
        const mapHeight = mapBounds.height;
        
        return {
          x: riderScreenPoint.x,
          y: riderScreenPoint.y,
          mapWidth: mapWidth,
          mapHeight: mapHeight,
          coords: riderCoords
        };
      } catch (error) {
        console.warn('Error getting rider screen position:', error);
        return null;
      }
    }
    
    // ===== New camera system functions =====
    
    // Set up a camera transition with custom interpolation
    function setupCameraTransition(targetPos, targetBearing, targetPitch, targetZoom, duration = 2000) {
      // Simply store the target values - our continuous interpolation will handle the rest
      cameraTargetPos = targetPos;
      cameraTargetBearing = targetBearing;
      cameraTargetPitch = targetPitch;
      cameraTargetZoom = targetZoom;
    }
    
    // Smoothly interpolate camera position using an advanced damping system with variable lag factors
    function updateCameraInterpolation() {
      // Skip if no target or current position
      if (!cameraTargetPos || !currentCameraPos) return;
      
      // Get current map info for precise adjustments
      const mapWidth = map.getContainer().offsetWidth;
      const mapHeight = map.getContainer().offsetHeight;
      const currentZoom = map.getZoom();
      
      // Adaptive lag factors that change based on zoom level and camera distance from target
      // Lower zoom = more stable camera, higher zoom = more responsive camera
      // This creates natural, cinematic smoothing at different zoom levels
      const zoomFactor = Math.min(1, Math.max(0.3, (currentZoom - 11) / 8)); // 0.3 at zoom 11, 1.0 at zoom 19
      
      // Calculate distance between current and target positions
      const currentLatLng = new mapboxgl.LngLat(currentCameraPos.lng, currentCameraPos.lat);
      const targetLatLng = new mapboxgl.LngLat(cameraTargetPos.lng, cameraTargetPos.lat);
      const distanceToTarget = currentLatLng.distanceTo(targetLatLng);
      
      // Large sudden changes need faster lag (more immediate response)
      // Small adjustments need slower lag (very smooth, gradual changes)
      // This prevents both "laggy" feeling and jerky small movements
      const distanceFactor = Math.min(1, Math.max(0.2, distanceToTarget / 2000)); // 0.2 for small changes, up to 1.0 for large
      
      // Create adaptive lag factors that respond to both zoom and distance
      // Zoomed out + small changes = very smooth, stable camera
      // Zoomed in + big changes = responsive camera that doesn't lag too much
      const positionLagFactor = 0.04 + (0.08 * zoomFactor * distanceFactor);
      const bearingLagFactor = 0.03 + (0.06 * zoomFactor * distanceFactor);
      const pitchLagFactor = 0.04 + (0.06 * zoomFactor * distanceFactor);
      const zoomLagFactor = 0.03 + (0.07 * zoomFactor);
      
      // Add velocity damping for even smoother transitions
      // Store previous position for velocity calculation if we don't have it
      if (!prevCameraPos) {
        prevCameraPos = { ...currentCameraPos };
      }
      
      // Calculate current velocity
      const currentVelocity = {
        lng: currentCameraPos.lng - prevCameraPos.lng,
        lat: currentCameraPos.lat - prevCameraPos.lat
      };
      
      // Store current position for next frame's velocity calculation
      prevCameraPos = { ...currentCameraPos };
      
      // Apply inertia with velocity - reduces oscillation around target
      // and creates more natural physical movement with easing
      const velocityDamping = 0.8 - (0.4 * zoomFactor); // 0.8 at low zoom (more damping), 0.4 at high zoom
      
      // Interpolate position with inertia and velocity damping
      currentCameraPos = {
        lng: currentCameraPos.lng + (cameraTargetPos.lng - currentCameraPos.lng) * positionLagFactor + 
             (currentVelocity.lng * velocityDamping),
        lat: currentCameraPos.lat + (cameraTargetPos.lat - currentCameraPos.lat) * positionLagFactor + 
             (currentVelocity.lat * velocityDamping)
      };
      
      // Handle bearing interpolation with special care for 0/360 boundary
      let targetBearingRad = cameraTargetBearing * Math.PI / 180;
      
      // Find shortest path around circle
      let bearingDiff = targetBearingRad - currentCameraBearingRad;
      if (bearingDiff > Math.PI) bearingDiff -= 2 * Math.PI;
      if (bearingDiff < -Math.PI) bearingDiff += 2 * Math.PI;
      
      // Store previous bearing for velocity damping
      if (prevCameraBearingRad === undefined) {
        prevCameraBearingRad = currentCameraBearingRad;
      }
      
      // Calculate bearing velocity with damping for smooth rotation
      const bearingVelocity = (currentCameraBearingRad - prevCameraBearingRad) * 
                             (0.7 - (0.4 * zoomFactor)); // More damping at low zoom
      
      // Store current bearing for next frame
      prevCameraBearingRad = currentCameraBearingRad;
      
      // Apply smooth interpolation to bearing with velocity damping
      currentCameraBearingRad += bearingDiff * bearingLagFactor + bearingVelocity;
      
      // Convert back to degrees for mapbox
      const newBearing = (currentCameraBearingRad * 180 / Math.PI) % 360;
      
      // Interpolate pitch with inertia smoothing (with similar damping)
      if (prevCameraPitch === undefined) {
        prevCameraPitch = currentCameraPitch;
      }
      
      const pitchVelocity = (currentCameraPitch - prevCameraPitch) * (0.7 - (0.3 * zoomFactor));
      prevCameraPitch = currentCameraPitch;
      currentCameraPitch += (cameraTargetPitch - currentCameraPitch) * pitchLagFactor + pitchVelocity;
      
      // Interpolate zoom with inertia smoothing (with similar damping)
      if (prevCameraZoom === undefined) {
        prevCameraZoom = currentCameraZoom;
      }
      
      const zoomVelocity = (currentCameraZoom - prevCameraZoom) * (0.6 - (0.3 * zoomFactor));
      prevCameraZoom = currentCameraZoom;
      currentCameraZoom += (cameraTargetZoom - currentCameraZoom) * zoomLagFactor + zoomVelocity;
      
      // Apply the new camera values - using jumpTo for performance
      // This avoids Mapbox's own easing/smoothing which can cause stuttering
      map.jumpTo({
        center: currentCameraPos,
        bearing: newBearing,
        pitch: currentCameraPitch,
        zoom: currentCameraZoom
      });
    }
    
    // Calculate ideal camera position based on rider and look-ahead
    // with improved path-based prediction and turn handling
    function calculateIdealCameraPosition(riderCoord, bearing, speed, height, pitch, sideOffset = 0, lookAheadAdjust = 0) {
      // Normalize camera height to 0-1 scale
      const normalizedHeight = (height - 1) / 99;
      
      // Get current zoom level for adaptive behavior
      const currentZoom = map.getZoom();
      
      // Create dynamic factors that change based on zoom level
      // When zoomed out, we want much more stable camera
      // When zoomed in, we want responsive but still smooth camera
      const zoomFactor = Math.min(1, Math.max(0.3, (currentZoom - 11) / 8)); // 0.3 at zoom 11, 1.0 at zoom 19
      
      // ======= PATH-AWARE LOOK-AHEAD SYSTEM =======
      // Find current position in the route for path-based prediction
      const currentDistanceKm = currentRouteDistance / 1000;
      const segment = calculateSegmentForDistance(currentDistanceKm, false);
      const currentRouteIndex = segment.beforeIdx;
      
      // Calculate height factor here to avoid reference before initialization
      // Base distance that scales with camera height (exponentially)
      // For low heights, we want minimal look-ahead
      // For high heights, we want significant look-ahead
      const heightFactor = Math.pow(normalizedHeight, 0.8); // Flatter curve at lower heights
      
      // Look ahead multiple points on the actual route to better predict path
      // The amount of look ahead depends on camera height (more height = further look ahead)
      // Use a maximum of 1/5 of the remaining route ahead
      const maxLookAheadPoints = Math.floor(Math.max(10, 20 * heightFactor)); 
      const routeRemaining = routeCoordinates.length - currentRouteIndex - 1;
      const pathLookAheadPoints = Math.min(maxLookAheadPoints, Math.floor(routeRemaining / 5));
      
      // Calculate path-based look-ahead point if we have enough points ahead
      let pathLookAheadCoord = { ...riderCoord }; // Default to rider position
      let pathHeading = bearing; // Default to current bearing
      
      if (pathLookAheadPoints > 3 && currentRouteIndex < routeCoordinates.length - pathLookAheadPoints) {
        // Determine an adaptive look-ahead index based on zoom level
        // When zoomed out, look further ahead on the path
        // When zoomed in, look closer ahead
        const baseLookAheadIndex = Math.floor(3 + (pathLookAheadPoints - 3) * normalizedHeight);
        const lookAheadIndex = Math.min(routeCoordinates.length - 1, currentRouteIndex + baseLookAheadIndex);
        
        // Save last look-ahead index for smooth transitions
        lastLookAheadIndex = lookAheadIndex;
        
        // Calculate the path-aware look-ahead coordinate from the route
        const lookAheadRoutePoint = routeCoordinates[lookAheadIndex];
        pathLookAheadCoord = {
          lng: lookAheadRoutePoint[0],
          lat: lookAheadRoutePoint[1]
        };
        
        // Calculate path direction using a wider window for more stable heading
        // Especially important when moving slowly or on twisty routes
        const headingEndIndex = Math.min(lookAheadIndex + 3, routeCoordinates.length - 1);
        const headingStartIndex = Math.max(currentRouteIndex, lookAheadIndex - 3);
        
        if (headingEndIndex > headingStartIndex) {
          // Calculate bearing between these points for smoother path-based heading
          const startPoint = routeCoordinates[headingStartIndex];
          const endPoint = routeCoordinates[headingEndIndex];
          pathHeading = calculateBearing(startPoint, endPoint);
        }
      }
      
      // ======= ADAPTIVE LOOK-AHEAD DISTANCE CALCULATIONS =======
      // heightFactor already calculated above
      
      // Calculate base look-ahead distance - larger when zoomed out
      // Minimum distance ensures camera is never too close
      // Maximum distance ensures natural perspective when zoomed out
      const minLookAhead = 5; // Minimum look-ahead in meters
      const maxLookAhead = 400; // Maximum look-ahead in meters
      const baseLookAhead = minLookAhead + ((maxLookAhead - minLookAhead) * heightFactor);
      
      // Adjust for speed - higher speeds need more look-ahead
      // But scale by height factor so it matters more when zoomed out
      const speedFactor = 1 + speed; // Range 1.1-2.0
      const speedImpact = 0.3 + (0.7 * heightFactor); // Less impact at close zoom
      
      // Apply look-ahead adjustment from visibility check (positive = more look ahead)
      const lookAheadAdjustment = baseLookAhead * lookAheadAdjust;
      
      // Calculate final look-ahead distance in meters
      const lookAheadMeters = (baseLookAhead + lookAheadAdjustment) * (1 + (speedImpact * speedFactor));
      
      // ======= TRADITIONAL DIRECTIONAL LOOK-AHEAD =======
      // Calculate basic directional look-ahead as fallback/blend
      const bearingRad = (bearing * Math.PI) / 180;
      const metersPerDegree = 111319.9; // Approximate meters per degree latitude
      
      // Calculate offsets for directional look-ahead
      const latOffset = Math.cos(bearingRad) * (lookAheadMeters / metersPerDegree);
      const lngOffset = Math.sin(bearingRad) * (lookAheadMeters / (metersPerDegree * Math.cos(riderCoord.lat * Math.PI / 180)));
      
      // Create direction-based look-ahead coordinate
      const directionLookAheadCoord = {
        lng: riderCoord.lng + lngOffset,
        lat: riderCoord.lat + latOffset
      };
      
      // ======= BLEND PATH-BASED AND DIRECTION-BASED LOOK-AHEAD =======
      // When zoomed out, prefer path-based look-ahead for stability
      // When zoomed in, use more direction-based look-ahead for responsiveness
      // This creates natural, stable camera behavior on any route
      const pathWeight = 0.4 + (0.5 * (1 - zoomFactor));
      const directionWeight = 1 - pathWeight;
      
      // Create blended look-ahead point
      const lookAheadCoord = {
        lng: (pathLookAheadCoord.lng * pathWeight) + (directionLookAheadCoord.lng * directionWeight),
        lat: (pathLookAheadCoord.lat * pathWeight) + (directionLookAheadCoord.lat * directionWeight)
      };
      
      // ======= ADJUST CAMERA POSITION TO KEEP BIKE CENTERED =======
      // Calculate offset to position camera behind the rider (creating a "third person" view)
      // Adjust based on camera height and pitch:
      // - Closer/lower camera needs to be more behind the rider
      // - Higher/distant camera can be more centered over the rider
      // This creates a more natural perspective at all zoom levels
      
      // Calculate behind-distance (more when close, less when far)
      const minBehindFactor = 0.0001; // Minimum behind distance in degrees
      const maxBehindFactor = 0.0005; // Maximum behind distance in degrees
      const behindDistanceDegrees = minBehindFactor + ((maxBehindFactor - minBehindFactor) * (1 - heightFactor));
      
      // Instead of fixed 180° behind position, calculate ideal "third-person" angle 
      // based on camera pitch - lower pitch = more behind, higher pitch = more above
      const normalizedPitch = pitch / 85; // 0-1 range
      const thirdPersonAngleOffset = 175 + (5 * normalizedPitch); // 175-180° range
      const behindBearingRad = ((bearing + thirdPersonAngleOffset) % 360) * Math.PI / 180;
      
      // Calculate behind position offset
      const behindLatOffset = Math.cos(behindBearingRad) * behindDistanceDegrees;
      const behindLngOffset = Math.sin(behindBearingRad) * (behindDistanceDegrees / Math.cos(riderCoord.lat * Math.PI / 180));
      
      // ======= BLEND RIDER POSITION AND LOOK-AHEAD =======
      // The blend depends on camera height, pitch, and zoom:
      // - Higher pitch (looking more down) needs more rider influence
      // - Lower pitch (looking more horizontal) needs more look-ahead
      // (normalizedPitch already calculated above)
      
      // Calculate pitch influence - lower pitch needs more look-ahead
      const pitchFactor = 1 - Math.pow(normalizedPitch, 0.7);
      
      // Fine-tune look-ahead weighting based on multiple factors
      // Lower numbers = more focused on rider (centered view)
      // Higher numbers = more focused on look-ahead (better for seeing where you're going)
      const lookAheadWeight = Math.min(0.7, 0.2 + (0.5 * heightFactor * pitchFactor));
      const riderWeight = 1 - lookAheadWeight;
      
      // Create the blended coordinate
      const blendedCoord = {
        lng: (riderCoord.lng * riderWeight) + (lookAheadCoord.lng * lookAheadWeight),
        lat: (riderCoord.lat * riderWeight) + (lookAheadCoord.lat * lookAheadWeight)
      };
      
      // ======= APPLY SIDE OFFSET FOR VISIBILITY =======
      // Calculate side offset (perpendicular to direction)
      // Used to adjust camera position to keep rider in view
      let sideLatOffset = 0;
      let sideLngOffset = 0;
      
      if (sideOffset !== 0) {
        // Perpendicular angle (90° to travel direction)
        const sideBearingRad = ((bearing + 90) % 360) * Math.PI / 180;
        
        // Scale side offset based on height and zoom
        // More responsive at higher zoom, more stable at lower zoom
        const sideOffsetDistance = sideOffset * 0.0005 * (0.5 + (0.5 * zoomFactor));
        
        // Calculate offset in lat/lng
        sideLatOffset = Math.cos(sideBearingRad) * sideOffsetDistance;
        sideLngOffset = Math.sin(sideBearingRad) * (sideOffsetDistance / Math.cos(riderCoord.lat * Math.PI / 180));
      }
      
      // ======= FINAL CAMERA POSITION =======
      // Apply all offsets to blended position
      const cameraPos = {
        lng: blendedCoord.lng + behindLngOffset + sideLngOffset,
        lat: blendedCoord.lat + behindLatOffset + sideLatOffset
      };
      
      return cameraPos;
    }
    
    // Update camera smoothly based on rider position
    function updateCamera(riderCoord, bearing, options = {}) {
      // Merge options with defaults
      const settings = {
        speed: animationSpeed,
        height: cameraHeight,
        pitch: cameraAngle,
        transitionDuration: 800, // ms
        ...options
      };
      
      // Calculate ideal camera position
      const targetCameraPos = calculateIdealCameraPosition(
        riderCoord, 
        bearing, 
        settings.speed, 
        settings.height, 
        settings.pitch
      );
      
      const targetZoom = calculateZoomFromHeight(settings.height);
      const targetPitch = settings.pitch;
      const targetBearingRad = bearing * Math.PI / 180;
      
      // Initialize camera position on first call
      if (currentCameraPos.lng === 0 && currentCameraPos.lat === 0) {
        currentCameraPos = map.getCenter();
        currentCameraZoom = map.getZoom();
        currentCameraPitch = map.getPitch();
        currentCameraBearingRad = map.getBearing() * Math.PI / 180;
        
        // First time, jump directly to position
        map.jumpTo({
          center: targetCameraPos,
          bearing: bearing,
          pitch: targetPitch,
          zoom: targetZoom
        });
        
        return;
      }
      
      // Don't use transitions at all - we'll handle the smooth movement ourselves
      // by directly updating the camera each frame during animation
      
      // Store the target values for the animation loop to use
      cameraTargetPos = targetCameraPos;
      cameraTargetBearing = bearing;
      cameraTargetPitch = targetPitch;
      cameraTargetZoom = targetZoom;
    }
    
    // Calculate the zoom level from camera height
    function calculateZoomFromHeight(height) {
      // Convert slider value (1-100) to actual parameters
      const sliderMin = 1;
      const sliderMax = 100;
      
      // Adjusted height range
      const actualMinHeight = 0.8;
      const actualMaxHeight = 250;
      
      // Normalize and calculate actual height (exponential scale)
      const normalizedSliderValue = (height - sliderMin) / (sliderMax - sliderMin);
      const actualHeight = actualMinHeight * Math.pow(actualMaxHeight / actualMinHeight, normalizedSliderValue);
      
      // Zoom range 
      const minZoom = 19.0; // Closer view
      const maxZoom = 11.5; // Farther view
      
      // Calculate zoom level (logarithmic scale)
      return maxZoom + ((Math.log(actualMaxHeight) - Math.log(actualHeight)) / 
                        (Math.log(actualMaxHeight) - Math.log(actualMinHeight))) * (minZoom - maxZoom);
    }
    
    // Function to parse URL parameters and hash fragments
    function parseUrlParams() {
      // Check for route parameter in the URL query string
      const urlParams = new URLSearchParams(window.location.search);
      const routeParam = urlParams.get('route');
      
      // Check for route in the hash fragment (e.g. #route=D1_East_Long.gpx)
      const hashParams = new URLSearchParams(window.location.hash.substring(1));
      const hashRoute = hashParams.get('route');
      
      // Use the parameter from query string or hash if available
      const requestedRoute = routeParam || hashRoute;
      
      if (requestedRoute) {
        // Find the matching option in the select element
        const options = Array.from(routeSelect.options);
        const matchingOption = options.find(option => option.value === requestedRoute);
        
        if (matchingOption) {
          // Set the select element to the requested route
          routeSelect.value = requestedRoute;
          return requestedRoute;
        }
      }
      
      // Return default route if no valid route parameter found
      return routeSelect.value;
    }

    // Event listeners
    document.addEventListener('DOMContentLoaded', () => {
      initMap();
      
      // Check URL parameters for requested route
      const initialRoute = parseUrlParams();
      
      // Load the initial route from URL parameter if available
      if (initialRoute) {
        loadRoute(initialRoute, true);
      }
      
      routeSelect.addEventListener('change', () => {
        loadRoute(routeSelect.value, true); // Apply camera height immediately on route change
        
        // Update URL hash to make the current route shareable
        window.location.hash = `route=${routeSelect.value}`;
      });
      
      toggleBtn.addEventListener('click', toggleAnimation);
      resetBtn.addEventListener('click', resetAnimation);
      
      // Map style is fixed to Satellite with Streets
      
      // Terrain exaggeration is now fixed at 1.0x - no handler needed
      
      // Camera height handler - updates view immediately
      heightControl.addEventListener('input', () => {
        try {
          cameraHeight = parseInt(heightControl.value);
          
          // If animation is not running, update the view immediately
          if (!animationId && routeCoordinates.length > 0) {
            updateInitialMapView();
            
            // After view update, check if rider is visible
            // Using a longer delay for smoother behavior
            setTimeout(() => {
              try {
                // Only check if the rider is completely out of view (less aggressive)
                const riderPosition = getRiderScreenPosition();
                if (riderPosition && isRiderCompletelyOutOfView(riderPosition)) {
                  // Use a very gentle, slow adjustment only when absolutely necessary
                  adjustCameraToKeepRiderVisible(riderPosition, false);
                }
              } catch (e) {
                console.warn('Error checking rider visibility after height change:', e);
              }
            }, 1200);
          }
          
          // Only recalculate if the height has changed significantly
          if (Math.abs(cameraHeight - lastPreCalcHeight) > 10) {
            // Wait a short delay if the user is actively adjusting the slider
            setTimeout(() => {
              try {
                // Only recalculate if the height hasn't changed again during the delay
                if (Math.abs(cameraHeight - lastPreCalcHeight) > 10) {
                  preCalculateRouteData();
                }
              } catch (e) {
                console.warn('Error in preCalculateRouteData:', e);
              }
            }, 500);
          }
        } catch (error) {
          console.error('Error in camera height handler:', error);
        }
      });
      
      // Camera angle handler - updates view immediately
      angleControl.addEventListener('input', () => {
        try {
          // Invert the values - slider shows low to high (10-85), but we need to reverse this
          // so that when slider is at "Low" position, we get a horizontal view (low angle value)
          // and when slider is at "High" position, we get an overhead view (high angle value)
          const sliderValue = parseInt(angleControl.value);
          
          // Calculate inverted angle - when slider is at min (10), we want max angle (85)
          // and vice versa
          cameraAngle = 95 - sliderValue; // 95 - 10 = 85, 95 - 85 = 10
          
          // If animation is not running, update the view immediately
          if (!animationId && routeCoordinates.length > 0) {
            updateInitialMapView();
            
            // After view update, check if rider is completely out of view
            // Using a longer delay for smoother behavior and being less aggressive
            setTimeout(() => {
              try {
                // Only check if the rider is completely out of view (less aggressive)
                const riderPosition = getRiderScreenPosition();
                if (riderPosition && isRiderCompletelyOutOfView(riderPosition)) {
                  // Use a very gentle, slow adjustment only when absolutely necessary
                  adjustCameraToKeepRiderVisible(riderPosition, false);
                }
              } catch (e) {
                console.warn('Error checking rider visibility after angle change:', e);
              }
            }, 1200);
          }
        } catch (error) {
          console.error('Error in camera angle handler:', error);
        }
      });
      
      speedControl.addEventListener('input', () => {
        animationSpeed = parseFloat(speedControl.value);
      });
      
      // Position slider handler
      positionSlider.addEventListener('input', () => {
        // Only allow manual positioning when animation is not running
        if (!animationId) {
          try {
            const positionPercent = parseFloat(positionSlider.value) / 100;
            updatePositionManually(positionPercent);
            
            // Wait for position update to complete, then check visibility
            // Using a longer delay for a smoother experience
            setTimeout(() => {
              try {
                const riderPosition = getRiderScreenPosition();
                if (riderPosition && !isRiderVisible(riderPosition)) {
                  // If rider isn't visible, make a smooth adjustment
                  adjustCameraToKeepRiderVisible(riderPosition);
                }
              } catch (e) {
                console.warn('Error in rider visibility check after position update:', e);
              }
            }, 1000);
          } catch (error) {
            console.error('Error updating position manually:', error);
          }
        }
      });
    });
    
    // Function to manually update position based on slider
    function updatePositionManually(positionPercent) {
      // Safety check
      if (!routeCoordinates || routeCoordinates.length === 0 || !routeDistances || routeDistances.length === 0) {
        return;
      }
      
      // Calculate the distance along the route
      const totalDistanceMeters = routeDistances[routeDistances.length - 1] * 1000; // km to m
      currentRouteDistance = positionPercent * totalDistanceMeters;
      
      // Convert current distance to km for comparison with routeDistances
      const currentDistanceKm = currentRouteDistance / 1000;
      
      // Get segment using the route
      const segment = calculateSegmentForDistance(currentDistanceKm, false);
      const beforeIdx = segment.beforeIdx;
      const afterIdx = segment.afterIdx;
      const fraction = segment.fraction;
      
      // Get the two points
      const beforePoint = routeCoordinates[beforeIdx];
      const afterPoint = routeCoordinates[afterIdx];
      
      // Create interpolated point
      const interpolatedPoint = [
        beforePoint[0] + (afterPoint[0] - beforePoint[0]) * fraction,
        beforePoint[1] + (afterPoint[1] - beforePoint[1]) * fraction
      ];
      
      // Include elevation if available
      if (beforePoint.length > 2 && afterPoint.length > 2) {
        interpolatedPoint[2] = beforePoint[2] + (afterPoint[2] - beforePoint[2]) * fraction;
      }
      
      // Update rider position
      updatePointPosition(interpolatedPoint);
      
      // Update current tracking point indices
      currentPoint = beforeIdx;
      currentPointFloat = beforeIdx + fraction;
      
      // Calculate bearing
      const bearing = calculateBearing(
        beforePoint,
        afterPoint
      );
      
      // Create a rider coordinate object
      const riderCoord = {
        lng: interpolatedPoint[0],
        lat: interpolatedPoint[1]
      };
      
      // Use our new camera system for consistency with animation
      updateCamera(riderCoord, bearing, {
        // Use a longer transition duration for slider updates
        transitionDuration: 1500
      });
      
      // Update UI
      updateProgress();
    }
  </script>
</body>
</html>