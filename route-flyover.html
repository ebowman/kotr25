<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>King of the Road 2025 - Route Flyover</title>
  <link rel="stylesheet" href="https://unpkg.com/mapbox-gl@2.15.0/dist/mapbox-gl.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />
  <script src="https://unpkg.com/mapbox-gl@2.15.0/dist/mapbox-gl.js"></script>
  <script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>
  <script src="https://unpkg.com/axios/dist/axios.min.js"></script>
  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      background: #f9f9f9;
      color: #333;
    }
    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
      display: flex;
      flex-wrap: wrap;
      gap: 20px;
    }
    h1 {
      width: 100%;
      text-align: center;
      margin-bottom: 10px;
      color: #222;
    }
    #map {
      flex: 1;
      min-width: 700px;
      height: 600px;
      border-radius: 8px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.05);
    }
    .controls {
      width: 280px;
      padding: 15px;
      background: white;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.05);
      display: flex;
      flex-direction: column;
      gap: 20px;
    }
    select, button {
      padding: 10px 15px;
      border-radius: 5px;
      border: 1px solid #ddd;
      background: white;
      font-size: 14px;
      width: 100%;
    }
    button {
      background: linear-gradient(to bottom, #3498db, #2980b9);
      color: white;
      cursor: pointer;
      border: none;
      transition: all 0.2s;
      font-weight: 600;
    }
    button:hover {
      background: linear-gradient(to bottom, #2980b9, #2471a3);
      transform: translateY(-1px);
    }
    button:disabled {
      background: #ccc;
      cursor: not-allowed;
    }
    label {
      font-weight: 600;
      margin-bottom: 5px;
      display: block;
      color: #444;
    }
    .control-group {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .control-group label input[type="checkbox"] {
      margin-right: 8px;
      transform: scale(1.2);
    }
    .control-group label {
      display: flex;
      align-items: center;
      cursor: pointer;
      font-size: 14px;
      font-weight: 500;
    }
    .route-info {
      background: white;
      border-radius: 8px;
      padding: 15px;
      margin-top: 20px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    }
    .info-grid {
      display: flex;
      justify-content: space-between;
      flex-wrap: nowrap;
      gap: 15px;
      margin-top: 10px;
    }
    .info-item {
      flex: 1;
      text-align: center;
      padding: 12px;
      background: #f5f9ff;
      border-radius: 5px;
    }
    .info-label {
      font-size: 12px;
      color: #666;
      margin-bottom: 5px;
    }
    .info-value {
      font-size: 20px;
      font-weight: 600;
      color: #2c3e50;
    }
    .elevation-profile {
      width: 100%;
      height: 120px;
      background: white;
      margin-top: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.05);
      position: relative;
    }
    #elevation-canvas {
      width: 100%;
      height: 100%;
      border-radius: 8px;
    }
    .elevation-marker {
      position: absolute;
      top: 0;
      width: 2px;
      height: 120px;
      background: red;
      z-index: 10;
      pointer-events: none;
    }
    .loading {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(255,255,255,0.8);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }
    .loading-spinner {
      border: 5px solid #f3f3f3;
      border-top: 5px solid #3498db;
      border-radius: 50%;
      width: 50px;
      height: 50px;
      animation: spin 1s linear infinite;
      margin-bottom: 15px;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    .slider-container {
      margin-top: 5px;
    }
    .range-labels {
      display: flex;
      justify-content: space-between;
      font-size: 12px;
      color: #666;
      margin-top: 5px;
    }
    input[type="range"] {
      width: 100%;
      margin: 0;
      -webkit-appearance: none;
      appearance: none;
      height: 6px;
      background: #e0e0e0;
      border-radius: 3px;
      outline: none;
    }
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: #3498db;
      cursor: pointer;
      border: 2px solid white;
      box-shadow: 0 1px 3px rgba(0,0,0,0.2);
    }
    input[type="range"]::-moz-range-thumb {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: #3498db;
      cursor: pointer;
      border: 2px solid white;
      box-shadow: 0 1px 3px rgba(0,0,0,0.2);
    }
  </style>
</head>
<body>
  <div class="container">
    <div style="display: flex; justify-content: space-between; align-items: center; width: 100%; margin-bottom: 10px;">
      <a href="index.html" style="text-decoration: none; color: #3498db; display: flex; align-items: center;">
        <i class="fas fa-arrow-left" style="margin-right: 5px;"></i> Back to routes
      </a>
    </div>
    <h1>King of the Road 2025 - 3D Route Flyover</h1>
    
    <div class="controls">
      <div class="control-group">
        <label for="route-select">Select Route:</label>
        <select id="route-select">
          <option value="D0_Warm-up.gpx">Day 0 - Warm-up</option>
          <option value="D1_East Short.gpx">Day 1 - East (Short)</option>
          <option value="D1_East_Long.gpx">Day 1 - East (Long)</option>
          <option value="D2_North_Short.gpx">Day 2 - North (Short)</option>
          <option value="D2_North_Long.gpx">Day 2 - North (Long)</option>
          <option value="D3_West_Short.gpx">Day 3 - West (Short)</option>
          <option value="D3_West_Long.gpx">Day 3 - West (Long)</option>
        </select>
      </div>
      
      <div class="control-group">
        <label for="camera-height">Zoom:</label>
        <div class="slider-container">
          <input type="range" id="camera-height" min="1" max="100" step="1" value="70">
          <div class="range-labels">
            <span>In</span>
            <span>Out</span>
          </div>
        </div>
      </div>
      
      <div class="control-group">
        <label for="camera-angle">View Angle:</label>
        <div class="slider-container">
          <input type="range" id="camera-angle" min="10" max="85" step="1" value="35">
          <div class="range-labels">
            <span>Low</span>
            <span>High</span>
          </div>
        </div>
      </div>
      
      <div class="control-group">
        <label for="speed-control">Animation Speed:</label>
        <div class="slider-container">
          <input type="range" id="speed-control" min="0.1" max="5" step="0.1" value="3.5">
          <div class="range-labels">
            <span>Slow</span>
            <span>Fast</span>
          </div>
        </div>
      </div>
      
      <div class="control-group">
        <label for="position-slider">Position:</label>
        <div class="slider-container" style="position: relative;">
          <input type="range" id="position-slider" min="0" max="100" step="0.1" value="0">
          <div id="position-overlay" style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; z-index: 10; cursor: pointer; background: transparent;" title="Click to jump to position"></div>
          <div class="range-labels">
            <span>Start</span>
            <span>End</span>
          </div>
        </div>
      </div>
      
      <div class="control-group">
        <label>
          <input type="checkbox" id="follow-path-toggle" checked>
          Follow Path (Camera tracks rider)
        </label>
      </div>
      
      <div class="control-group" style="margin-top: 10px;">
        <button id="toggle-btn">Start</button>
        <button id="reset-btn" disabled>Reset</button>
        <button id="recenter-btn">Recenter Camera</button>
      </div>
    </div>
    
    <div id="map"></div>
    
    <div class="elevation-profile">
      <canvas id="elevation-canvas"></canvas>
      <div class="elevation-marker" id="elevation-marker" style="display: none;"></div>
    </div>
    
    <div class="route-info">
      <div class="info-header">
        <h3>Route Information</h3>
      </div>
      <div class="info-grid">
        <div class="info-item">
          <div class="info-label">Total Distance</div>
          <div class="info-value" id="total-distance">--</div>
        </div>
        <div class="info-item">
          <div class="info-label">Distance Traveled</div>
          <div class="info-value" id="distance-traveled">0.0 km</div>
        </div>
        <div class="info-item">
          <div class="info-label">Elevation Gain</div>
          <div class="info-value" id="elevation-gain">--</div>
        </div>
        <div class="info-item">
          <div class="info-label">Current Elevation</div>
          <div class="info-value" id="current-elevation">--</div>
        </div>
        <div class="info-item">
          <div class="info-label">Current Gradient</div>
          <div class="info-value" id="current-gradient">--</div>
        </div>
        <div class="info-item">
          <div class="info-label">Progress</div>
          <div class="info-value" id="progress">0%</div>
        </div>
      </div>
    </div>
  </div>
  
  <div class="loading" id="loading">
    <div class="loading-spinner"></div>
    <p>Loading route data...</p>
  </div>
  
  <script>
    // Replace with your Mapbox access token
    mapboxgl.accessToken = 'pk.eyJ1IjoiZWJvd21hbiIsImEiOiJjbWE1ZWVwdzYwODhwMmlzZnU4NTlyem1rIn0.E10X5hj2NTgViJexKpvrOg';
    
    // Global variables
    let map;
    let routeData = null;
    let animationId = null;
    let currentPoint = 0;
    let elevationProfile = [];
    let maxElevation = 0;
    let minElevation = Infinity;
    let totalDistance = 0;
    let elevationGain = 0;
    let routeCoordinates = [];
    let routeDistances = []; // Array to store cumulative distances along route
    let animationSpeed = 0.5;
    let cameraHeight = 25; // Default camera height (slider position, not actual meters)
    let cameraAngle = 60; // Default camera angle (pitch) in degrees (calculated from slider value of 35: 95-35=60)
    let followPath = true; // Whether to use helicopter camera or standard Mapbox controls
    let userAdjustingPosition = false; // Flag to prevent automatic slider updates during manual adjustment
    let currentRouteDistance = 0; // Current distance along route in meters
    let totalDistanceMeters = 0; // Total distance of the route in meters
    let dt = 1/60; // Physics timestep in seconds (60fps)
    
    // Camera state variables - simplified
    let cameraPos = { x: 0, y: 0, z: 0 }; // Current position
    let cameraFOV = 60; // Current field of view
    let lastFrameTime = performance.now(); // For deltaTime calculation
    let currentBearing = 0; // Current smoothed bearing for gradual direction changes
    let cameraVelocity = { bearing: 0, speed: 0 }; // Camera movement velocity for momentum
    let currentWaypoint = null; // Current target waypoint camera is flying toward
    let waypointUpdateTimer = 0; // Timer to update waypoint occasionally
    let isAnimationRunning = false; // Track animation state more reliably
    let animationToken = null; // Unique token to identify the current animation instance
    
    // Simplified camera parameters for smooth motion
    let lookAheadFactor = 0.05;  // Much less aggressive look-ahead
    let minLook = 2;  // Minimum look-ahead distance
    let maxLook = 20;  // Reduced maximum look-ahead for stability
    let verticalOffset = 5;  // Minimal vertical offset
    let baseZoom = 50;  // Default FOV
    let zoomMax = 75;  // Maximum FOV
    
    // Smoothing parameters
    let positionSmoothing = 0.08;  // Base position smoothing factor
    
    // Obscuration detection state
    let obscurationCounter = 0; // Count consecutive obscured frames
    let lastObscuredState = false; // Track previous obscuration state
    
    // Debug: Track camera updates per frame
    let frameCount = 0;
    let cameraUpdatesThisFrame = 0;
    
    // ANTI-JITTER: Only allow one camera update per timeout cycle
    let pendingCameraUpdate = null;
    let lastCameraUpdateTime = 0;
    let zoomSmoothing = 0.12;      // Zoom smoothing factor
    let bearingSmoothing = 0.15;   // Bearing smoothing factor for camera direction
    
    // Simplified zoom control
    let zoomGoal = baseZoom;
    
    // Helper function to smooth bearing changes with proper angle wraparound
    function smoothBearing(currentBearing, targetBearing, smoothingFactor, deltaTime) {
      // Normalize angles to 0-360 range
      const normalizeBearing = (angle) => ((angle % 360) + 360) % 360;
      
      const current = normalizeBearing(currentBearing);
      const target = normalizeBearing(targetBearing);
      
      // Calculate the shortest angular distance
      let diff = target - current;
      if (diff > 180) diff -= 360;
      if (diff < -180) diff += 360;
      
      // Apply frame-rate independent smoothing
      const frameRateAdjustment = Math.min(1, deltaTime * 60);
      const actualSmoothingFactor = 1 - Math.pow(1 - smoothingFactor, frameRateAdjustment);
      
      // Calculate new bearing
      const newBearing = current + (diff * actualSmoothingFactor);
      
      return normalizeBearing(newBearing);
    }
    
    
    // Helper function to efficiently calculate segment data for any distance
    // Uses binary search for much faster lookups, important for smooth animation
    function calculateSegmentForDistance(distanceKm) {
      
      // Use regular route distances
      const distances = routeDistances;
      
      // Safety check to ensure we have valid distances
      if (!distances || distances.length < 2) {
        console.warn('Invalid distances array for route lookup');
        return { beforeIdx: 0, afterIdx: 1, fraction: 0 };
      }
      
      let beforeIdx = 0;
      let afterIdx = 1;
      let fraction = 0;
      
      // Handle edge cases for start and end of route
      if (distanceKm <= distances[0]) {
        return { 
          beforeIdx: 0, 
          afterIdx: 1, 
          fraction: 0,
          useSmoothedRoute: shouldUseSmoothedRoute 
        };
      }
      
      if (distanceKm >= distances[distances.length - 1]) {
        return { 
          beforeIdx: distances.length - 2,
          afterIdx: distances.length - 1,
          fraction: 1,
          useSmoothedRoute: shouldUseSmoothedRoute
        };
      }
      
      // Binary search to find the closest segment for the given distance
      // This is much more efficient than linear search for long routes
      let start = 0, end = distances.length - 1;
      
      while (start <= end) {
        const mid = Math.floor((start + end) / 2);
        
        if (mid + 1 < distances.length && // Safety check for array bounds
            distances[mid] <= distanceKm && distances[mid + 1] >= distanceKm) {
          beforeIdx = mid;
          afterIdx = mid + 1;
          break;
        } else if (distances[mid] < distanceKm) {
          start = mid + 1;
        } else {
          end = mid - 1;
        }
      }
      
      // Final safety check for valid indices
      if (afterIdx >= distances.length) {
        afterIdx = distances.length - 1;
        beforeIdx = Math.max(0, afterIdx - 1);
      }
      
      // Calculate the interpolation fraction
      const segmentLength = distances[afterIdx] - distances[beforeIdx];
      fraction = segmentLength > 0 ? 
        (distanceKm - distances[beforeIdx]) / segmentLength : 0;
      
      // Ensure fraction is always valid (0-1)
      fraction = Math.max(0, Math.min(1, fraction));
      
      // Debug interpolation occasionally - DISABLED
      // if (Math.random() < 0.005) { // Log very occasionally
      //   console.log(`Segment ${beforeIdx}-${afterIdx}: length=${(segmentLength*1000).toFixed(1)}m, fraction=${fraction.toFixed(3)}`);
      // }
      
      return { 
        beforeIdx, 
        afterIdx, 
        fraction
      };
    }

    // Calculate bearing between two coordinates
    function calculateBearing(start, end) {
      // Safety check for invalid coordinates
      if (!start || !end || !Array.isArray(start) || !Array.isArray(end) || 
          start.length < 2 || end.length < 2) {
        console.warn('Invalid coordinates for bearing calculation:', start, end);
        return 0; // Default bearing
      }
      
      try {
        const startLat = start[1] * Math.PI / 180;
        const startLng = start[0] * Math.PI / 180;
        const endLat = end[1] * Math.PI / 180;
        const endLng = end[0] * Math.PI / 180;
        
        const y = Math.sin(endLng - startLng) * Math.cos(endLat);
        const x = Math.cos(startLat) * Math.sin(endLat) - 
                  Math.sin(startLat) * Math.cos(endLat) * Math.cos(endLng - startLng);
        
        const bearing = Math.atan2(y, x) * 180 / Math.PI;
        return (bearing + 360) % 360;
      } catch (e) {
        console.warn('Error calculating bearing:', e);
        return 0; // Default bearing on error
      }
    }
    
    // Update point position
    function updatePointPosition(coord) {
      // Safety check to prevent errors
      if (!coord || !Array.isArray(coord) || coord.length < 2) {
        console.warn('Invalid coordinate passed to updatePointPosition:', coord);
        return;
      }
      
      // Create a GeoJSON point
      const point = {
        type: 'Feature',
        properties: {},
        geometry: {
          type: 'Point',
          coordinates: [coord[0], coord[1]]
        }
      };
      
      // Update the point source if it exists
      if (map && map.getSource('point')) {
        try {
          map.getSource('point').setData(point);
        } catch (e) {
          console.warn('Error updating point position:', e);
        }
      }
    }
    
    // SIMPLE HEIGHT: Just use zoom-based height without terrain detection
    function shouldUseHighCamera(zoomFactor) {
      // Use higher camera when significantly zoomed out
      return zoomFactor > 0.7;
    }
    
    // ANTI-JITTER: Guarantee only one camera update per timeout cycle
    function safeCameraUpdate(cameraState, source) {
      const currentTime = performance.now();
      
      // For MAIN_ANIMATION with requestAnimationFrame, allow all updates
      // Only throttle non-animation sources to prevent interference
      if (source !== "MAIN_ANIMATION" && currentTime - lastCameraUpdateTime < 15) {
        // Already updated camera recently - store as pending
        console.log(`Blocking camera update from ${source} - too soon after last update`);
        pendingCameraUpdate = { ...cameraState, source };
        return;
      }
      
      // Safe to update
      lastCameraUpdateTime = currentTime;
      // Disable frame-by-frame logging during animation for performance
      // console.log(`Camera update from ${source} at time ${currentTime.toFixed(1)}`);
      
      // During main animation, use jumpTo for instant, direct updates without any interpolation
      if (source === "MAIN_ANIMATION") {
        map.jumpTo({
          center: cameraState.center,
          zoom: cameraState.zoom,
          bearing: cameraState.bearing,
          pitch: cameraState.pitch
        });
      } else {
        // Normal easeTo for non-animation interactions
        map.easeTo({
          ...cameraState,
          duration: cameraState.duration || 0,
          easing: cameraState.easing || (t => t)
        });
      }
    }
    
    // SIMPLE CAMERA HEIGHT DECISION: Use zoom level only
    function shouldUseHighCamera(zoomFactor) {
      return zoomFactor > 0.7;
    }
    
    // CONSTRAINT STATE: Track to prevent rapid on/off switching
    let riderVisibilityActive = false;
    
    // CAMERA PATH DERIVATIVES: Track velocity and acceleration for jitter detection
    let cameraHistory = []; // Store recent camera positions
    const maxHistoryLength = 10; // Keep last 10 positions for derivative calculation
    
    // ROUTE HAZARD DETECTION: Pre-analyze route for problematic sections
    let routeHazardMap = []; // Array marking problematic sections of the route
    
    function analyzeRouteForHazards() {
      console.log("Analyzing route for camera hazards...");
      routeHazardMap = [];
      
      if (routeCoordinates.length < 10) return;
      
      for (let i = 0; i < routeCoordinates.length; i++) {
        let hazardScore = 0;
        let hazardReasons = [];
        
        // Check for steep elevation changes
        if (i > 0 && i < routeCoordinates.length - 1) {
          const prevElevation = routeCoordinates[i-1][2] || 0;
          const currentElevation = routeCoordinates[i][2] || 0;
          const nextElevation = routeCoordinates[i+1][2] || 0;
          
          const elevationChange1 = Math.abs(currentElevation - prevElevation);
          const elevationChange2 = Math.abs(nextElevation - currentElevation);
          
          if (elevationChange1 > 20 || elevationChange2 > 20) {
            hazardScore += 2;
            hazardReasons.push("steep-elevation");
          }
        }
        
        // Check for sharp direction changes (tight turns)
        if (i > 1 && i < routeCoordinates.length - 2) {
          const p1 = routeCoordinates[i-2];
          const p2 = routeCoordinates[i-1];
          const p3 = routeCoordinates[i];
          const p4 = routeCoordinates[i+1];
          
          // Calculate bearing changes
          const bearing1 = Math.atan2(p2[1] - p1[1], p2[0] - p1[0]);
          const bearing2 = Math.atan2(p3[1] - p2[1], p3[0] - p2[0]);
          const bearing3 = Math.atan2(p4[1] - p3[1], p4[0] - p3[0]);
          
          let bearingChange1 = Math.abs(bearing2 - bearing1);
          let bearingChange2 = Math.abs(bearing3 - bearing2);
          
          // Handle angle wraparound
          if (bearingChange1 > Math.PI) bearingChange1 = 2 * Math.PI - bearingChange1;
          if (bearingChange2 > Math.PI) bearingChange2 = 2 * Math.PI - bearingChange2;
          
          if (bearingChange1 > 0.3 || bearingChange2 > 0.3) { // ~17 degrees
            hazardScore += 1;
            hazardReasons.push("sharp-turn");
          }
        }
        
        // Check for rapid elevation + direction changes (worst case)
        if (hazardReasons.includes("steep-elevation") && hazardReasons.includes("sharp-turn")) {
          hazardScore += 3; // Extra penalty for combination
          hazardReasons.push("compound-hazard");
        }
        
        routeHazardMap[i] = {
          score: hazardScore,
          reasons: hazardReasons,
          isHazardous: hazardScore >= 3
        };
      }
      
      const hazardCount = routeHazardMap.filter(h => h.isHazardous).length;
      console.log(`Found ${hazardCount} hazardous sections out of ${routeCoordinates.length} points`);
    }
    
    function applyDerivativeBasedSmoothing(proposedPosition, deltaTime) {
      // Add current camera position to history
      const currentTime = performance.now();
      cameraHistory.push({
        position: { x: cameraPos.x, y: cameraPos.y, z: cameraPos.z },
        time: currentTime
      });
      
      // Trim history to max length
      if (cameraHistory.length > maxHistoryLength) {
        cameraHistory.shift();
      }
      
      // Need at least 3 points to calculate acceleration
      if (cameraHistory.length < 3) {
        return proposedPosition; // Not enough history, use proposed position
      }
      
      // Calculate velocity (first derivative) for recent positions
      const velocities = [];
      for (let i = 1; i < cameraHistory.length; i++) {
        const dt = (cameraHistory[i].time - cameraHistory[i-1].time) / 1000; // Convert to seconds
        if (dt > 0) {
          const dx = cameraHistory[i].position.x - cameraHistory[i-1].position.x;
          const dy = cameraHistory[i].position.y - cameraHistory[i-1].position.y;
          velocities.push({
            vx: dx / dt,
            vy: dy / dt,
            time: cameraHistory[i].time
          });
        }
      }
      
      // Calculate acceleration (second derivative) for recent velocities
      const accelerations = [];
      for (let i = 1; i < velocities.length; i++) {
        const dt = (velocities[i].time - velocities[i-1].time) / 1000;
        if (dt > 0) {
          const ax = (velocities[i].vx - velocities[i-1].vx) / dt;
          const ay = (velocities[i].vy - velocities[i-1].vy) / dt;
          accelerations.push({
            ax: ax,
            ay: ay,
            magnitude: Math.sqrt(ax*ax + ay*ay)
          });
        }
      }
      
      // Skip derivative analysis during main animation to prevent interference
      if (isAnimationRunning) {
        return proposedPosition; // Use proposed position directly during animation
      }
      
      // Analyze derivatives for jitter patterns (only when not animating)
      if (accelerations.length >= 2) {
        // Calculate average acceleration magnitude (indicator of jittering)
        const avgAcceleration = accelerations.reduce((sum, a) => sum + a.magnitude, 0) / accelerations.length;
        
        // Calculate velocity direction changes (oscillation detection)
        let directionChanges = 0;
        for (let i = 1; i < velocities.length; i++) {
          const dot = velocities[i].vx * velocities[i-1].vx + velocities[i].vy * velocities[i-1].vy;
          if (dot < 0) directionChanges++; // Direction reversal
        }
        
        // Determine jitter severity and apply appropriate smoothing
        const highAccelerationThreshold = 0.01; // High acceleration indicates jitter
        const oscillationThreshold = 2; // Multiple direction changes indicate oscillation
        
        let smoothingStrength = 0.1; // Base smoothing
        let jitterReason = "";
        
        if (avgAcceleration > highAccelerationThreshold) {
          smoothingStrength = 0.7; // Strong smoothing for high acceleration
          jitterReason = `high acceleration (${(avgAcceleration * 111000).toFixed(1)}m/s²)`;
        } else if (directionChanges >= oscillationThreshold) {
          smoothingStrength = 0.6; // Strong smoothing for oscillation
          jitterReason = `oscillation (${directionChanges} direction changes)`;
        } else if (avgAcceleration > highAccelerationThreshold * 0.5) {
          smoothingStrength = 0.3; // Moderate smoothing for moderate acceleration
          jitterReason = `moderate acceleration (${(avgAcceleration * 111000).toFixed(1)}m/s²)`;
        }
        
        // Disable console logging during animation for performance
        // if (jitterReason && Math.random() < 0.1) {
        //   console.log(`Derivative jitter detection: ${jitterReason} - applying ${(smoothingStrength*100).toFixed(0)}% smoothing`);
        // }
        
        // Apply derivative-constrained smoothing
        return {
          x: cameraPos.x + (proposedPosition.x - cameraPos.x) * (1 - smoothingStrength),
          y: cameraPos.y + (proposedPosition.y - cameraPos.y) * (1 - smoothingStrength),
          z: proposedPosition.z
        };
      }
      
      // Fallback to minimal smoothing
      return {
        x: cameraPos.x + (proposedPosition.x - cameraPos.x) * 0.9,
        y: cameraPos.y + (proposedPosition.y - cameraPos.y) * 0.9,
        z: proposedPosition.z
      };
    }
    
    // SIMPLE HEIGHT CALCULATION: Use zoom level only, no complex terrain sampling
    function calculateSimpleHeight(zoomFactor, useHighCamera = false) {
      // Simple, predictable height based purely on zoom level
      // No terrain sampling to avoid oscillation
      const minHeight = 100;  // 100m when zoomed in
      const maxHeight = 800;  // 800m when zoomed out
      
      const baseHeight = minHeight + (zoomFactor * (maxHeight - minHeight));
      
      // If high camera mode, boost camera height significantly
      const heightBoost = useHighCamera ? 400 : 0; // Extra 400m when needed
      
      return baseHeight + heightBoost;
    }
    
    
    // TARGET-POINT MODULE: Calculate where camera position should be
    function calculateTargetPoint(bikerPos, bikerVel, deltaTime = 0.016) {
      // Safety checks for NaN values
      if (isNaN(bikerPos.x) || isNaN(bikerPos.y) || isNaN(bikerPos.z)) {
        console.warn('NaN values detected in biker position');
        return {
          x: bikerPos.x || 0,
          y: bikerPos.y || 0,
          z: (bikerPos.z || 0) + 100 // Safe default height
        };
      }
      
      // Get current zoom level
      const heightControl = document.getElementById('camera-height');
      const zoomOutAmount = heightControl ? parseInt(heightControl.value) : 50;
      const currentZoomFactor = Math.max(0, Math.min(1, zoomOutAmount / 100));
      
      // Calculate how far ahead on the route to position the camera
      // Use much shorter look-ahead to prevent geometric conflicts on tight turns
      const currentDistanceKm = currentRouteDistance / 1000;
      const altitudeFactor = Math.max(0.1, Math.min(1.0, (cameraFOV - baseZoom) / (zoomMax - baseZoom)));
      const lookAheadDistance = currentDistanceKm + (0.01 + altitudeFactor * 0.05); // Reduced to 0.01-0.06km for stability
      
      const clampedLookAheadDistance = Math.min(lookAheadDistance, routeDistances[routeDistances.length - 1]);
      
      // Find the point on the route at this distance
      const lookAheadSegment = calculateSegmentForDistance(clampedLookAheadDistance, false); // Use actual route
      const lookAheadCoords = routeCoordinates;
      
      if (lookAheadSegment && lookAheadCoords[lookAheadSegment.afterIdx]) {
        const beforePoint = lookAheadCoords[lookAheadSegment.beforeIdx];
        const afterPoint = lookAheadCoords[lookAheadSegment.afterIdx];
        const fraction = lookAheadSegment.fraction;
        
        // UNIFIED CONSTRAINT RESOLUTION: Calculate all possible positions first, then choose
        
        // 1. BASE POSITION: Interpolate the look-ahead point on the route
        const baseX = beforePoint[0] + (afterPoint[0] - beforePoint[0]) * fraction;
        const baseY = beforePoint[1] + (afterPoint[1] - beforePoint[1]) * fraction;
        const routeElevation = (beforePoint[2] || 0) + ((afterPoint[2] || 0) - (beforePoint[2] || 0)) * fraction;
        
        // 2. HEIGHT CALCULATION: Simple and stable - no terrain queries
        const useHighCamera = shouldUseHighCamera(currentZoomFactor);
        const cameraHeight = calculateSimpleHeight(currentZoomFactor, useHighCamera);
        const targetZ = routeElevation + cameraHeight;
        
        // 3. CONSTRAINT VOTING SYSTEM: Multiple constraints cast votes, manager mediates
        const constraints = [];
        
        // SIMPLIFIED STABLE CONSTRAINTS: Fixed strengths to prevent oscillation
        
        // CONSTRAINT 1: Route Following
        constraints.push({
          name: "route-following",
          position: { x: baseX, y: baseY, z: targetZ },
          strength: 0.5, // Fixed moderate strength
          reason: "Follow route path"
        });
        
        // CONSTRAINT 2: Rider Visibility (terrain-aware to prevent impossible constraints)
        const cameraToBikerX = bikerPos.x - baseX;
        const cameraToBikerY = bikerPos.y - baseY;
        const distanceToBiker = Math.sqrt(cameraToBikerX * cameraToBikerX + cameraToBikerY * cameraToBikerY);
        
        // Check if steep terrain likely obscures the rider
        const elevationDifference = Math.abs(targetZ - bikerPos.z);
        const isLikelyObscured = elevationDifference > 100; // 100m+ elevation difference suggests terrain obscuration
        
        if (!useHighCamera && !isLikelyObscured) {
          // Hysteresis: different thresholds for turning on vs off
          const turnOnThreshold = 0.001;    // Activate when rider gets this far (~100m)
          const turnOffThreshold = 0.0005;  // Deactivate when rider gets this close (~50m)
          
          if (!riderVisibilityActive && distanceToBiker > turnOnThreshold) {
            riderVisibilityActive = true;
          } else if (riderVisibilityActive && distanceToBiker < turnOffThreshold) {
            riderVisibilityActive = false;
          }
          
          if (riderVisibilityActive) {
            const riderCenteredX = bikerPos.x - (cameraToBikerX * 0.2); // Gentler centering
            const riderCenteredY = bikerPos.y - (cameraToBikerY * 0.2);
            
            constraints.push({
              name: "rider-visibility",
              position: { x: riderCenteredX, y: riderCenteredY, z: targetZ },
              strength: 0.3, // Fixed moderate strength
              reason: `Keep rider visible`
            });
          }
        } else {
          // Reset when in high camera mode OR when likely obscured by terrain
          riderVisibilityActive = false;
          // Disable console logging during animation for performance
          // if (isLikelyObscured && Math.random() < 0.1) {
          //   console.log(`Disabling rider-visibility due to terrain obscuration (elevation diff: ${elevationDifference.toFixed(1)}m)`);
          // }
        }
        
        // CONSTRAINT 3: Stability - stronger to prevent jitter
        constraints.push({
          name: "stability",
          position: { x: cameraPos.x, y: cameraPos.y, z: targetZ },
          strength: 0.4, // Stronger stability influence
          reason: "Minimize camera movement"
        });
        
        // CONSTRAINT MANAGER: Resolve conflicts with weighted averaging
        let totalWeight = 0;
        let weightedX = 0;
        let weightedY = 0;
        let maxZ = targetZ;
        
        constraints.forEach(constraint => {
          const weight = constraint.strength;
          weightedX += constraint.position.x * weight;
          weightedY += constraint.position.y * weight;
          maxZ = Math.max(maxZ, constraint.position.z);
          totalWeight += weight;
        });
        
        const finalPosition = {
          x: weightedX / totalWeight,
          y: weightedY / totalWeight,
          z: maxZ
        };
        
        // Debug logging to understand constraint decisions - DISABLED
        // if (Math.random() < 0.01) { // Log 1% of frames to avoid spam
        //   console.log("Constraint votes:", constraints.map(c => 
        //     `${c.name}: strength=${c.strength.toFixed(2)} (${c.reason})`
        //   ).join(", "));
        //   console.log(`Final position: (${(finalPosition.x * 111000).toFixed(1)}, ${(finalPosition.y * 111000).toFixed(1)})m`);
        // }
        
        // CHECK FOR HAZARDOUS ROUTE SECTION
        const currentRouteIndex = Math.round((currentRouteDistance / routeDistances[routeDistances.length - 1]) * (routeCoordinates.length - 1));
        const isHazardousSection = routeHazardMap[currentRouteIndex]?.isHazardous || false;
        
        if (isHazardousSection) {
          // HAZARD MODE: Ultra-simplified camera logic
          const hazardReasons = routeHazardMap[currentRouteIndex]?.reasons || [];
          if (Math.random() < 0.1) {
            console.log(`Hazard mode activated: ${hazardReasons.join(', ')} - using simplified camera`);
          }
          
          // Ultra-conservative: just follow route with heavy smoothing, no constraints
          const ultraSmoothingFactor = 0.8; // 80% smoothing in hazard zones
          return {
            x: cameraPos.x + (baseX - cameraPos.x) * (1 - ultraSmoothingFactor),
            y: cameraPos.y + (baseY - cameraPos.y) * (1 - ultraSmoothingFactor),
            z: targetZ
          };
        }
        
        // ANIMATION MODE: Skip constraint system entirely for pure route following
        if (isAnimationRunning) {
          return {
            x: baseX,
            y: baseY,
            z: targetZ
          };
        }
        
        // NORMAL MODE: Derivative-based jitter detection and smoothing
        return applyDerivativeBasedSmoothing(finalPosition, deltaTime);
      }
      
      // Fallback to biker position with terrain-aware height
      const fallbackHeightControl = document.getElementById('camera-height');
      const fallbackZoomOutAmount = fallbackHeightControl ? parseInt(fallbackHeightControl.value) : 50;
      const fallbackZoomFactor = Math.max(0, Math.min(1, fallbackZoomOutAmount / 100));
      
      const cameraHeight = calculateSimpleHeight(fallbackZoomFactor);
      
      return {
        x: bikerPos.x,
        y: bikerPos.y,
        z: bikerPos.z + cameraHeight
      };
    }
    
    // FRAMING CONTROLLER: Simplified - just maintain base zoom
    function framingController(bikerScreenPos) {
      // Keep zoom at base level - manual controls will override if needed
      zoomGoal = baseZoom;
    }
    
    // CAMERA SOLVER: Simple exponential smoothing for silky smooth movement
    function updateCameraPhysics(targetPos, targetFOV, deltaTime, bearing = 0) {
      // Get current manual zoom setting
      const heightControl = document.getElementById('camera-height');
      let desiredFOV = targetFOV;
      
      if (heightControl) {
        const heightValue = parseInt(heightControl.value);
        const heightRatio = heightValue / 100;
        desiredFOV = baseZoom + ((zoomMax - baseZoom) * heightRatio);
      }
      
      // Apply safety limits to FOV
      desiredFOV = Math.max(baseZoom, Math.min(zoomMax, desiredFOV));
      
      // Calculate zoom alpha (0: zoomed in, 1: zoomed out) for adaptive smoothing
      const zoomAlpha = Math.max(0, Math.min(1, (cameraFOV - baseZoom) / (zoomMax - baseZoom)));
      
      // Adaptive smoothing: faster when zoomed in, slower when zoomed out
      const adaptivePositionSmoothing = positionSmoothing + (0.15 * (1 - zoomAlpha));
      
      // Simple exponential smoothing for position - frame rate independent
      // Disable position smoothing during animation to prevent interference
      if (isAnimationRunning) {
        // Direct position update during animation for crisp movement
        cameraPos.x = targetPos.x;
        cameraPos.y = targetPos.y;
        cameraPos.z = targetPos.z;
      } else {
        // Normal smoothing when not animating
        const frameRateAdjustment = Math.min(1, deltaTime * 60); // Normalize to 60fps
        const actualPositionSmoothing = 1 - Math.pow(1 - adaptivePositionSmoothing, frameRateAdjustment);
        
        cameraPos.x += (targetPos.x - cameraPos.x) * actualPositionSmoothing;
        cameraPos.y += (targetPos.y - cameraPos.y) * actualPositionSmoothing;
        cameraPos.z += (targetPos.z - cameraPos.z) * actualPositionSmoothing;
      }
      
      // Simple exponential smoothing for FOV
      if (isAnimationRunning) {
        // Direct FOV update during animation
        cameraFOV = desiredFOV;
      } else {
        // Normal FOV smoothing when not animating
        const frameRateAdjustment = Math.min(1, deltaTime * 60); // Normalize to 60fps
        const actualZoomSmoothing = 1 - Math.pow(1 - zoomSmoothing, frameRateAdjustment);
        cameraFOV += (desiredFOV - cameraFOV) * actualZoomSmoothing;
      }
      
      // Apply safety limits to FOV
      cameraFOV = Math.max(baseZoom, Math.min(zoomMax, cameraFOV));
      
      // Use the bearing passed in from the animation loop (don't recalculate!)
      // This bearing has already been smoothed and calculated with inertia
      
      // FOV was already updated earlier in the function
      
      // Improved conversion from FOV to mapbox zoom level
      // With our new settings (FOV 50-70)
      // FOV 50 -> zoom 18, FOV 70 -> zoom 14
      const zoom = 22 - ((cameraFOV - 40) / 5);
      
      // Convert to map coordinates
      return {
        center: [cameraPos.x, cameraPos.y],
        bearing: bearing,
        pitch: cameraAngle,
        zoom: zoom
      };
    }
    
    // Get biker position on screen
    function getBikerScreenPosition() {
      // Safety check
      if (!map || !map.getSource('point')) return null;
      
      try {
        // Get the rider's current position
        const pointSource = map.getSource('point');
        if (!pointSource || !pointSource._data) return null;
        
        const pointFeature = pointSource._data;
        if (!pointFeature || !pointFeature.geometry || !pointFeature.geometry.coordinates) return null;
      
        const riderCoords = pointFeature.geometry.coordinates;
        
        // Convert rider coordinates to screen coordinates
        return map.project(riderCoords);
      } catch (e) {
        console.warn('Error getting rider screen position:', e);
        return null;
      }
    }
    
    // Clean, optimized animation function that implements the architecture from CAMERA.md
    // Enhanced to handle dynamic route smoothing based on zoom level
    function animateRoute(currentTime = performance.now(), token = animationToken) {
      // Check if this is the current animation instance
      if (token !== animationToken || !isAnimationRunning) {
        return;
      }
      
      // Calculate deltaTime but smooth it to prevent jitter from frame timing variations
      let rawDeltaTime = (currentTime - lastFrameTime) / 1000; // Convert to seconds
      lastFrameTime = currentTime;
      
      // Smooth deltaTime to reduce jitter from frame timing variations
      // Use exponential moving average to smooth timing inconsistencies
      const targetFrameTime = 1/60; // Target 60fps
      const deltaTime = Math.abs(rawDeltaTime - targetFrameTime) < 0.004 ? 
        targetFrameTime : // Use target if close to 60fps
        Math.max(0.008, Math.min(0.05, rawDeltaTime)); // Clamp to reasonable range otherwise
      
      // Safety check to avoid errors if route data isn't loaded
      if (!routeCoordinates || routeCoordinates.length === 0 || !routeDistances || routeDistances.length === 0) {
        pauseAnimation();
        console.warn('No route coordinates available for animation');
        return;
      }
      
      // Check if we've reached the end of the route
      const maxDistanceKm = routeDistances[routeDistances.length - 1];
      const maxDistanceMeters = maxDistanceKm * 1000;
      
      if (currentRouteDistance >= maxDistanceMeters) { // Convert km to m
        console.log(`Animation complete - currentRouteDistance: ${currentRouteDistance}m, maxDistance: ${maxDistanceMeters}m (${maxDistanceKm}km)`);
        console.log(`totalDistance variable: ${totalDistance}km, totalDistanceMeters variable: ${totalDistanceMeters}m`);
        pauseAnimation();
        // Reset button text to "Start" when animation completes
        const toggleBtn = document.getElementById('toggle-btn');
        if (toggleBtn) toggleBtn.textContent = "Start";
        
        // Ensure map interactions are re-enabled at the end of animation
        map.dragPan.enable();
        map.scrollZoom.enable();
        map.doubleClickZoom.enable();
        map.touchZoomRotate.enable();
        
        // Enable position slider
        const positionSlider = document.getElementById('position-slider');
        if (positionSlider) positionSlider.disabled = false;
        
        return;
      }
      
      // Frame-rate independent speed calculation  
      // Realistic cycling speed: ~15-25 m/s for visualization (54-90 km/h)
      const baseSpeedMPS = 20; // meters per second (more realistic for smooth movement)
      const distanceIncrement = baseSpeedMPS * animationSpeed * deltaTime;
      
      // Debug speed consistency - disabled during animation for performance
      // if (Math.random() < 0.01) { // Log occasionally
      //   console.log(`Speed: ${(baseSpeedMPS * animationSpeed).toFixed(1)} m/s, deltaTime: ${deltaTime.toFixed(3)}s, increment: ${distanceIncrement.toFixed(2)}m`);
      // }
      
      // Update current distance along route
      currentRouteDistance += distanceIncrement;
      
      // Convert to km for route lookup
      const currentDistanceKm = currentRouteDistance / 1000;
      
      // Get current zoom level to determine camera behavior
      const heightControl = document.getElementById('camera-height');
      const zoomOutAmount = heightControl ? parseInt(heightControl.value) : 50;
      
      // Calculate zoom factor (0 = zoomed in, 1 = zoomed out)
      const zoomFactor = Math.max(0, Math.min(1, zoomOutAmount / 100));
      
      
      // Get segment for RIDER position - always use raw route for rider
      // This ensures the rider always stays on the actual route
      const riderSegment = calculateSegmentForDistance(currentDistanceKm, false);
      const riderBeforeIdx = riderSegment.beforeIdx;
      const riderAfterIdx = riderSegment.afterIdx;
      const riderFraction = riderSegment.fraction;
      
      // Get the points for rider interpolation from raw route
      const riderBeforePoint = routeCoordinates[riderBeforeIdx];
      const riderAfterPoint = routeCoordinates[riderAfterIdx];
      
      // Create interpolated point for the rider position
      const interpolatedPoint = [
        riderBeforePoint[0] + (riderAfterPoint[0] - riderBeforePoint[0]) * riderFraction,
        riderBeforePoint[1] + (riderAfterPoint[1] - riderBeforePoint[1]) * riderFraction
      ];
      
      // Include elevation if available
      if (riderBeforePoint.length > 2 && riderAfterPoint.length > 2) {
        interpolatedPoint[2] = riderBeforePoint[2] + (riderAfterPoint[2] - riderBeforePoint[2]) * riderFraction;
      } else {
        interpolatedPoint[2] = 0;
      }
      
      // Debug position calculation occasionally - DISABLED
      // if (Math.random() < 0.005) { // Log very occasionally
      //   const usedDistances = riderSegment.useSmoothedRoute ? smoothedRouteDistances : routeDistances;
      //   const routeSegmentDistance = (usedDistances[riderAfterIdx] - usedDistances[riderBeforeIdx]) * 1000; // km to m
      //   const expectedPosition = usedDistances[riderBeforeIdx] + (riderFraction * (usedDistances[riderAfterIdx] - usedDistances[riderBeforeIdx]));
      //   const actualPosition = currentRouteDistance / 1000; // m to km
      //   console.log(`Position: segment ${riderBeforeIdx}-${riderAfterIdx}, fraction=${riderFraction.toFixed(3)}, route segment=${routeSegmentDistance.toFixed(1)}m, expected=${expectedPosition.toFixed(3)}km, actual=${actualPosition.toFixed(3)}km`);
      // }
      
      // Update the rider marker position
      updatePointPosition(interpolatedPoint);
      
      // Update tracking information for UI display
      currentPoint = riderBeforeIdx;
      currentPointFloat = riderBeforeIdx + riderFraction;
      
      // Get camera targeting points - use smoothed route when zoomed out for smooth camera movement
      let cameraCoords, cameraSegment, cameraBeforePoint, cameraAfterPoint, nextCameraPoint;
      
      // Use regular route for camera targeting
      cameraSegment = riderSegment;
      cameraCoords = routeCoordinates;
      cameraBeforePoint = riderBeforePoint;
      cameraAfterPoint = riderAfterPoint;
      const lookAheadIdx = Math.min(riderAfterIdx + 1, routeCoordinates.length - 1);
      nextCameraPoint = routeCoordinates[lookAheadIdx];
      
      // FORWARD-LOOKING CAMERA: Look ahead on route, not back at biker
      
      // Calculate where biker will be further ahead on the route
      // Look-ahead distance based on camera altitude (like real helicopter pilot)
      const altitudeFactor = Math.max(0.1, Math.min(1.0, (cameraFOV - baseZoom) / (zoomMax - baseZoom)));
      const forwardLookDistance = currentDistanceKm + (0.1 + altitudeFactor * 1.0); // 0.1-1.1km based on altitude
        
      const clampedForwardDistance = Math.min(forwardLookDistance, routeDistances[routeDistances.length - 1]);
      
      // Get the forward point on the route
      const forwardSegment = calculateSegmentForDistance(clampedForwardDistance, false);
      const forwardCoords = routeCoordinates;
      
      let targetBearing = currentBearing; // Default: keep current direction
      
      if (forwardSegment && forwardCoords[forwardSegment.afterIdx]) {
        const beforePoint = forwardCoords[forwardSegment.beforeIdx];
        const afterPoint = forwardCoords[forwardSegment.afterIdx];
        const fraction = forwardSegment.fraction;
        
        // Interpolate the forward point
        const forwardX = beforePoint[0] + (afterPoint[0] - beforePoint[0]) * fraction;
        const forwardY = beforePoint[1] + (afterPoint[1] - beforePoint[1]) * fraction;
        
        // Calculate bearing toward this forward point (where biker is going)
        targetBearing = calculateBearing([cameraPos.x, cameraPos.y], [forwardX, forwardY]);
      }
      
      
      if (zoomFactor > 0.5) {
        // ZOOMED OUT: Camera has strong inertia and barely responds
        const bearingError = ((targetBearing - currentBearing + 540) % 360) - 180;
        
        // Only make tiny corrections if significantly off-course
        let correction = 0;
        if (Math.abs(bearingError) > 15) {
          correction = Math.sign(bearingError) * 0.05; // Fixed 0.05 degree correction
        }
        
        // Apply correction with massive momentum
        cameraVelocity.bearing = cameraVelocity.bearing * 0.999 + correction * 0.001;
        cameraVelocity.bearing = Math.max(-0.1, Math.min(0.1, cameraVelocity.bearing));
        
      } else {
        // ZOOMED IN: More responsive tracking
        const bearingError = ((targetBearing - currentBearing + 540) % 360) - 180;
        const correction = bearingError * 0.01;
        cameraVelocity.bearing = cameraVelocity.bearing * 0.9 + correction * 0.1;
        cameraVelocity.bearing = Math.max(-2.0, Math.min(2.0, cameraVelocity.bearing));
      }
      
      // Apply velocity to bearing
      currentBearing = currentBearing + cameraVelocity.bearing;
      const bearing = currentBearing;
      
      // ===== CAMERA SYSTEM ARCHITECTURE PER CAMERA.md =====
      
      // 1. BIKER STATE - always use actual rider position
      const bikerPos = {
        x: interpolatedPoint[0],
        y: interpolatedPoint[1],
        z: interpolatedPoint[2]
      };
      
      
      // Calculate velocity using camera targeting points for smooth movement
      let bikerVel;
      // Safety check for valid points
      if (!nextCameraPoint || !Array.isArray(nextCameraPoint) || nextCameraPoint.length < 2 || 
          !cameraAfterPoint || !Array.isArray(cameraAfterPoint) || cameraAfterPoint.length < 2) {
        console.warn('Invalid points for velocity calculation');
        // Provide a safe default velocity
        bikerVel = { x: 0, y: 0, z: 0 };
      } else {
        // Calculate raw velocity
        let dx = nextCameraPoint[0] - cameraAfterPoint[0];
        let dy = nextCameraPoint[1] - cameraAfterPoint[1];
        let dz = (nextCameraPoint.length > 2 && cameraAfterPoint.length > 2) ? 
                  (nextCameraPoint[2] - cameraAfterPoint[2]) : 0;
        
        
        // Scale velocity by animation speed, but keep it reasonable
        const scaleFactor = Math.min(5.0, animationSpeed) * 0.0005;
        
        bikerVel = {
          x: dx * scaleFactor,
          y: dy * scaleFactor,
          z: dz * scaleFactor
        };
      }
      
      // CAMERA SYSTEM: Only update camera if followPath is enabled
      if (followPath) {
        // 2. TARGET-POINT MODULE
        const targetPoint = calculateTargetPoint(bikerPos, bikerVel, deltaTime);
        
        // 3. FRAMING CONTROLLER
        const bikerScreenPos = getBikerScreenPosition();
        framingController(bikerScreenPos);
        
        // 4. CAMERA SOLVER
        const newCameraState = updateCameraPhysics(targetPoint, zoomGoal, deltaTime, bearing);
        
        // Apply the new camera state with anti-jitter protection
        safeCameraUpdate(newCameraState, "MAIN_ANIMATION");
      }
      
      // Update UI elements
      updateProgress();
      
      // Continue animation - but only if we're still supposed to be running
      // Use setTimeout for consistent 60fps (16.67ms) instead of requestAnimationFrame
      // This prevents high refresh rate displays from causing jitter
      if (isAnimationRunning && token === animationToken) {
        animationId = setTimeout(() => animateRoute(performance.now(), token), 16.67);
      } else {
        animationId = null;
      }
    }
    
    // Helper functions and UI-related code (mostly unchanged)
    
    // Update progress and UI
    function updateProgress() {
      if (routeCoordinates.length === 0 || routeDistances.length === 0 || totalDistanceMeters === 0) return;
      
      const progress = currentRouteDistance / totalDistanceMeters;
      
      // Update progress element
      const progressEl = document.getElementById('progress');
      progressEl.textContent = `${Math.round(progress * 100)}%`;
      
      // Update distance traveled - always show actual geographic distance
      const distanceTraveledEl = document.getElementById('distance-traveled');
      const actualDistanceTraveled = progress * routeDistances[routeDistances.length - 1]; // progress × actual route distance
      distanceTraveledEl.textContent = `${actualDistanceTraveled.toFixed(1)} km`;
      
      // Update position slider without triggering its change event (unless user is manually adjusting)
      if (!userAdjustingPosition) {
        const positionSlider = document.getElementById('position-slider');
        const newValue = progress * 100;
        positionSlider.value = newValue;
        
      } else {
        console.log('Skipping automatic slider update - user is adjusting position');
      }
      
      // Update elevation marker
      updateElevationMarker(progress);
      
      // Get current and next points for interpolation
      const currentIdx = Math.floor(currentPointFloat);
      const nextIdx = Math.min(currentIdx + 1, routeCoordinates.length - 1);
      const pointFraction = currentPointFloat - currentIdx;
      
      // Get interpolated elevation
      let currentElevation;
      if (routeCoordinates[currentIdx].length > 2 && routeCoordinates[nextIdx].length > 2) {
        currentElevation = routeCoordinates[currentIdx][2] + 
                          (routeCoordinates[nextIdx][2] - routeCoordinates[currentIdx][2]) * pointFraction;
      } else {
        currentElevation = routeCoordinates[currentIdx][2] || 0;
      }
      
      const currentElevationEl = document.getElementById('current-elevation');
      currentElevationEl.textContent = `${Math.round(currentElevation)} m`;
      
      // Calculate gradient using about 100m look-behind distance
      const coordinates = routeCoordinates;
      
      // Find a point ~100m back from our current position
      let lookBehindDistance = Math.max(0, currentRouteDistance - 100); // meters
      let lookBehindDistanceKm = lookBehindDistance / 1000;
      let prevPointIdx = 0;
      
      // Find the closest point for our look-behind distance
      for (let i = 0; i < routeDistances.length; i++) {
        if (routeDistances[i] >= lookBehindDistanceKm) {
          prevPointIdx = Math.max(0, i - 1);
          break;
        }
      }
      
      // Calculate the elevation change over this distance using the correct coordinates
      const prevElevation = coordinates[prevPointIdx][2] || 0;
      const elevationChange = currentElevation - prevElevation;
      
      // Calculate the actual distance between these points
      const actualDistance = (currentRouteDistance - (routeDistances[prevPointIdx] * 1000)); // in meters
      
      // Debug gradient calculation occasionally - DISABLED
      // if (Math.random() < 0.02) { // Log occasionally
      //   console.log(`Gradient calc: currentElevation=${currentElevation.toFixed(1)}m, prevElevation=${prevElevation.toFixed(1)}m`);
      //   console.log(`ElevationChange=${elevationChange.toFixed(1)}m, actualDistance=${actualDistance.toFixed(1)}m`);
      //   console.log(`CurrentRouteDistance=${currentRouteDistance.toFixed(1)}m, prevPointDistance=${(routeDistances[prevPointIdx] * 1000).toFixed(1)}m`);
      //   console.log(`PrevPointIdx=${prevPointIdx}, lookBehindDistanceKm=${lookBehindDistanceKm.toFixed(2)}km`);
      // }
      
      const currentGradientEl = document.getElementById('current-gradient');
      if (actualDistance > 10) { // Only calculate gradient if we have sufficient distance
        const gradient = (elevationChange / actualDistance) * 100;
        currentGradientEl.textContent = `${gradient.toFixed(1)}%`;
        
        // Change gradient text color based on steepness
        if (gradient > 8) {
          currentGradientEl.style.color = '#e74c3c'; // Steep - red
        } else if (gradient > 4) {
          currentGradientEl.style.color = '#f39c12'; // Moderate - orange
        } else if (gradient < -4) {
          currentGradientEl.style.color = '#2ecc71'; // Descent - green
        } else {
          currentGradientEl.style.color = '#2c3e50'; // Flat - default
        }
      }
    }
    
    // Update elevation marker on the profile
    function updateElevationMarker(progress) {
      const elevationMarker = document.getElementById('elevation-marker');
      if (!elevationMarker) return;
      
      const elevationProfile = document.querySelector('.elevation-profile');
      if (!elevationProfile) return;
      
      const profileWidth = elevationProfile.offsetWidth;
      const markerPosition = profileWidth * progress;
      
      elevationMarker.style.left = `${markerPosition}px`;
      elevationMarker.style.display = 'block';
    }
    
    // Add terrain and common sources/layers function
    function addTerrainAndSources(exaggerationValue = 1.0) {
      try {
        // Add terrain source if it doesn't exist
        if (!map.getSource('mapbox-dem')) {
          map.addSource('mapbox-dem', {
            'type': 'raster-dem',
            'url': 'mapbox://mapbox.mapbox-terrain-dem-v1',
            'tileSize': 512,
            'maxzoom': 14
          });
        }
        
        // Add sky layer if it doesn't exist
        if (!map.getLayer('sky')) {
          map.addLayer({
            'id': 'sky',
            'type': 'sky',
            'paint': {
              'sky-type': 'atmosphere',
              'sky-atmosphere-sun': [0.0, 0.0],
              'sky-atmosphere-sun-intensity': 15
            }
          });
        }
        
        // Use fixed 1.0 terrain exaggeration - no slider adjustment
        const exaggeration = exaggerationValue;
        
        // Add 3D terrain
        map.setTerrain({ 'source': 'mapbox-dem', 'exaggeration': exaggeration });
        
        // Add route source and layer if needed
        if (!map.getSource('route') && routeCoordinates.length > 0) {
          map.addSource('route', {
            type: 'geojson',
            data: {
              type: 'Feature',
              properties: {},
              geometry: {
                type: 'LineString',
                coordinates: routeCoordinates.map(coord => [coord[0], coord[1]])
              }
            }
          });
          
          map.addLayer({
            id: 'route',
            type: 'line',
            source: 'route',
            layout: {
              'line-join': 'round',
              'line-cap': 'round'
            },
            paint: {
              'line-color': '#3498db',
              'line-width': 5,
              'line-opacity': 0.8
            }
          });
        }
        
        // Add point source and layer if needed
        if (!map.getSource('point') && routeCoordinates.length > 0) {
          map.addSource('point', {
            type: 'geojson',
            data: {
              type: 'Feature',
              properties: {},
              geometry: {
                type: 'Point',
                coordinates: [routeCoordinates[currentPoint][0], routeCoordinates[currentPoint][1]]
              }
            }
          });
          
          map.addLayer({
            id: 'point',
            type: 'circle',
            source: 'point',
            paint: {
              'circle-radius': 8,
              'circle-color': '#e74c3c',
              'circle-stroke-width': 2,
              'circle-stroke-color': '#ffffff'
            }
          });
        }
        
        return true;
      } catch (e) {
        console.warn('Error adding terrain or sources:', e);
        return false;
      }
    }
    
    // Initialize the map
    function initMap() {
      map = new mapboxgl.Map({
        container: 'map',
        style: 'mapbox://styles/mapbox/satellite-streets-v12',
        center: [0, 0], // Will be updated when route is loaded
        zoom: 13,
        pitch: 50,
        bearing: 0,
        antialias: true, // Smoother lines
        attributionControl: false
      });
      
      // Add attribution separately to have more control over its position
      map.addControl(new mapboxgl.AttributionControl({
        compact: true
      }));
      
      // Add navigation controls
      map.addControl(new mapboxgl.NavigationControl(), 'top-right');
      
      // Initially disable map interactions since followPath defaults to true
      map.boxZoom.disable();
      map.scrollZoom.disable();
      map.dragPan.disable();
      map.dragRotate.disable();
      map.keyboard.disable();
      map.doubleClickZoom.disable();
      map.touchZoomRotate.disable();
      
      // Initialize the camera position and velocity
      map.on('load', () => {
        cameraPos = {
          x: map.getCenter().lng,
          y: map.getCenter().lat,
          z: 0
        };
        cameraVel = { x: 0, y: 0, z: 0 };
        cameraFOV = baseZoom;
        cameraFOVVel = 0; // Initialize velocity for spring physics
      });
      
      // Add click-to-toggle functionality for follow path
      map.on('click', (e) => {
        console.log('Map clicked, current followPath:', followPath);
        const followPathToggle = document.getElementById('follow-path-toggle');
        if (followPathToggle) {
          followPathToggle.checked = !followPathToggle.checked;
          followPathToggle.dispatchEvent(new Event('change'));
        }
        e.preventDefault();
      });
    }
    
    // Load a GPX route
    async function loadRoute(routeFile, applyHeightImmediately = false) {
      document.getElementById('loading').style.display = 'flex';
      
      // Ensure buttons are disabled during load
      document.getElementById('toggle-btn').disabled = true;
      document.getElementById('reset-btn').disabled = true;
      document.getElementById('recenter-btn').disabled = true;
      
      try {
        // If map has route layer, remove it
        if (map.getLayer('route')) {
          map.removeLayer('route');
        }
        
        // If map has route source, remove it
        if (map.getSource('route')) {
          map.removeSource('route');
        }
        
        // If map has point layer, remove it
        if (map.getLayer('point')) {
          map.removeLayer('point');
        }
        
        // If map has point source, remove it
        if (map.getSource('point')) {
          map.removeSource('point');
        }
        
        const response = await axios.get(`gpx/${routeFile}`);
        const gpxData = response.data;
        
        // Parse GPX data
        const parser = new DOMParser();
        const gpx = parser.parseFromString(gpxData, 'text/xml');
        
        // Extract track points
        const trackPoints = gpx.querySelectorAll('trkpt');
        
        // Reset route data completely
        routeCoordinates = [];
        totalDistance = 0;
        routeDistances = [];
        smoothedRouteCoordinates = [];
        smoothedRouteDistances = [];
        
        // Reset tracking state
        currentPoint = 0;
        currentPointFloat = 0;
        currentRouteDistance = 0;
        
        // Extract elevation gain
        elevationGain = 0;
        let previousElevation = null;
        let minElevation = Infinity;
        let maxElevation = -Infinity;
        
        // Parse route coordinates and calculate cumulative distance
        for (let i = 0; i < trackPoints.length; i++) {
          const point = trackPoints[i];
          const lat = parseFloat(point.getAttribute('lat'));
          const lon = parseFloat(point.getAttribute('lon'));
          const ele = point.querySelector('ele');
          const elevation = ele ? parseFloat(ele.textContent) : 0;
          
          if (elevation < minElevation) minElevation = elevation;
          if (elevation > maxElevation) maxElevation = elevation;
          
          // Calculate elevation gain
          if (previousElevation !== null && elevation > previousElevation) {
            elevationGain += elevation - previousElevation;
          }
          previousElevation = elevation;
          
          const coordinate = [lon, lat, elevation];
          routeCoordinates.push(coordinate);
          
          // Calculate distance from previous point
          if (i > 0) {
            const prevPoint = [routeCoordinates[i-1][0], routeCoordinates[i-1][1]];
            const currentPoint = [lon, lat];
            const segmentDistance = turf.distance(turf.point(prevPoint), turf.point(currentPoint));
            totalDistance += segmentDistance;
          }
          
          // Store cumulative distance at each point (in kilometers)
          routeDistances.push(totalDistance);
        }
        
        // Log route information
        console.log(`Loaded route ${routeFile} with ${routeCoordinates.length} points and ${totalDistance.toFixed(1)}km total distance`);
        
        // Debug: Check if route distances are consistent
        if (routeDistances.length > 10) {
          for (let i = 1; i < Math.min(11, routeDistances.length); i++) {
            const segmentDist = routeDistances[i] - routeDistances[i-1];
            console.log(`Segment ${i}: ${(segmentDist * 1000).toFixed(1)}m`);
          }
        }
        
        
        // Initialize map and camera
        if (routeCoordinates.length > 0) {
          // Save total distance for progress calculations
          totalDistanceMeters = totalDistance * 1000; // km to meters
          
          // Reset camera physics state
          cameraVel = { x: 0, y: 0, z: 0 };
          cameraFOVVel = 0;
          
          // Reset framing controller state
          framingState = "IN_SAFE";
          stateTimer = 0;
          zoomGoal = baseZoom;
          
          // Analyze route for camera hazards
          analyzeRouteForHazards();
          
          // Update UI
          document.getElementById('total-distance').textContent = `${totalDistance.toFixed(1)} km`;
          document.getElementById('elevation-gain').textContent = `${Math.round(elevationGain)} m`;
          document.getElementById('progress').textContent = "0%";
          document.getElementById('distance-traveled').textContent = "0.0 km";
          document.getElementById('current-elevation').textContent = "--";
          document.getElementById('current-gradient').textContent = "--";
          
          // Reset position slider
          const positionSlider = document.getElementById('position-slider');
          if (positionSlider) positionSlider.value = 0;
          
          // Hide elevation marker
          const elevationMarker = document.getElementById('elevation-marker');
          if (elevationMarker) elevationMarker.style.display = 'none';
          
          // Set map center to start of route - use safeCameraUpdate
          safeCameraUpdate({
            center: [routeCoordinates[0][0], routeCoordinates[0][1]],
            zoom: 13,
            pitch: cameraAngle,
            bearing: 0,
            duration: 1500
          }, "INITIAL_SETUP");
          
          // Initialize camera position and state
          // Start with a good initial position slightly behind and above the route start
          if (routeCoordinates.length > 5) {
            // Calculate initial direction from first few points
            const startPoint = routeCoordinates[0];
            const aheadPoint = routeCoordinates[5];
            const initialBearing = calculateBearing(startPoint, aheadPoint);
            
            // Convert to radians for offset calculation
            const bearingRad = (initialBearing + 180) % 360 * Math.PI / 180;
            
            // Position camera slightly behind and above the start point
            cameraPos = {
              x: startPoint[0] - 0.0002 * Math.sin(bearingRad),
              y: startPoint[1] - 0.0002 * Math.cos(bearingRad),
              z: (startPoint[2] || 0) + verticalOffset
            };
            
            // Reset camera state
            cameraFOV = baseZoom;
            currentBearing = initialBearing; // Initialize bearing for smooth transitions
            cameraVelocity = { bearing: 0, speed: 0 }; // Reset camera momentum
            currentWaypoint = null; // Reset waypoint
            waypointUpdateTimer = 0; // Reset timer
          } else {
            // Fallback for routes with fewer points
            cameraPos = {
              x: routeCoordinates[0][0],
              y: routeCoordinates[0][1],
              z: (routeCoordinates[0][2] || 0) + verticalOffset
            };
            currentBearing = 0; // Initialize bearing for smooth transitions
            cameraVelocity = { bearing: 0, speed: 0 }; // Reset camera momentum
            currentWaypoint = null; // Reset waypoint
            waypointUpdateTimer = 0; // Reset timer
          }
          
          // When map is ready, add terrain and layers
          map.once('moveend', () => {
            updateInitialMapView(applyHeightImmediately);
            
            // Draw elevation profile
            drawElevationProfile();
            
            // Hide loading spinner
            document.getElementById('loading').style.display = 'none';
            
            // Enable buttons
            document.getElementById('toggle-btn').disabled = false;
            document.getElementById('reset-btn').disabled = false;
            document.getElementById('recenter-btn').disabled = false;
          });
        }
      } catch (error) {
        console.error('Error loading GPX route:', error);
        document.getElementById('loading').style.display = 'none';
        document.getElementById('toggle-btn').disabled = false;
        document.getElementById('reset-btn').disabled = false;
        document.getElementById('recenter-btn').disabled = false;
      }
    }
    
    // Update initial map view
    function updateInitialMapView(applyHeightImmediately = false) {
      if (!map || routeCoordinates.length === 0) return;
      
      // Add terrain and layers
      addTerrainAndSources(1.0);
      
      // Reset position
      currentPoint = 0;
      currentPointFloat = 0;
      currentRouteDistance = 0;
      
      // Update point position
      if (map.getSource('point')) {
        updatePointPosition(routeCoordinates[0]);
      }
      
      // Update camera position
      cameraPos = {
        x: routeCoordinates[0][0],
        y: routeCoordinates[0][1],
        z: routeCoordinates[0][2] || 0
      };
      
      // Reset velocity
      cameraVel = { x: 0, y: 0, z: 0 };
      cameraFOVVel = 0; // Reset FOV velocity for spring physics
      
      // Reset framing controller
      framingState = "IN_SAFE";
      stateTimer = 0;
      zoomGoal = baseZoom;
      
      // Update progress UI
      updateProgress();
    }
    
    // Draw elevation profile
    function drawElevationProfile() {
      const canvas = document.getElementById('elevation-canvas');
      if (!canvas || routeCoordinates.length === 0) return;
      
      const ctx = canvas.getContext('2d');
      const canvasWidth = canvas.clientWidth;
      const canvasHeight = canvas.clientHeight;
      
      // Set canvas dimensions to match display size
      canvas.width = canvasWidth;
      canvas.height = canvasHeight;
      
      // Clear canvas
      ctx.clearRect(0, 0, canvasWidth, canvasHeight);
      
      // Find min and max elevation
      let minEle = Infinity;
      let maxEle = -Infinity;
      
      for (const point of routeCoordinates) {
        if (point.length > 2) {
          minEle = Math.min(minEle, point[2]);
          maxEle = Math.max(maxEle, point[2]);
        }
      }
      
      // Add padding to elevation range
      const padding = (maxEle - minEle) * 0.1;
      minEle = Math.max(0, minEle - padding);
      maxEle = maxEle + padding;
      
      // Draw elevation profile
      ctx.beginPath();
      ctx.moveTo(0, canvasHeight);
      
      for (let i = 0; i < routeCoordinates.length; i++) {
        const x = (i / (routeCoordinates.length - 1)) * canvasWidth;
        const elevation = routeCoordinates[i].length > 2 ? routeCoordinates[i][2] : 0;
        const y = canvasHeight - ((elevation - minEle) / (maxEle - minEle)) * canvasHeight;
        
        if (i === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      }
      
      // Complete the path to the bottom of the canvas
      ctx.lineTo(canvasWidth, canvasHeight);
      ctx.lineTo(0, canvasHeight);
      
      // Fill the elevation profile
      const gradient = ctx.createLinearGradient(0, 0, 0, canvasHeight);
      gradient.addColorStop(0, 'rgba(46, 204, 113, 0.8)');
      gradient.addColorStop(1, 'rgba(52, 152, 219, 0.4)');
      
      ctx.fillStyle = gradient;
      ctx.fill();
      
      // Draw the profile line
      ctx.beginPath();
      for (let i = 0; i < routeCoordinates.length; i++) {
        const x = (i / (routeCoordinates.length - 1)) * canvasWidth;
        const elevation = routeCoordinates[i].length > 2 ? routeCoordinates[i][2] : 0;
        const y = canvasHeight - ((elevation - minEle) / (maxEle - minEle)) * canvasHeight;
        
        if (i === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      }
      
      ctx.strokeStyle = 'rgba(41, 128, 185, 0.8)';
      ctx.lineWidth = 2;
      ctx.stroke();
    }
    
    // Toggle animation
    function toggleAnimation() {
      const toggleBtn = document.getElementById('toggle-btn');
      if (isAnimationRunning) {
        pauseAnimation();
        if (toggleBtn) toggleBtn.textContent = "Start";
      } else {
        startAnimation();
        if (toggleBtn) toggleBtn.textContent = "Pause";
      }
    }
    
    // Start animation
    function startAnimation() {
      if (isAnimationRunning) {
        return; // Already running
      }
      
      // Create unique token for this animation instance
      animationToken = Date.now() + Math.random();
      
      // Set animation flag first
      isAnimationRunning = true;
      
      // Disable interactions during animation
      map.dragPan.disable();
      map.scrollZoom.disable();
      map.doubleClickZoom.disable();
      map.touchZoomRotate.disable();
      
      // Disable position slider during animation
      document.getElementById('position-slider').disabled = true;
      
      // Enable reset button
      document.getElementById('reset-btn').disabled = false;
      
      // Start animation loop using setTimeout for consistent 60fps (single entry point)
      animationId = setTimeout(() => animateRoute(performance.now(), animationToken), 16.67);
    }
    
    // Pause animation
    function pauseAnimation() {
      // Invalidate token and stop animation flag first
      animationToken = null;
      isAnimationRunning = false;
      
      if (animationId) {
        clearTimeout(animationId);
        animationId = null;
      }
      
      // Re-enable interactions
      map.dragPan.enable();
      map.scrollZoom.enable();
      map.doubleClickZoom.enable();
      map.touchZoomRotate.enable();
      
      // Enable position slider
      document.getElementById('position-slider').disabled = false;
    }
    
    // Reset animation
    function resetAnimation() {
      // Pause animation if running
      pauseAnimation();
      
      // Reset position
      currentPoint = 0;
      currentPointFloat = 0;
      currentRouteDistance = 0;
      
      // Update point position
      if (map.getSource('point')) {
        updatePointPosition(routeCoordinates[0]);
      }
      
      // Reset camera position
      cameraPos = {
        x: routeCoordinates[0][0],
        y: routeCoordinates[0][1],
        z: routeCoordinates[0][2] || 0
      };
      
      // Reset camera state
      cameraFOV = baseZoom;
      
      // Update camera position - use safeCameraUpdate
      safeCameraUpdate({
        center: [routeCoordinates[0][0], routeCoordinates[0][1]],
        zoom: 13,
        pitch: cameraAngle,
        bearing: 0,
        duration: 1000
      }, "ROUTE_LOAD");
      
      // Reset framing controller
      framingState = "IN_SAFE";
      stateTimer = 0;
      zoomGoal = baseZoom;
      
      // Update progress UI
      updateProgress();
      
      // Reset button text
      const toggleBtn = document.getElementById('toggle-btn');
      if (toggleBtn) toggleBtn.textContent = "Start";
    }
    
    // Function to manually update position based on slider
    function updatePositionManually(positionPercent) {
      // Safety check
      if (!routeCoordinates || routeCoordinates.length === 0 || !routeDistances || routeDistances.length === 0) {
        return;
      }
      
      // Use regular route distances
      const totalDistanceMeters = routeDistances[routeDistances.length - 1] * 1000; // km to m
      currentRouteDistance = positionPercent * totalDistanceMeters;
      
      // Convert current distance to km for comparison with routeDistances
      const currentDistanceKm = currentRouteDistance / 1000;
      
      // Get segment using the route
      const segment = calculateSegmentForDistance(currentDistanceKm, false);
      const beforeIdx = segment.beforeIdx;
      const afterIdx = segment.afterIdx;
      const fraction = segment.fraction;
      
      // Get the two points
      const beforePoint = routeCoordinates[beforeIdx];
      const afterPoint = routeCoordinates[afterIdx];
      
      // Create interpolated point
      const interpolatedPoint = [
        beforePoint[0] + (afterPoint[0] - beforePoint[0]) * fraction,
        beforePoint[1] + (afterPoint[1] - beforePoint[1]) * fraction
      ];
      
      // Include elevation if available
      if (beforePoint.length > 2 && afterPoint.length > 2) {
        interpolatedPoint[2] = beforePoint[2] + (afterPoint[2] - beforePoint[2]) * fraction;
      }
      
      // Update rider position
      updatePointPosition(interpolatedPoint);
      
      // Update current tracking point indices
      currentPoint = beforeIdx;
      currentPointFloat = beforeIdx + fraction;
      
      // Update UI
      updateProgress();
      
      // Update camera position
      // Calculate the bearing
      const bearing = calculateBearing(beforePoint, afterPoint);
      
      // Update biker position
      const bikerPos = {
        x: interpolatedPoint[0],
        y: interpolatedPoint[1],
        z: interpolatedPoint[2] || 0
      };
      
      // Calculate velocity based on next point
      const lookAheadIdx = Math.min(afterIdx + 1, routeCoordinates.length - 1);
      const nextPoint = routeCoordinates[lookAheadIdx];
      
      let bikerVel;
      // Safety check for valid points
      if (!nextPoint || !Array.isArray(nextPoint) || nextPoint.length < 2 || 
          !interpolatedPoint || !Array.isArray(interpolatedPoint) || interpolatedPoint.length < 2) {
        console.warn('Invalid points for velocity calculation in manual update');
        // Provide a safe default velocity
        bikerVel = { x: 0, y: 0, z: 0 };
      } else {
        // Calculate velocity with scaled magnitude
        const dx = nextPoint[0] - interpolatedPoint[0];
        const dy = nextPoint[1] - interpolatedPoint[1];
        const dz = (nextPoint.length > 2 && interpolatedPoint.length > 2) ? 
                    (nextPoint[2] - interpolatedPoint[2]) : 0;
        
        // Scale velocity for manual updates
        const scaleFactor = 0.0002;
        
        bikerVel = {
          x: dx * scaleFactor,
          y: dy * scaleFactor,
          z: dz * scaleFactor
        };
      }
      
      // Calculate target position (use default deltaTime for manual positioning)
      const targetPoint = calculateTargetPoint(bikerPos, bikerVel);
      
      // Set the camera position directly for manual positioning
      cameraPos = {
        x: targetPoint.x,
        y: targetPoint.y,
        z: targetPoint.z
      };
      
      // Jump to the new position - use safeCameraUpdate
      safeCameraUpdate({
        center: [targetPoint.x, targetPoint.y],
        zoom: 13,
        bearing: bearing,
        pitch: cameraAngle
      }, "ROUTE_SWITCH");
    }
    
    // Calculate bearing between two coordinates
    function calculateBearing(start, end) {
      // Safety check for invalid coordinates
      if (!start || !end || !Array.isArray(start) || !Array.isArray(end) || 
          start.length < 2 || end.length < 2) {
        console.warn('Invalid coordinates for bearing calculation:', start, end);
        return 0; // Default bearing
      }
      
      try {
        const startLat = start[1] * Math.PI / 180;
        const startLng = start[0] * Math.PI / 180;
        const endLat = end[1] * Math.PI / 180;
        const endLng = end[0] * Math.PI / 180;
        
        const y = Math.sin(endLng - startLng) * Math.cos(endLat);
        const x = Math.cos(startLat) * Math.sin(endLat) - 
                  Math.sin(startLat) * Math.cos(endLat) * Math.cos(endLng - startLng);
        
        const bearing = Math.atan2(y, x) * 180 / Math.PI;
        return (bearing + 360) % 360;
      } catch (e) {
        console.warn('Error calculating bearing:', e);
        return 0; // Default bearing on error
      }
    }
    
    // Event listeners
    document.addEventListener('DOMContentLoaded', () => {
      initMap();
      
      // DOM elements
      const routeSelect = document.getElementById('route-select');
      const heightControl = document.getElementById('camera-height');
      const angleControl = document.getElementById('camera-angle');
      const speedControl = document.getElementById('speed-control');
      const positionSlider = document.getElementById('position-slider');
      const toggleBtn = document.getElementById('toggle-btn');
      const resetBtn = document.getElementById('reset-btn');
      
      // Check URL parameters for requested route
      const initialRoute = parseUrlParams();
      
      // Load the initial route from URL parameter if available
      if (initialRoute) {
        loadRoute(initialRoute, true);
      }
      
      routeSelect.addEventListener('change', () => {
        // Ensure animation is paused before loading new route
        if (animationId) {
          pauseAnimation();
          
          // Reset button text to "Start"
          if (toggleBtn) toggleBtn.textContent = "Start";
        }
        
        // Reset all state variables before loading the new route
        // This prevents the camera from following the old route
        resetAllStateVariables();
        
        // Load the new route
        loadRoute(routeSelect.value, true); // Apply camera height immediately on route change
        
        // Update URL hash to make the current route shareable
        window.location.hash = `route=${routeSelect.value}`;
      });
      
      // Function to completely reset all state variables when changing routes
      function resetAllStateVariables() {
        // Reset route data
        routeCoordinates = [];
        routeDistances = [];
        
        // Reset position tracking
        currentPoint = 0;
        currentPointFloat = 0;
        currentRouteDistance = 0;
        totalDistance = 0;
        totalDistanceMeters = 0;
        
        // Reset camera physics state
        cameraPos = { x: 0, y: 0, z: 0 };
        cameraVel = { x: 0, y: 0, z: 0 };
        cameraFOV = baseZoom;
        cameraFOVVel = 0;
        
        // Reset framing controller state
        framingState = "IN_SAFE";
        stateTimer = 0;
        zoomGoal = baseZoom;
        
        // Reset UI elements
        document.getElementById('progress').textContent = "0%";
        document.getElementById('distance-traveled').textContent = "0.0 km";
        document.getElementById('current-elevation').textContent = "--";
        document.getElementById('current-gradient').textContent = "--";
        document.getElementById('total-distance').textContent = "--";
        document.getElementById('elevation-gain').textContent = "--";
        
        // Reset position slider
        const positionSlider = document.getElementById('position-slider');
        if (positionSlider) positionSlider.value = 0;
        
        // Hide elevation marker
        const elevationMarker = document.getElementById('elevation-marker');
        if (elevationMarker) elevationMarker.style.display = 'none';
      }
      
      toggleBtn.addEventListener('click', toggleAnimation);
      resetBtn.addEventListener('click', resetAnimation);
      
      // Recenter camera handler
      const recenterBtn = document.getElementById('recenter-btn');
      recenterBtn.addEventListener('click', () => {
        // Get current rider position
        if (routeCoordinates.length === 0) return;
        
        // Calculate current rider position
        const currentDistanceKm = currentRouteDistance / 1000;
        const segment = calculateSegmentForDistance(currentDistanceKm);
        
        if (segment && routeCoordinates[segment.afterIdx]) {
          const beforePoint = routeCoordinates[segment.beforeIdx];
          const afterPoint = routeCoordinates[segment.afterIdx];
          const fraction = segment.fraction;
          
          // Interpolate current rider position
          const riderLng = beforePoint[0] + (afterPoint[0] - beforePoint[0]) * fraction;
          const riderLat = beforePoint[1] + (afterPoint[1] - beforePoint[1]) * fraction;
          
          // Smoothly fly to rider position - use safeCameraUpdate
          safeCameraUpdate({
            center: [riderLng, riderLat],
            zoom: 15, // Nice zoom level to see the rider and surroundings
            duration: 1000 // 1 second smooth transition
          }, "RECENTER_BUTTON");
        }
      });
      
      // Camera height handler - updates view immediately
      heightControl.addEventListener('input', () => {
        cameraHeight = parseInt(heightControl.value);
        
        // If not animating, update the view immediately
        if (!animationId) {
          // Calculate target FOV based on height slider
          const heightRatio = cameraHeight / 100;
          const targetFOV = baseZoom + ((zoomMax - baseZoom) * heightRatio);
          
          // Convert FOV to mapbox zoom
          const zoomLevel = 21 - ((targetFOV - 40) / 10);
          
          // Update the map view with new zoom - use safeCameraUpdate
          safeCameraUpdate({
            zoom: zoomLevel,
            pitch: cameraAngle,
            duration: 500
          }, "HEIGHT_SLIDER");
        }
      });
      
      // Camera angle handler - updates view immediately
      angleControl.addEventListener('input', () => {
        // Invert the values - slider shows low to high (10-85)
        const sliderValue = parseInt(angleControl.value);
        
        // Calculate inverted angle - when slider is at min (10), we want max angle (85)
        // and vice versa
        cameraAngle = 95 - sliderValue; // 95 - 10 = 85, 95 - 85 = 10
        
        // If animation is not running, update the view immediately
        if (!animationId && routeCoordinates.length > 0) {
          updateInitialMapView();
        }
      });
      
      speedControl.addEventListener('input', () => {
        animationSpeed = parseFloat(speedControl.value);
      });
      
      // Follow path toggle handler
      const followPathToggle = document.getElementById('follow-path-toggle');
      if (followPathToggle) {
        followPathToggle.addEventListener('change', () => {
          followPath = followPathToggle.checked;
          console.log('Follow path toggled:', followPath);
          
          // When disabling follow path, enable map interaction
          if (!followPath) {
            console.log('Enabling map interactions');
            map.boxZoom.enable();
            map.scrollZoom.enable();
            map.dragPan.enable();
            map.dragRotate.enable();
            map.keyboard.enable();
            map.doubleClickZoom.enable();
            map.touchZoomRotate.enable();
          } else {
            console.log('Disabling map interactions');
            // When enabling follow path, disable map interaction to avoid conflicts
            map.boxZoom.disable();
            map.scrollZoom.disable();
            map.dragPan.disable();
            map.dragRotate.disable();
            map.keyboard.disable();
            map.doubleClickZoom.disable();
            map.touchZoomRotate.disable();
          }
        });
      } else {
        console.error('Follow path toggle element not found');
      }
      
      // Position control via overlay - supports both click and drag
      const positionOverlay = document.getElementById('position-overlay');
      let isDragging = false;
      
      // Function to update position based on mouse/touch coordinates
      function updatePositionFromEvent(e) {
        const rect = positionOverlay.getBoundingClientRect();
        const clientX = e.clientX || (e.touches && e.touches[0] ? e.touches[0].clientX : 0);
        const clickX = clientX - rect.left;
        const width = rect.width;
        const positionPercent = Math.max(0, Math.min(1, clickX / width));
        
        // Update slider value
        positionSlider.value = positionPercent * 100;
        
        if (animationId) {
          // Animation is running - update the current position directly
          const totalDistanceMeters = routeDistances[routeDistances.length - 1] * 1000; // km to m
          currentRouteDistance = positionPercent * totalDistanceMeters;
          
          // Clamp to valid range
          currentRouteDistance = Math.max(0, Math.min(currentRouteDistance, totalDistanceMeters));
        } else {
          // Animation is stopped - use the existing manual positioning function
          updatePositionManually(positionPercent);
        }
      }
      
      // Mouse events for dragging
      positionOverlay.addEventListener('mousedown', (e) => {
        isDragging = true;
        userAdjustingPosition = true;
        updatePositionFromEvent(e);
        e.preventDefault();
      });
      
      document.addEventListener('mousemove', (e) => {
        if (isDragging) {
          updatePositionFromEvent(e);
          e.preventDefault();
          e.stopPropagation(); // Prevent event from bubbling to map
        }
      });
      
      document.addEventListener('mouseup', (e) => {
        if (isDragging) {
          isDragging = false;
          setTimeout(() => {
            userAdjustingPosition = false;
          }, 100);
          e.stopPropagation(); // Prevent event from bubbling to map
        }
      });
      
      // Touch events for mobile dragging
      positionOverlay.addEventListener('touchstart', (e) => {
        isDragging = true;
        userAdjustingPosition = true;
        updatePositionFromEvent(e);
        e.preventDefault();
      });
      
      document.addEventListener('touchmove', (e) => {
        if (isDragging) {
          updatePositionFromEvent(e);
          e.preventDefault();
          e.stopPropagation(); // Prevent event from bubbling to map
        }
      });
      
      document.addEventListener('touchend', (e) => {
        if (isDragging) {
          isDragging = false;
          setTimeout(() => {
            userAdjustingPosition = false;
          }, 100);
          e.stopPropagation(); // Prevent event from bubbling to map
        }
      });
      
      // Keep the click handler for single clicks
      positionOverlay.addEventListener('click', (e) => {
        if (!isDragging) { // Only handle click if we weren't dragging
          userAdjustingPosition = true;
          updatePositionFromEvent(e);
          setTimeout(() => {
            userAdjustingPosition = false;
          }, 100);
        }
      });
    });
    
    // Function to parse URL parameters and hash fragments
    function parseUrlParams() {
      // Check for route parameter in the URL query string
      const urlParams = new URLSearchParams(window.location.search);
      const routeParam = urlParams.get('route');
      
      // Check for route in the hash fragment (e.g. #route=D1_East_Long.gpx)
      const hashParams = new URLSearchParams(window.location.hash.substring(1));
      const hashRoute = hashParams.get('route');
      
      // Use the parameter from query string or hash if available
      const requestedRoute = routeParam || hashRoute;
      
      if (requestedRoute) {
        // Find the matching option in the select element
        const options = Array.from(document.getElementById('route-select').options);
        const matchingOption = options.find(option => option.value === requestedRoute);
        
        if (matchingOption) {
          // Set the select element to the requested route
          document.getElementById('route-select').value = requestedRoute;
          return requestedRoute;
        }
      }
      
      // Return default route if no valid route parameter found
      return document.getElementById('route-select').value;
    }
  </script>
</body>
</html>
